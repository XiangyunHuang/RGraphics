[
["index.html", "数据科学与 R 语言 Data Science with R 欢迎 Why R 目标读者 获取帮助 发展历史 记号约定 运行环境", " 数据科学与 R 语言 Data Science with R 黄湘云 2020-02-05 13:14:51 CST 欢迎 这本书还处于一个很早期的阶段 Why R GNU R 是发布在 GPL-2/3 下的开源自由软件，意味着只要你遵循该协议，就可以自由地获取、修改和发布R 源代码，R 本身的这种开源自由的属性，决定你可以免费地使用它。《The Art of R Programming》的作者 Norm Matloff 给出使用 R 语言的四个优势：它是统计学家开发的，也是为统计学家打造的；内建的矩阵类型和矩阵操作非常高效；不管是来自基础 R 还是 CRAN 上的绘图包，都提供强大的绘图功能；还有优秀的并行能力1，最近他更是在数据科学中全面比较了 R 与 Python2。关于 R 语言和 Python 语言的对比，网络上充斥着很多的文章，除了赞扬，还有表示反对的声音，如 R语言采用的对 GPL 协议3，甚至有人列举了逃离 R 语言阵营的10大上榜理由4，datacamp 提供了一份较为完整的对比图，仅供参考5。如果你是学统计的学生或者数据分析师，我都建议你先学习 R6，如果你是社会科学的学生和研究者， R 社区开发了 GUI 工具，如 Rcmdr 和 rattle，还有基于 Shiny 的分析工具 radiant 和类似 SPSS 的 JASP。 R 语言比较遭人诟病的大概有： R 包总体数量已达到 15000+，年度增长速度大约在 4.6% 左右，很多 R 包都在重复造轮子，且 R 包之间依赖关系非常复杂。若与 Python 作一个对比，所有的 R 包和 Python 模块必须处于活跃维护，拥有大批粉丝，维护者在社区内享有声誉，有厂子或科研经费支持。我们不打嘴仗，不下结论，只做对比，不完善之处还请大家指出并补充，见表 0.1。 每个 Base R 包内的函数非常多，参数也非常多，功能涉及方方面面，初学者学习起来难度非常大！数据处理和可视化常用基本包最流行的 tidyverse 系列和基础 R 系统存在很多不一致，在不清楚的情况下很难掌握，而陷于已有的函数不能自拔！ R 是面向对象的程序设计语言，是解释性的语言，也是函数式编程语言，包含的程序设计风格非常多，仅面向对象的设计就有 S3、 S4、 RC、 R5 和 R6。每一个操作都是函数调用，一切皆是对象的环境和闭包概念简洁又复杂。 R 内置的数据结构非常多，原子类型的有字符、布尔、整型、复数、双精度浮点、单精度浮点等，此外常见的还有数据框、列表。每个特定的领域往往还有特殊的类型，如时间序列 ts、zoo 等， 空间对象 sp、 raster 和 sf 等。 深入学习 R 实现的统计模型，如 lm、glm 等，你可能会发现统计学家的程序设计思维如此难懂。 Thomas Lumley, “R Fundamentals and Programming Techniques” https://faculty.washington.edu/tlumley/Rcourse/R-fundamentals.pdf 表 0.1: R 与 Python 常用模块对照表 比较内容 具体范围 R 包 Python 模块 数据获取 本地、数据库、远程 内置，RCurl、XML、rvest、data.table、 odbc scrapy 数据清理 正则表达式 内置，stringi、stringr、tidyr re 数据聚合 SQL支持的所有操作 内置，dplyr、purrr、dbplyr、sparklyr Numpy、Scipy、Pandas 数据分析 统计推断的所有方法 内置，lme4、rstan、mxnet、xgoost、 tensorflow xgboost、scikit-learn、tensorflow、mxnet 数据展示 数据可视化 内置，ggplot2、plotly matplotlib、bokeh、plotly 数据报告 网页文档、幻灯片 rmarkdown、bookdown、blogdown 数据落地 模型部署，调优，维护 plumber、opencpu、fiery 目标读者 本书起源于自己的学习笔记，侧重统计图形，当然也包括在制作统计图形之前的数据导入和ETL操作，后续的数据可视化。本书的目标可以是接触过 R 语言的读者，也可以是零基础者，书的内容侧重数据处理和可视化分析，数据建模的部分比较少。 获取帮助 R 语言官网给出了一份如何获取帮助的指导 https://www.r-project.org/help.html，RStudio 公司也总结了一份 Getting Help with R，又及 https://blog.rsquaredacademy.com/getting-help-in-r-updated/ 发展历史 GNU R 最初由 Ross Ihaka 和 Robert Gentleman 开发，它脱胎于 S 语言，S 语言形成于大名鼎鼎的美国贝尔实验室，距今已有40多年的历史了7，R语言的前世今生8，Ross Ihaka 总结了过去的经验，展望了 R 语言未来发展的方向9。 记号约定 写作风格，R 包名称都加粗表示，如 bookdown， rmarkdown 等，软件、编程语言名称保持原样，如 TinyTeX，LyX，TeXLive，R，Python，Stan，C++，SQL等，在代码块中，我们不使用R&gt;或+，代码输出结果用#&gt;注释。knitr (Xie 2015)、 bookdown (Xie 2016)、 Pandoc 和 TinyTeX ，请使用 XeLaTeX 编译这本书，等宽字体为 inconsolata 默认的文本字体为 Times 运行环境 重现书籍本节内容需要的 R 包列表如下 xfun::session_info(c(&quot;rmarkdown&quot;, &quot;bookdown&quot;)) #&gt; R Under development (unstable) (2020-02-04 r77771) #&gt; Platform: x86_64-pc-linux-gnu (64-bit) #&gt; Running under: Ubuntu 16.04.6 LTS #&gt; #&gt; Locale: #&gt; LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C #&gt; LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 #&gt; LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 #&gt; LC_PAPER=en_US.UTF-8 LC_NAME=C #&gt; LC_ADDRESS=C LC_TELEPHONE=C #&gt; LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C #&gt; #&gt; Package version: #&gt; base64enc_0.1.3 bookdown_0.17 digest_0.6.23 evaluate_0.14 #&gt; glue_1.3.1 graphics_4.0.0 grDevices_4.0.0 highr_0.8 #&gt; htmltools_0.4.0 jsonlite_1.6.1 knitr_1.26 magrittr_1.5 #&gt; markdown_1.1 methods_4.0.0 mime_0.9 Rcpp_1.0.3 #&gt; rlang_0.4.4 rmarkdown_2.1 stats_4.0.0 stringi_1.4.5 #&gt; stringr_1.4.0 tinytex_0.19 tools_4.0.0 utils_4.0.0 #&gt; xfun_0.12 yaml_2.2.1 #&gt; #&gt; Pandoc version: 2.7.3 本书要求 R 软件版本 4.0.0 因为书中涉及 barplot 新增的公式方法，新增多维数组操作函数 asplit， axis 函数的 gap.axis ，新增 hcl.colors 函数等，完整列表见官网 What’s New? 书籍同时使用 bookdown.org 和 netlify 部署，网址分别是 https://bookdown.org/xiangyun/RGraphics/ 和 https://r-graphics.netlify.com/ 参考文献 "],
["preface.html", "前言 关于本书 本书结构 关于作者", " 前言 关于本书 这里写每章的主要内容介绍 本书结构 关于作者 热心开源事业，统计之都副主编，经常混迹于统计之都论坛、Github 和爆栈网。个人主页 https://www.xiangyunhuang.com.cn/ "],
["setup.html", "第 1 章 安装与配置 1.1 仓库安装 1.2 源码安装 1.3 忍者安装 1.4 配置 1.5 命令行参数", " 第 1 章 安装与配置 主要参考 R-admin 1.1 仓库安装 1.1.1 Ubuntu 安装 openssh zsh 和 Git sudo apt-get install zsh openssh-server sudo add-apt-repository -y ppa:git-core/ppa sudo apt update &amp;&amp; sudo apt install git sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 只考虑最新的 Ubuntu 18.04 因为本书写成的时候，该版本应该已经大规模使用了，默认版本的安装和之前版本的安装就不再展示了。安装最新版 R-3.5.x，无论安装哪个版本，都要先导入密钥 sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv E084DAB9 Ubuntu 14.04.5 提供的默认版本 R 3.0.2，安装 R 3.5.x 系列之前的版本，如 R 3.4.4 sudo apt-add-repository -y &quot;deb http://cran.rstudio.com/bin/linux/ubuntu `lsb_release -cs`/&quot; sudo apt-get install r-base-dev 添加完仓库后，都需要更新源sudo apt-get update，安装 R 3.5.x 系列最新版 sudo apt-add-repository -y &quot;deb https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/linux/ubuntu trusty-cran35/&quot; Ubuntu 16.04.5 提供的默认版本 R 3.4.4，这是 R 3.4.x 系列的最新版，安装目前最新的 R 3.5.x 版本需要 sudo apt-add-repository -y &quot;deb https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/linux/ubuntu xenial-cran35/&quot; Ubuntu 18.04.1 提供的默认版本 R 3.4.4，安装目前的最新版本需要 sudo apt-add-repository -y &quot;deb https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/linux/ubuntu bionic-cran35/&quot; 接下来安装 R，详细安装指导见 CRAN 官网。 sudo apt-get install -y r-base-dev Michael Rutter 维护了编译好的二进制版本 https://launchpad.net/~marutter，比如 rstan 包可以通过安装 r-cran-rstan 完成 # R packages for Ubuntu LTS. Based on CRAN Task Views. sudo add-apt-repository -y ppa:marutter/c2d4u3.5 sudo apt-get install r-cran-rstan 1.1.2 CentOS 同样适用于 Fedora 安装指导10 1.2 源码安装 1.2.1 Ubuntu 首先启用源码仓库，否则执行 sudo apt-get build-dep r-base 会报如下错误 E: You must put some &#39;source&#39; URIs in your sources.list sudo sed -i -- &#39;s/#deb-src/deb-src/g&#39; /etc/apt/sources.list &amp;&amp; sudo sed -i -- &#39;s/# deb-src/deb-src/g&#39; /etc/apt/sources.list sudo apt-get update 安装编译 R 所需的系统依赖 sudo apt-get build-dep r-base-dev 编译安装 R ./configure make &amp;&amp; make install 自定义编译选项 ./configure --help 1.2.2 CentOS 基于 CentOS 7 和 GCC 4.8.5，参考 R-admin 手册 下载源码包 最新发布的稳定版 curl -fLo ./R-latest.tar.gz https://mirrors.tuna.tsinghua.edu.cn/CRAN/src/base/R-latest.tar.gz % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 10 28.7M 10 3232k 0 0 107k 0 0:04:34 0:00:30 0:04:04 118k 安装依赖 sudo yum install -y yum-utils epel-release &amp;&amp; sudo yum-builddep R-devel sudo dnf update &amp;&amp; sudo dnf builddep R-devel # Fedora 30 解压配置 mkdir R-latest &amp;&amp; tar -xzf ./R-latest.tar.gz -C ./R-latest &amp;&amp; cd R-3.5.2 ./configure --enable-R-shlib --enable-byte-compiled-packages \\ --enable-BLAS-shlib --enable-memory-profiling R is now configured for x86_64-pc-linux-gnu Source directory: . Installation directory: /usr/local C compiler: gcc -std=gnu99 -g -O2 Fortran 77 compiler: gfortran -g -O2 Default C++ compiler: g++ -g -O2 C++98 compiler: g++ -std=gnu++98 -g -O2 C++11 compiler: g++ -std=gnu++11 -g -O2 C++14 compiler: C++17 compiler: Fortran 90/95 compiler: gfortran -g -O2 Obj-C compiler: gcc -g -O2 -fobjc-exceptions Interfaces supported: X11, tcltk External libraries: readline, curl Additional capabilities: PNG, JPEG, TIFF, NLS, cairo, ICU Options enabled: shared R library, shared BLAS, R profiling, memory profiling Capabilities skipped: Options not enabled: Recommended packages: yes 编译安装 make -j 2 all sudo make install BLAS 加持（可选） BLAS 对于加快矩阵计算至关重要，编译 R 带 BLAS 支持，添加 OpenBLAS 支持 --with-blas=\"-lopenblas\" 或 ATLAS 支持 --with-blas=\"-L/usr/lib64/atlas -lsatlas\" sudo yum install -y openblas openblas-threads openblas-openmp ./configure --enable-R-shlib --enable-byte-compiled-packages \\ --enable-BLAS-shlib --enable-memory-profiling \\ --with-blas=&quot;-lopenblas&quot; R is now configured for x86_64-pc-linux-gnu Source directory: . Installation directory: /usr/local C compiler: gcc -std=gnu99 -g -O2 Fortran 77 compiler: gfortran -g -O2 Default C++ compiler: g++ -g -O2 C++98 compiler: g++ -std=gnu++98 -g -O2 C++11 compiler: g++ -std=gnu++11 -g -O2 C++14 compiler: C++17 compiler: Fortran 90/95 compiler: gfortran -g -O2 Obj-C compiler: gcc -g -O2 -fobjc-exceptions Interfaces supported: X11, tcltk External libraries: readline, **BLAS(OpenBLAS)**, curl Additional capabilities: PNG, JPEG, TIFF, NLS, cairo, ICU Options enabled: shared R library, shared BLAS, R profiling, memory profiling Capabilities skipped: Options not enabled: Recommended packages: yes 配置成功的标志，如 OpenBLAS checking for dgemm_ in -lopenblas... yes checking whether double complex BLAS can be used... yes checking whether the BLAS is complete... yes ATLAS 加持 sudo yum install -y atlas ./configure --enable-R-shlib --enable-byte-compiled-packages \\ --enable-BLAS-shlib --enable-memory-profiling \\ --with-blas=&quot;-L/usr/lib64/atlas -lsatlas&quot; R is now configured for x86_64-pc-linux-gnu Source directory: . Installation directory: /usr/local C compiler: gcc -std=gnu99 -g -O2 Fortran 77 compiler: gfortran -g -O2 Default C++ compiler: g++ -g -O2 C++98 compiler: g++ -std=gnu++98 -g -O2 C++11 compiler: g++ -std=gnu++11 -g -O2 C++14 compiler: C++17 compiler: Fortran 90/95 compiler: gfortran -g -O2 Obj-C compiler: gcc -g -O2 -fobjc-exceptions Interfaces supported: X11, tcltk External libraries: readline, **BLAS(generic)**, curl Additional capabilities: PNG, JPEG, TIFF, NLS, cairo, ICU Options enabled: shared R library, shared BLAS, R profiling, memory profiling Capabilities skipped: Options not enabled: Recommended packages: yes ATLAS 配置成功 checking for dgemm_ in -L/usr/lib64/atlas -lsatlas... yes checking whether double complex BLAS can be used... yes checking whether the BLAS is complete... yes 后续步骤同上 1.3 忍者安装 从源码自定义安装：加速 Intel MKL 和 大文件支持 https://software.intel.com/en-us/articles/using-intel-mkl-with-r 1.4 配置 1.4.1 初始会话 .Rprofile .Rprofile 文件位于 ~/ 目录下或者 R 项目的根目录下 查看帮助 ?.Rprofile 更多配置设置 startup 1.4.2 环境变量 .Renviron .Renviron 文件位于 ~/ 目录下 1.4.3 编译选项 Makevars Makevars 文件位于 ~/.R/ 目录下 1.5 命令行参数 commandArgs 从终端命令行中传递参数 rdoc 高亮 R 帮助文档中的 R 函数、关键字 NULL。启用需要在R控制台中执行 rdoc::use_rdoc() radian 代码自动补全和语法高亮，进入 R 控制台，终端中输入radian docopt 提供R命令行工具，如 littler 包，getopt 从终端命令行接受参数 optparse 命令行选项参数的解析器 安装完 R-littler R-littler-examples (centos) 或 littler r-cran-littler (ubuntu) 后，执行 # centos sudo ln -s /usr/lib64/R/library/littler/examples/install.r /usr/bin/install.r sudo ln -s /usr/lib64/R/library/littler/examples/install2.r /usr/bin/install2.r sudo ln -s /usr/lib64/R/library/littler/examples/installGithub.r /usr/bin/installGithub.r sudo ln -s /usr/lib64/R/library/littler/examples/testInstalled.r /usr/bin/testInstalled.r # ubuntu sudo ln -s /usr/lib/R/site-library/littler/examples/install.r /usr/bin/install.r sudo ln -s /usr/lib/R/site-library/littler/examples/install2.r /usr/bin/install2.r sudo ln -s /usr/lib/R/site-library/littler/examples/installGithub.r /usr/bin/installGithub.r sudo ln -s /usr/lib/R/site-library/littler/examples/testInstalled.r /usr/bin/testInstalled.r 这样可以载终端中安装 R 包了 install.r docopt #!/usr/bin/env Rscript # 安装 optparse 提供更加灵活的传参方式 # 也可参考 littler https://github.com/eddelbuettel/littler # if(&quot;optparse&quot; %in% .packages(TRUE)) install.packages(&#39;optparse&#39;,repos = &quot;https://cran.rstudio.com&quot;) # https://cran.r-project.org/doc/manuals/R-intro.html#Invoking-R-from-the-command-line # http://www.cureffi.org/2014/01/15/running-r-batch-mode-linux/ args = commandArgs(trailingOnly=TRUE) # 函数功能：在浏览器中同时打开多个 PDF 文档 open_pdf &lt;- function(pdf_path = &quot;./figures/&quot;, n = 1) { # pdf_path: PDF文件所在目录 # n: 默认打开1个PDF文档 # PDF文档目录 pdfs &lt;- list.files(pdf_path, pattern = &#39;\\\\.pdf$&#39;) # PDF 文档路径 path_to_pdfs &lt;- paste(pdf_path, pdfs, sep = .Platform$file.sep) # 打开 PDF 文档 invisible(lapply(head(path_to_pdfs, n), browseURL)) } open_pdf(pdf_path, n = args[1]) # 使用： Rscript --vanilla code/batch-open-pdf.R 20 在 CentOS 7 上打造 R 语言编程环境↩︎ "],
["files.html", "第 2 章 文件管理员 2.1 查看文件 2.2 操作文件 2.3 压缩文件 2.4 路径操作 2.5 查找文件 2.6 文件权限 2.7 区域设置 2.8 进程管理 2.9 系统命令 2.10 时间管理 2.11 R 包管理 2.12 查找函数 2.13 运行环境", " 第 2 章 文件管理员 考虑添加 Shell 下的命令实现，参考 命令行的艺术 library(magrittr) # 提供管道命令 %&gt;% fs 由 Jim Hester 开发，提供文件系统操作的统一接口，相比于 R 默认的文件系统的操作函数有显而易见的优点，详情请看 https://fs.r-lib.org/ 对于文件操作，Jim Hester 开发了 fs 包 目的是统一文件操作的命令，由于时间和历史原因，R内置的文件操作函数的命名很不统一，如 path.expand() 和 normalizePath()，Sys.chmod() 和 file.access() 等 # 加载 R 包 library(fs) 2.1 查看文件 文件夹只包含文件，目录既包含文件又包含文件夹，list.dirs 列出目录或文件夹，list.files 列出文件或文件夹 list.dirs(path = \".\", full.names = TRUE, recursive = TRUE) path: 指定完整路径名，默认使用当前路径 getwd() full.names: TRUE 返回相对路径，FALSE 返回目录的名称 recursive: 是否递归的方式列出目录，如果是的话，目录下的子目录也会列出 # list.dirs(path = &#39;.&#39;, full.names = TRUE, recursive = TRUE) list.dirs(path = &#39;.&#39;, full.names = TRUE, recursive = FALSE) #&gt; [1] &quot;./_book&quot; &quot;./_bookdown_files&quot; #&gt; [3] &quot;./.git&quot; &quot;./animated-graphics_files&quot; #&gt; [5] &quot;./cs-cran-network_files&quot; &quot;./data&quot; #&gt; [7] &quot;./data-frame_cache&quot; &quot;./data-frame_files&quot; #&gt; [9] &quot;./data-import_cache&quot; &quot;./data-objects_cache&quot; #&gt; [11] &quot;./data-table_cache&quot; &quot;./data-tibble_cache&quot; #&gt; [13] &quot;./dc-regular-expressions_cache&quot; &quot;./dc-string-manipulation_cache&quot; #&gt; [15] &quot;./demos&quot; &quot;./dv-colors-fonts_cache&quot; #&gt; [17] &quot;./dv-colors-fonts_files&quot; &quot;./dv-ggplot2_cache&quot; #&gt; [19] &quot;./dv-ggplot2_files&quot; &quot;./dv-highcharter_cache&quot; #&gt; [21] &quot;./dv-highcharter_files&quot; &quot;./dv-lattice_cache&quot; #&gt; [23] &quot;./dv-lattice_files&quot; &quot;./dv-plot_cache&quot; #&gt; [25] &quot;./dv-plot_files&quot; &quot;./dv-plot3d_cache&quot; #&gt; [27] &quot;./dv-plot3d_files&quot; &quot;./dv-plotly_cache&quot; #&gt; [29] &quot;./dv-spatio-temporal_files&quot; &quot;./dynamic-documents_cache&quot; #&gt; [31] &quot;./dynamic-documents_files&quot; &quot;./figures&quot; #&gt; [33] &quot;./files_cache&quot; &quot;./includes&quot; #&gt; [35] &quot;./index_cache&quot; &quot;./interactives&quot; #&gt; [37] &quot;./preface_cache&quot; &quot;./ubuntu&quot; list.dirs(path = &#39;.&#39;, full.names = FALSE, recursive = FALSE) #&gt; [1] &quot;_book&quot; &quot;_bookdown_files&quot; #&gt; [3] &quot;.git&quot; &quot;animated-graphics_files&quot; #&gt; [5] &quot;cs-cran-network_files&quot; &quot;data&quot; #&gt; [7] &quot;data-frame_cache&quot; &quot;data-frame_files&quot; #&gt; [9] &quot;data-import_cache&quot; &quot;data-objects_cache&quot; #&gt; [11] &quot;data-table_cache&quot; &quot;data-tibble_cache&quot; #&gt; [13] &quot;dc-regular-expressions_cache&quot; &quot;dc-string-manipulation_cache&quot; #&gt; [15] &quot;demos&quot; &quot;dv-colors-fonts_cache&quot; #&gt; [17] &quot;dv-colors-fonts_files&quot; &quot;dv-ggplot2_cache&quot; #&gt; [19] &quot;dv-ggplot2_files&quot; &quot;dv-highcharter_cache&quot; #&gt; [21] &quot;dv-highcharter_files&quot; &quot;dv-lattice_cache&quot; #&gt; [23] &quot;dv-lattice_files&quot; &quot;dv-plot_cache&quot; #&gt; [25] &quot;dv-plot_files&quot; &quot;dv-plot3d_cache&quot; #&gt; [27] &quot;dv-plot3d_files&quot; &quot;dv-plotly_cache&quot; #&gt; [29] &quot;dv-spatio-temporal_files&quot; &quot;dynamic-documents_cache&quot; #&gt; [31] &quot;dynamic-documents_files&quot; &quot;figures&quot; #&gt; [33] &quot;files_cache&quot; &quot;includes&quot; #&gt; [35] &quot;index_cache&quot; &quot;interactives&quot; #&gt; [37] &quot;preface_cache&quot; &quot;ubuntu&quot; list.files(path = \".\", pattern = NULL, all.files = FALSE, full.names = FALSE, recursive = FALSE,ignore.case = FALSE, include.dirs = FALSE, no.. = FALSE) 是否递归的方式列出目录，如果是的话，目录下的子目录也会列出 path: 指定完整路径名，默认使用当前路径 getwd() full.names: TRUE 返回相对路径，FALSE 返回目录的名称 recursive: 是否递归的方式列出目录，如果是的话，目录下的子目录也会列出 file.show(..., header = rep(\"\", nfiles), title = \"R Information\", delete.file = FALSE, pager = getOption(\"pager\"),encoding = \"\") 打开文件内容，file.show 会在R终端中新开一个窗口显示文件 rinternals &lt;- file.path(R.home(&quot;include&quot;), &quot;Rinternals.h&quot;) # file.show(rinternals) file.info(..., extra_cols = TRUE) 获取文件信息，此外 file.mode(...) 、 file.mtime(...) 和 file.size(...) 分别表示文件的读写权限，修改时间和文件大小。 file.info(rinternals) #&gt; size isdir mode #&gt; /home/travis/R-bin/lib/R/include/Rinternals.h 62539 FALSE 644 #&gt; mtime #&gt; /home/travis/R-bin/lib/R/include/Rinternals.h 2020-02-04 21:19:55 #&gt; ctime #&gt; /home/travis/R-bin/lib/R/include/Rinternals.h 2020-02-05 13:09:12 #&gt; atime uid gid #&gt; /home/travis/R-bin/lib/R/include/Rinternals.h 2020-02-05 13:09:12 2000 2000 #&gt; uname grname #&gt; /home/travis/R-bin/lib/R/include/Rinternals.h travis travis file.mode(rinternals) #&gt; [1] &quot;644&quot; file.mtime(rinternals) #&gt; [1] &quot;2020-02-04 21:19:55 CST&quot; file.size(rinternals) #&gt; [1] 62539 # 查看当前目录的权限 file.info(&quot;.&quot;) #&gt; size isdir mode mtime ctime atime #&gt; . 4096 TRUE 775 2020-02-05 13:14:52 2020-02-05 13:14:52 2020-02-05 13:14:53 #&gt; uid gid uname grname #&gt; . 2000 2000 travis travis # 查看指定目录权限 file.info(&quot;./_book/&quot;) #&gt; size isdir mode mtime ctime #&gt; ./_book/ 4096 TRUE 775 2020-02-05 13:14:50 2020-02-05 13:14:50 #&gt; atime uid gid uname grname #&gt; ./_book/ 2020-02-05 13:14:50 2000 2000 travis travis file.access(names, mode = 0) 文件是否可以被访问，第二个参数 mode 一共有四种取值 0，1，2，4，分别表示文件的存在性，可执行，可写和可读四种，返回值 0 表示成功，返回值 -1 表示失败。 file.access(rinternals,mode = 0) #&gt; /home/travis/R-bin/lib/R/include/Rinternals.h #&gt; 0 file.access(rinternals,mode = 1) #&gt; /home/travis/R-bin/lib/R/include/Rinternals.h #&gt; -1 file.access(rinternals,mode = 2) #&gt; /home/travis/R-bin/lib/R/include/Rinternals.h #&gt; 0 file.access(rinternals,mode = 4) #&gt; /home/travis/R-bin/lib/R/include/Rinternals.h #&gt; 0 dir(path = \".\", pattern = NULL, all.files = FALSE, full.names = FALSE, recursive = FALSE, ignore.case = FALSE, include.dirs = FALSE, no.. = FALSE) 查看目录，首先看看和目录操作有关的函数列表 apropos(&quot;^dir.&quot;) #&gt; [1] &quot;dir_copy&quot; &quot;dir_create&quot; &quot;dir_delete&quot; &quot;dir_exists&quot; &quot;dir_info&quot; #&gt; [6] &quot;dir_ls&quot; &quot;dir_map&quot; &quot;dir_tree&quot; &quot;dir_walk&quot; &quot;dir.create&quot; #&gt; [11] &quot;dir.exists&quot; &quot;dirname&quot; 显而易见，dir.create 和 dir.exists 分别是创建目录和查看目录的存在性。dirname 和 basename 是一对函数用来操作文件路径。以当前目录/home/travis/build/XiangyunHuang/RGraphics为例，dirname(getwd()) 返回 /home/travis/build/XiangyunHuang 而 basename(getwd()) 返回 RGraphics。对于文件路径而言，dirname(rinternals) 返回文件所在的目录/home/travis/R-bin/lib/R/include， basename(rinternals) 返回文件名Rinternals.h。dir 函数查看指定路径或目录下的文件，支持以模式匹配和递归的方式查找目录下的文件 # 当前目录下的子目录和文件 dir() #&gt; [1] &quot;_book&quot; &quot;_bookdown_files&quot; #&gt; [3] &quot;_bookdown.yml&quot; &quot;_build.sh&quot; #&gt; [5] &quot;_common.R&quot; &quot;_deploy.sh&quot; #&gt; [7] &quot;_main.rds&quot; &quot;_output.yml&quot; #&gt; [9] &quot;_render.R&quot; &quot;99-references.Rmd&quot; #&gt; [11] &quot;Adobe-Fonts.zip&quot; &quot;animated-graphics_files&quot; .... # 查看指定目录的子目录和文件 dir(path = &quot;./&quot;) #&gt; [1] &quot;_book&quot; &quot;_bookdown_files&quot; #&gt; [3] &quot;_bookdown.yml&quot; &quot;_build.sh&quot; #&gt; [5] &quot;_common.R&quot; &quot;_deploy.sh&quot; #&gt; [7] &quot;_main.rds&quot; &quot;_output.yml&quot; #&gt; [9] &quot;_render.R&quot; &quot;99-references.Rmd&quot; #&gt; [11] &quot;Adobe-Fonts.zip&quot; &quot;animated-graphics_files&quot; .... # 只列出以字母R开头的子目录和文件 dir(path = &quot;./&quot;, pattern = &quot;^R&quot;) #&gt; [1] &quot;README.md&quot; &quot;RGraphics.Rproj&quot; # 列出目录下所有目录和文件，包括隐藏文件 dir(path = &quot;./&quot;, all.files = TRUE) #&gt; [1] &quot;_book&quot; &quot;_bookdown_files&quot; #&gt; [3] &quot;_bookdown.yml&quot; &quot;_build.sh&quot; #&gt; [5] &quot;_common.R&quot; &quot;_deploy.sh&quot; #&gt; [7] &quot;_main.rds&quot; &quot;_output.yml&quot; #&gt; [9] &quot;_render.R&quot; &quot;.&quot; #&gt; [11] &quot;..&quot; &quot;.git&quot; .... # 支持正则表达式 dir(pattern = &#39;^[A-Z]+[.]txt$&#39;, full.names=TRUE, system.file(&#39;doc&#39;, &#39;SuiteSparse&#39;, package=&#39;Matrix&#39;)) #&gt; [1] &quot;/home/travis/R-bin/lib/R/library/Matrix/doc/SuiteSparse/AMD.txt&quot; #&gt; [2] &quot;/home/travis/R-bin/lib/R/library/Matrix/doc/SuiteSparse/CHOLMOD.txt&quot; #&gt; [3] &quot;/home/travis/R-bin/lib/R/library/Matrix/doc/SuiteSparse/COLAMD.txt&quot; #&gt; [4] &quot;/home/travis/R-bin/lib/R/library/Matrix/doc/SuiteSparse/SPQR.txt&quot; # 在临时目录下递归创建一个目录 dir.create(paste0(tempdir(), &quot;/_book/tmp&quot;), recursive = TRUE) 查看当前目录下的文件和文件夹 tree -L 2 . 或者 ls -l . 2.2 操作文件 实现文件增删改查的函数如下 apropos(&quot;^file.&quot;) #&gt; [1] &quot;file_access&quot; &quot;file_chmod&quot; &quot;file_chown&quot; &quot;file_copy&quot; #&gt; [5] &quot;file_create&quot; &quot;file_delete&quot; &quot;file_exists&quot; &quot;file_info&quot; #&gt; [9] &quot;file_move&quot; &quot;file_show&quot; &quot;file_size&quot; &quot;file_temp&quot; #&gt; [13] &quot;file_temp_pop&quot; &quot;file_temp_push&quot; &quot;file_test&quot; &quot;file_touch&quot; #&gt; [17] &quot;file.access&quot; &quot;file.append&quot; &quot;file.choose&quot; &quot;file.copy&quot; #&gt; [21] &quot;file.create&quot; &quot;file.edit&quot; &quot;file.exists&quot; &quot;file.info&quot; #&gt; [25] &quot;file.link&quot; &quot;file.mode&quot; &quot;file.mtime&quot; &quot;file.path&quot; #&gt; [29] &quot;file.remove&quot; &quot;file.rename&quot; &quot;file.show&quot; &quot;file.size&quot; #&gt; [33] &quot;file.symlink&quot; &quot;fileSnapshot&quot; file.create(..., showWarnings = TRUE) 创建/删除文件，检查文件的存在性 file.create(&#39;demo.txt&#39;) #&gt; [1] TRUE file.exists(&#39;demo.txt&#39;) #&gt; [1] TRUE file.remove(&#39;demo.txt&#39;) #&gt; [1] TRUE file.exists(&#39;demo.txt&#39;) #&gt; [1] FALSE file.rename(from, to) 文件重命名 file.create(&#39;demo.txt&#39;) #&gt; [1] TRUE file.rename(from = &#39;demo.txt&#39;, to = &#39;tmp.txt&#39;) #&gt; [1] TRUE file.exists(&#39;tmp.txt&#39;) #&gt; [1] TRUE file.append(file1, file2) 追加文件 file2 的内容到文件 file1 上 if(!dir.exists(paths = &#39;data/&#39;)) dir.create(path = &#39;data/&#39;) # 创建两个临时文件 # file.create(c(&#39;data/tmp1.md&#39;,&#39;data/tmp2.md&#39;)) # 写入内容 cat(&quot;AAA\\n&quot;, file = &#39;data/tmp1.md&#39;) cat(&quot;BBB\\n&quot;, file = &#39;data/tmp2.md&#39;) # 追加文件 file.append(file1 = &#39;data/tmp1.md&#39;, file2 = &#39;data/tmp2.md&#39;) #&gt; [1] TRUE # 展示文件内容 readLines(&#39;data/tmp1.md&#39;) #&gt; [1] &quot;AAA&quot; &quot;BBB&quot; file.copy(from, to, overwrite = recursive, recursive = FALSE,copy.mode = TRUE, copy.date = FALSE) 复制文件，参考 https://blog.csdn.net/wzj_110/article/details/86497860 file.copy(from = &#39;Makefile&#39;, to = &#39;data/Makefile&#39;) #&gt; [1] TRUE file.symlink(from, to) 创建符号链接 file.link(from, to) 创建硬链接 Sys.junction(from, to) windows 平台上的函数，提供类似符号链接的功能 Sys.readlink(paths) 读取文件的符号链接（软链接） choose.files 在 Windows 环境下交互式地选择一个或多个文件，所以该函数只运行于 Windows 环境 # 选择 zip 格式的压缩文件或其它 if (interactive()) choose.files(filters = Filters[c(&quot;zip&quot;, &quot;All&quot;),]) Filters 参数传递一个矩阵，用来描述或标记R识别的文件类型，上面这个例子就能筛选出 zip 格式的文件 download.file 文件下载 download.file(url = &#39;https://mirrors.tuna.tsinghua.edu.cn/CRAN/src/base/R-latest.tar.gz&#39;, destfile = &#39;data/R-latest.tar.gz&#39;, method = &#39;auto&#39;) 2.3 压缩文件 tar 和 zip 是两种常见的压缩文件工具，具有免费和跨平台的特点，因此应用范围广11。 R 内对应的压缩与解压缩命令是 tar/untar tar(tarfile, files = NULL, compression = c(&quot;none&quot;, &quot;gzip&quot;, &quot;bzip2&quot;, &quot;xz&quot;), compression_level = 6, tar = Sys.getenv(&quot;tar&quot;), extra_flags = &quot;&quot;) 比较常用的压缩文件格式是 .tar.gz 和 .tar.bz2，将目录 _book/及其文件分别压缩成 _book.tar.gz 和 _book.tar.bz2 压缩包的名字可以任意取，后者压缩比率高。.tar.xz 的压缩比率最高，需要确保系统中安装了 gzip，bzip2 和 xz-utils 软件，R 软件自带的 tar 软件来自 Rtools12，我们可以通过设置系统环境变量 Sys.setenv(tar=\"path/to/tar\") 指定外部 tar。tar 实际支持的压缩类型只有 .tar.gz13。zip/unzip 压缩与解压缩就不赘述了。 # 打包目录 _book tar(tarfile = &#39;data/_book.tar&#39;, files = &#39;_book&#39;, compression = &#39;none&#39;) # 文件压缩成 _book.xz 格式 tar(tarfile = &#39;data/_book.tar.xz&#39;, files = &#39;data/_book&#39;, compression = &#39;xz&#39;) # tar -cf data/_book.tar _book 然后 xz -z data/_book.tar.xz data/_book.tar # 或者一次压缩到位 tar -Jcf data/_book.tar.xz _book/ # 解压 xz -d data/_book.tar.xz 再次解压 tar -xf data/_book.tar # 或者一次解压 tar -Jxf data/_book.tar.xz # 文件压缩成 _book.tar.gz 格式 # tar -czf data/_book.tar.gz _book tar(tarfile = &#39;data/_book.tar.gz&#39;, files = &#39;_book&#39;, compression = &#39;gzip&#39;) # 解压 tar -xzf data/_book.tar.gz # 文件压缩成 .tar.bz2 格式 # tar -cjf data/book2.tar.bz2 _book tar(tarfile = &#39;data/_book.tar.bz2&#39;, files = &#39;_book&#39;, compression = &#39;bzip2&#39;) # 解压 tar -xjf data/book2.tar.bz2 untar(tarfile, files = NULL, list = FALSE, exdir = &quot;.&quot;, compressed = NA, extras = NULL, verbose = FALSE, restore_times = TRUE, tar = Sys.getenv(&quot;TAR&quot;)) 2.4 路径操作 环境变量算是路径操作 # 获取环境变量 Sys.getenv(&quot;PATH&quot;) #&gt; [1] &quot;/home/travis/.TinyTeX/bin/x86_64-linux:/home/travis/.rvm/gems/ruby-2.5.3/bin:/home/travis/.rvm/gems/ruby-2.5.3@global/bin:/home/travis/.rvm/rubies/ruby-2.5.3/bin:/home/travis/.rvm/bin:/usr/lib/postgresql/9.6/bin:/home/travis/R-bin/bin:/home/travis/bin:/home/travis/.local/bin:/usr/local/lib/jvm/openjdk11/bin:/opt/pyenv/shims:/home/travis/.phpenv/shims:/home/travis/perl5/perlbrew/bin:/home/travis/.nvm/versions/node/v8.12.0/bin:/home/travis/.kiex/elixirs/elixir-1.7.4/bin:/home/travis/.kiex/bin:/home/travis/gopath/bin:/home/travis/.gimme/versions/go1.11.1.linux.amd64/bin:/usr/local/cmake-3.12.4/bin:/usr/local/clang-7.0.0/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin:/opt/ghc/bin:/home/travis/.phpenv/bin:/opt/pyenv/bin:/home/travis/.yarn/bin&quot; # 设置环境变量 Windows # Sys.setenv(R_GSCMD = &quot;C:/Program Files/gs/gs9.26/bin/gswin64c.exe&quot;) # 设置 pandoc 环境变量 pandoc_path &lt;- Sys.getenv(&quot;RSTUDIO_PANDOC&quot;, NA) if (Sys.which(&quot;pandoc&quot;) == &quot;&quot; &amp;&amp; !is.na(pandoc_path)) { Sys.setenv(PATH = paste( Sys.getenv(&quot;PATH&quot;), pandoc_path, sep = if (.Platform$OS.type == &quot;unix&quot;) &quot;:&quot; else &quot;;&quot; )) } 操作文件路径 file.path Construct Path to File file.path(&#39;./_book&#39;) #&gt; [1] &quot;./_book&quot; path.expand(path) Expand File Paths path.expand(&#39;./_book&#39;) #&gt; [1] &quot;./_book&quot; path.expand(&#39;~&#39;) #&gt; [1] &quot;/home/travis&quot; normalizePath() Express File Paths in Canonical Form normalizePath(&#39;~&#39;) #&gt; [1] &quot;/home/travis&quot; normalizePath(&#39;./_book&#39;) #&gt; [1] &quot;/home/travis/build/XiangyunHuang/RGraphics/_book&quot; shortPathName(path) 只在 Windows 下可用，Express File Paths in Short Form cat(shortPathName(c(R.home(), tempdir())), sep = &quot;\\n&quot;) Sys.glob Wildcard Expansion on File Paths Sys.glob(file.path(R.home(), &quot;library&quot;, &quot;*&quot;, &quot;R&quot;, &quot;*.rdx&quot;)) #&gt; [1] &quot;/home/travis/R-bin/lib/R/library/base/R/base.rdx&quot; #&gt; [2] &quot;/home/travis/R-bin/lib/R/library/boot/R/boot.rdx&quot; #&gt; [3] &quot;/home/travis/R-bin/lib/R/library/class/R/class.rdx&quot; #&gt; [4] &quot;/home/travis/R-bin/lib/R/library/cluster/R/cluster.rdx&quot; #&gt; [5] &quot;/home/travis/R-bin/lib/R/library/codetools/R/codetools.rdx&quot; #&gt; [6] &quot;/home/travis/R-bin/lib/R/library/compiler/R/compiler.rdx&quot; .... 2.5 查找文件 here 包用来查找你的文件，查找文件、可执行文件的完整路径、R 包 Sys.which Find Full Paths to Executables Sys.which(&#39;pandoc&#39;) #&gt; pandoc #&gt; &quot;/usr/bin/pandoc&quot; system.file Find Names of R System Files system.file(&#39;CITATION&#39;,package = &#39;base&#39;) #&gt; [1] &quot;/home/travis/R-bin/lib/R/library/base/CITATION&quot; R.home # R 安装目录 R.home() #&gt; [1] &quot;/home/travis/R-bin/lib/R&quot; # R执行文件目录 R.home(&#39;bin&#39;) #&gt; [1] &quot;/home/travis/R-bin/lib/R/bin&quot; # 配置文件目录 R.home(&#39;etc&#39;) #&gt; [1] &quot;/home/travis/R-bin/lib/R/etc&quot; # R 基础扩展包存放目录 R.home(&#39;library&#39;) #&gt; [1] &quot;/home/travis/R-bin/lib/R/library&quot; .libPaths() R 包存放的路径有哪些 .libPaths() #&gt; [1] &quot;/home/travis/R/Library&quot; &quot;/usr/local/lib/R/site-library&quot; #&gt; [3] &quot;/home/travis/R-bin/lib/R/library&quot; find.package 查找R包所在目录 find.package(package = &#39;MASS&#39;) #&gt; [1] &quot;/home/travis/R-bin/lib/R/library/MASS&quot; file.exist 检查文件是否存在 file.exists(paste(R.home(&#39;etc&#39;),&quot;Rprofile.site&quot;,sep = .Platform$file.sep)) #&gt; [1] FALSE apropos 和 find 查找对象 apropos(what, where = FALSE, ignore.case = TRUE, mode = &quot;any&quot;) find(what, mode = &quot;any&quot;, numeric = FALSE, simple.words = TRUE) 匹配含有 find 的函数 apropos(&quot;find&quot;) #&gt; [1] &quot;.find.package&quot; &quot;find&quot; &quot;Find&quot; #&gt; [4] &quot;find.package&quot; &quot;findClass&quot; &quot;findFunction&quot; #&gt; [7] &quot;findInterval&quot; &quot;findLineNum&quot; &quot;findMethod&quot; #&gt; [10] &quot;findMethods&quot; &quot;findMethodSignatures&quot; &quot;findPackageEnv&quot; #&gt; [13] &quot;findRestart&quot; &quot;findUnique&quot; 问号 ? 加函数名搜索R软件内置函数的帮助文档，如 ?regrex。如果不知道具体的函数名，可采用关键词搜索，如 help.search(keyword = &quot;character&quot;, package = &quot;base&quot;) browseEnv 函数用来在浏览器中查看当前环境下，对象的列表，默认环境是 sys.frame() 2.6 文件权限 操作目录和文件的权限 Manipulation of Directories and File Permissions dir.exists(paths) 检查目录是否存在 dir.exists(c(&#39;./_book&#39;,&#39;./book&#39;)) #&gt; [1] TRUE FALSE dir.create(path, showWarnings = TRUE, recursive = FALSE, mode = \"0777\") 创建目录 dir.create(&#39;./_book/tmp&#39;) Sys.chmod(paths, mode = \"0777\", use_umask = TRUE) 修改权限 Sys.chmod(&#39;./_book/tmp&#39;) Sys.umask(mode = NA) 2.7 区域设置 Sys.getlocale(category = \"LC_ALL\") 查看当前区域设置 Sys.getlocale(category = &quot;LC_ALL&quot;) #&gt; [1] &quot;LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGES=en_US.UTF-8;LC_PAPER=en_US.UTF-8;LC_NAME=C;LC_ADDRESS=C;LC_TELEPHONE=C;LC_MEASUREMENT=en_US.UTF-8;LC_IDENTIFICATION=C&quot; Sys.setlocale(category = \"LC_ALL\", locale = \"\") 设置区域 # 默认设置 Sys.setlocale(category = &quot;LC_ALL&quot;, locale = &quot;&quot;) #&gt; [1] &quot;LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGES=en_US.UTF-8;LC_PAPER=en_US.UTF-8;LC_NAME=C;LC_ADDRESS=C;LC_TELEPHONE=C;LC_MEASUREMENT=en_US.UTF-8;LC_IDENTIFICATION=C&quot; # 保存当前区域设置 old &lt;- Sys.getlocale() Sys.setlocale(&quot;LC_MONETARY&quot;, locale = &quot;&quot;) #&gt; [1] &quot;en_US.UTF-8&quot; Sys.localeconv() #&gt; decimal_point thousands_sep grouping int_curr_symbol #&gt; &quot;.&quot; &quot;&quot; &quot;&quot; &quot;USD &quot; #&gt; currency_symbol mon_decimal_point mon_thousands_sep mon_grouping #&gt; &quot;$&quot; &quot;.&quot; &quot;,&quot; &quot;\\003\\003&quot; #&gt; positive_sign negative_sign int_frac_digits frac_digits #&gt; &quot;&quot; &quot;-&quot; &quot;2&quot; &quot;2&quot; #&gt; p_cs_precedes p_sep_by_space n_cs_precedes n_sep_by_space #&gt; &quot;1&quot; &quot;0&quot; &quot;1&quot; &quot;0&quot; #&gt; p_sign_posn n_sign_posn #&gt; &quot;1&quot; &quot;1&quot; Sys.setlocale(&quot;LC_MONETARY&quot;, &quot;de_AT&quot;) #&gt; Warning in Sys.setlocale(&quot;LC_MONETARY&quot;, &quot;de_AT&quot;): OS reports request to set #&gt; locale to &quot;de_AT&quot; cannot be honored #&gt; [1] &quot;&quot; Sys.localeconv() #&gt; decimal_point thousands_sep grouping int_curr_symbol #&gt; &quot;.&quot; &quot;&quot; &quot;&quot; &quot;USD &quot; #&gt; currency_symbol mon_decimal_point mon_thousands_sep mon_grouping #&gt; &quot;$&quot; &quot;.&quot; &quot;,&quot; &quot;\\003\\003&quot; #&gt; positive_sign negative_sign int_frac_digits frac_digits #&gt; &quot;&quot; &quot;-&quot; &quot;2&quot; &quot;2&quot; #&gt; p_cs_precedes p_sep_by_space n_cs_precedes n_sep_by_space #&gt; &quot;1&quot; &quot;0&quot; &quot;1&quot; &quot;0&quot; #&gt; p_sign_posn n_sign_posn #&gt; &quot;1&quot; &quot;1&quot; # 恢复区域设置 Sys.setlocale(locale = old) #&gt; Warning in Sys.setlocale(locale = old): OS reports request to set locale to #&gt; &quot;LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGES=en_US.UTF-8;LC_PAPER=en_US.UTF-8;LC_NAME=C;LC_ADDRESS=C;LC_TELEPHONE=C;LC_MEASUREMENT=en_US.UTF-8;LC_IDENTIFICATION=C&quot; #&gt; cannot be honored #&gt; [1] &quot;&quot; Sys.localeconv() 当前区域设置下，数字和货币的表示 Sys.localeconv() #&gt; decimal_point thousands_sep grouping int_curr_symbol #&gt; &quot;.&quot; &quot;&quot; &quot;&quot; &quot;USD &quot; #&gt; currency_symbol mon_decimal_point mon_thousands_sep mon_grouping #&gt; &quot;$&quot; &quot;.&quot; &quot;,&quot; &quot;\\003\\003&quot; #&gt; positive_sign negative_sign int_frac_digits frac_digits #&gt; &quot;&quot; &quot;-&quot; &quot;2&quot; &quot;2&quot; #&gt; p_cs_precedes p_sep_by_space n_cs_precedes n_sep_by_space #&gt; &quot;1&quot; &quot;0&quot; &quot;1&quot; &quot;0&quot; #&gt; p_sign_posn n_sign_posn #&gt; &quot;1&quot; &quot;1&quot; 本地化信息 l10n_info() #&gt; $MBCS #&gt; [1] TRUE #&gt; #&gt; $`UTF-8` #&gt; [1] TRUE #&gt; #&gt; $`Latin-1` #&gt; [1] FALSE 2.8 进程管理 ps 包用来查询进程信息 Sys.getpid 获取当前运行中的 R 控制台（会话）的进程 ID Sys.getpid() #&gt; [1] 19236 proc.time() R 会话运行时间，常用于计算R程序在当前R控制台的运行时间 t1 &lt;- proc.time() tmp &lt;- rnorm(1e6) proc.time() - t1 #&gt; user system elapsed #&gt; 0.068 0.000 0.069 system.time 计算 R 表达式/程序块运行耗费的CPU时间 system.time({ rnorm(1e6) }, gcFirst = TRUE) #&gt; user system elapsed #&gt; 0.063 0.000 0.062 gc.time 报告垃圾回收耗费的时间 gc.time() #&gt; [1] 0 0 0 0 0 2.9 系统命令 system 和 system2 调用系统命令，推荐使用后者，它更灵活更便携。此外，Jeroen Ooms 开发的 sys 包 可看作 base::system2 的替代品 system &lt;- function(...) cat(base::system(..., intern = TRUE), sep = &#39;\\n&#39;) system2 &lt;- function(...) cat(base::system2(..., stdout = TRUE), sep = &quot;\\n&quot;) system(command = &quot;xelatex --version&quot;) #&gt; XeTeX 3.14159265-2.6-0.999991 (TeX Live 2019) #&gt; kpathsea version 6.3.1 #&gt; Copyright 2019 SIL International, Jonathan Kew and Khaled Hosny. #&gt; There is NO warranty. Redistribution of this software is #&gt; covered by the terms of both the XeTeX copyright and #&gt; the Lesser GNU General Public License. #&gt; For more information about these matters, see the file #&gt; named COPYING and the XeTeX source. #&gt; Primary author of XeTeX: Jonathan Kew. #&gt; Compiled with ICU version 63.1; using 63.1 #&gt; Compiled with zlib version 1.2.11; using 1.2.11 #&gt; Compiled with FreeType2 version 2.9.1; using 2.9.1 #&gt; Compiled with Graphite2 version 1.3.13; using 1.3.13 #&gt; Compiled with HarfBuzz version 2.3.1; using 2.3.1 #&gt; Compiled with libpng version 1.6.36; using 1.6.36 #&gt; Compiled with poppler version 0.68.0 #&gt; Compiled with fontconfig version 2.11.0; using 2.11.94 system2(command = &#39;pdflatex&#39;, args = &#39;--version&#39;) #&gt; pdfTeX 3.14159265-2.6-1.40.20 (TeX Live 2019) #&gt; kpathsea version 6.3.1 #&gt; Copyright 2019 Han The Thanh (pdfTeX) et al. #&gt; There is NO warranty. Redistribution of this software is #&gt; covered by the terms of both the pdfTeX copyright and #&gt; the Lesser GNU General Public License. #&gt; For more information about these matters, see the file #&gt; named COPYING and the pdfTeX source. #&gt; Primary author of pdfTeX: Han The Thanh (pdfTeX) et al. #&gt; Compiled with libpng 1.6.36; using libpng 1.6.36 #&gt; Compiled with zlib 1.2.11; using zlib 1.2.11 #&gt; Compiled with xpdf version 4.01 2.10 时间管理 Sys.timezone 获取时区信息 Sys.timezone(location = TRUE) #&gt; [1] &quot;Asia/Shanghai&quot; Sys.time 系统时间，可以给定时区下，显示当前时间，精确到秒，返回数据类型为 POSIXct # 此时美国洛杉矶时间 format(Sys.time(), tz = &#39;America/Los_Angeles&#39;, usetz = TRUE) #&gt; [1] &quot;2020-02-04 21:14:54 PST&quot; # 此时加拿大东部时间 format(Sys.time(), tz = &#39;Canada/Eastern&#39;, usetz = TRUE) #&gt; [1] &quot;2020-02-05 00:14:54 EST&quot; Sys.Date 显示当前时区下的日期，精确到日，返回数据类型为 date Sys.Date() #&gt; [1] &quot;2020-02-05&quot; date 返回当前系统日期和时间，数据类型是字符串 date() #&gt; [1] &quot;Wed Feb 5 13:14:54 2020&quot; ## 也可以这样表示 format(Sys.time(), &quot;%a %b %d %H:%M:%S %Y&quot;) #&gt; [1] &quot;Wed Feb 05 13:14:54 2020&quot; as.POSIX* 是一个 Date-time 转换函数 as.POSIXlt(Sys.time(), &quot;GMT&quot;) # the current time in GMT #&gt; [1] &quot;2020-02-05 05:14:54 GMT&quot; 时间计算 (z &lt;- Sys.time()) # the current date, as class &quot;POSIXct&quot; #&gt; [1] &quot;2020-02-05 13:14:54 CST&quot; Sys.time() - 3600 # an hour ago #&gt; [1] &quot;2020-02-05 12:14:54 CST&quot; .leap.seconds 是内置的日期序列 .leap.seconds #&gt; [1] &quot;1972-07-01 08:00:00 CST&quot; &quot;1973-01-01 08:00:00 CST&quot; #&gt; [3] &quot;1974-01-01 08:00:00 CST&quot; &quot;1975-01-01 08:00:00 CST&quot; #&gt; [5] &quot;1976-01-01 08:00:00 CST&quot; &quot;1977-01-01 08:00:00 CST&quot; #&gt; [7] &quot;1978-01-01 08:00:00 CST&quot; &quot;1979-01-01 08:00:00 CST&quot; #&gt; [9] &quot;1980-01-01 08:00:00 CST&quot; &quot;1981-07-01 08:00:00 CST&quot; #&gt; [11] &quot;1982-07-01 08:00:00 CST&quot; &quot;1983-07-01 08:00:00 CST&quot; #&gt; [13] &quot;1985-07-01 08:00:00 CST&quot; &quot;1988-01-01 08:00:00 CST&quot; #&gt; [15] &quot;1990-01-01 08:00:00 CST&quot; &quot;1991-01-01 08:00:00 CST&quot; #&gt; [17] &quot;1992-07-01 08:00:00 CST&quot; &quot;1993-07-01 08:00:00 CST&quot; #&gt; [19] &quot;1994-07-01 08:00:00 CST&quot; &quot;1996-01-01 08:00:00 CST&quot; #&gt; [21] &quot;1997-07-01 08:00:00 CST&quot; &quot;1999-01-01 08:00:00 CST&quot; #&gt; [23] &quot;2006-01-01 08:00:00 CST&quot; &quot;2009-01-01 08:00:00 CST&quot; #&gt; [25] &quot;2012-07-01 08:00:00 CST&quot; &quot;2015-07-01 08:00:00 CST&quot; #&gt; [27] &quot;2017-01-01 08:00:00 CST&quot; 计算日期对应的星期weekdays，月 months 和季度 quarters weekdays(.leap.seconds) #&gt; [1] &quot;Saturday&quot; &quot;Monday&quot; &quot;Tuesday&quot; &quot;Wednesday&quot; &quot;Thursday&quot; &quot;Saturday&quot; #&gt; [7] &quot;Sunday&quot; &quot;Monday&quot; &quot;Tuesday&quot; &quot;Wednesday&quot; &quot;Thursday&quot; &quot;Friday&quot; #&gt; [13] &quot;Monday&quot; &quot;Friday&quot; &quot;Monday&quot; &quot;Tuesday&quot; &quot;Wednesday&quot; &quot;Thursday&quot; #&gt; [19] &quot;Friday&quot; &quot;Monday&quot; &quot;Tuesday&quot; &quot;Friday&quot; &quot;Sunday&quot; &quot;Thursday&quot; #&gt; [25] &quot;Sunday&quot; &quot;Wednesday&quot; &quot;Sunday&quot; months(.leap.seconds) #&gt; [1] &quot;July&quot; &quot;January&quot; &quot;January&quot; &quot;January&quot; &quot;January&quot; &quot;January&quot; &quot;January&quot; #&gt; [8] &quot;January&quot; &quot;January&quot; &quot;July&quot; &quot;July&quot; &quot;July&quot; &quot;July&quot; &quot;January&quot; #&gt; [15] &quot;January&quot; &quot;January&quot; &quot;July&quot; &quot;July&quot; &quot;July&quot; &quot;January&quot; &quot;July&quot; #&gt; [22] &quot;January&quot; &quot;January&quot; &quot;January&quot; &quot;July&quot; &quot;July&quot; &quot;January&quot; quarters(.leap.seconds) #&gt; [1] &quot;Q3&quot; &quot;Q1&quot; &quot;Q1&quot; &quot;Q1&quot; &quot;Q1&quot; &quot;Q1&quot; &quot;Q1&quot; &quot;Q1&quot; &quot;Q1&quot; &quot;Q3&quot; &quot;Q3&quot; &quot;Q3&quot; &quot;Q3&quot; &quot;Q1&quot; &quot;Q1&quot; #&gt; [16] &quot;Q1&quot; &quot;Q3&quot; &quot;Q3&quot; &quot;Q3&quot; &quot;Q1&quot; &quot;Q3&quot; &quot;Q1&quot; &quot;Q1&quot; &quot;Q1&quot; &quot;Q3&quot; &quot;Q3&quot; &quot;Q1&quot; Sys.setFileTime() 使用系统调用 system call 设置文件或目录的时间 # 修改时间前 file.info(&#39;./_common.R&#39;) #&gt; size isdir mode mtime ctime #&gt; ./_common.R 2093 FALSE 664 2020-02-05 13:10:59 2020-02-05 13:10:59 #&gt; atime uid gid uname grname #&gt; ./_common.R 2020-02-05 13:10:59 2000 2000 travis travis # 修改时间后，对比一下 Sys.setFileTime(path = &#39;./_common.R&#39;, time = Sys.time()) file.info(&#39;./_common.R&#39;) #&gt; size isdir mode mtime ctime #&gt; ./_common.R 2093 FALSE 664 2020-02-05 13:14:54 2020-02-05 13:14:54 #&gt; atime uid gid uname grname #&gt; ./_common.R 2020-02-05 13:14:54 2000 2000 travis travis strptime 用于字符串与 POSIXlt、 POSIXct 类对象之间的转化，format 默认 tz = \"\" 且 usetz = TRUE # 存放时区信息的数据库所在目录 list.files(file.path(R.home(&quot;share&quot;), &quot;zoneinfo&quot;)) #&gt; character(0) # 比较不同的打印方式 strptime(Sys.time(), format =&quot;%Y-%m-%d %H:%M:%S&quot;, tz = &quot;Asia/Taipei&quot;) #&gt; [1] &quot;2020-02-05 13:14:54 CST&quot; format(Sys.time(), format = &quot;%Y-%m-%d %H:%M:%S&quot;) # 默认情形 #&gt; [1] &quot;2020-02-05 13:14:54&quot; format(Sys.time(), format = &quot;%Y-%m-%d %H:%M:%S&quot;, tz = &quot;Asia/Taipei&quot;, usetz = TRUE) #&gt; [1] &quot;2020-02-05 13:14:54 CST&quot; 设置时区 Sys.timezone() #&gt; [1] &quot;Asia/Shanghai&quot; Sys.setenv(TZ = &quot;Asia/Shanghai&quot;) Sys.timezone() #&gt; [1] &quot;Asia/Shanghai&quot; 全局修改，在文件 /home/travis/R-bin/lib/R/etc/Rprofile.site 内添加Sys.setenv(TZ=\"Asia/Shanghai\")。 局部修改，就是在本地R项目下，创建 .Rprofile，然后同样添加 Sys.setenv(TZ=\"Asia/Shanghai\")。 2.11 R 包管理 相关的函数大致有 apropos(&#39;package&#39;) #&gt; [1] &quot;.find.package&quot; &quot;.packages&quot; #&gt; [3] &quot;.packageStartupMessage&quot; &quot;.path.package&quot; #&gt; [5] &quot;$.package_version&quot; &quot;as.package_version&quot; #&gt; [7] &quot;aspell_package_C_files&quot; &quot;aspell_package_R_files&quot; #&gt; [9] &quot;aspell_package_Rd_files&quot; &quot;aspell_package_vignettes&quot; #&gt; [11] &quot;available.packages&quot; &quot;CRAN.packages&quot; #&gt; [13] &quot;download.packages&quot; &quot;find.package&quot; #&gt; [15] &quot;findPackageEnv&quot; &quot;format.packageInfo&quot; #&gt; [17] &quot;getClassPackage&quot; &quot;getPackageName&quot; #&gt; [19] &quot;install.packages&quot; &quot;installed.packages&quot; .... .packages(T) 已安装的 R 包 .packages(T) %&gt;% length() #&gt; [1] 235 available.packages 查询可用的 R 包 available.packages()[,&quot;Package&quot;] %&gt;% head() #&gt; A3 aaSEA ABACUS abbyyR abc abc.data #&gt; &quot;A3&quot; &quot;aaSEA&quot; &quot;ABACUS&quot; &quot;abbyyR&quot; &quot;abc&quot; &quot;abc.data&quot; 查询 repos 的 R 包 rforge &lt;- available.packages(repos = &quot;https://r-forge.r-project.org/&quot;) cran &lt;- available.packages(repos = &quot;https://mirrors.tuna.tsinghua.edu.cn/CRAN/&quot;) setdiff(rforge[, &quot;Package&quot;], cran[, &quot;Package&quot;]) download.packages 下载 R 包 download.packages(&quot;Rbooks&quot;, destdir = &quot;~/&quot;, repos = &quot;https://r-forge.r-project.org/&quot;) install.packages 安装 R 包 install.packages(&quot;rmarkdown&quot;) installed.packages 已安装的 R 包 installed.packages(fields = c(&quot;Package&quot;,&quot;Version&quot;)) %&gt;% head() remove.packages 卸载/删除/移除已安装的R包 remove.packages(&#39;rmarkdown&#39;) update.packages 更新已安装的 R 包 update.packages(ask = FALSE) old.packages 查看过时/可更新的 R 包 old.packages() %&gt;% head() #&gt; Package LibPath Installed Built ReposVer #&gt; knitr &quot;knitr&quot; &quot;/home/travis/R/Library&quot; &quot;1.26&quot; &quot;4.0.0&quot; &quot;1.27&quot; #&gt; Repository #&gt; knitr &quot;https://cloud.r-project.org/src/contrib&quot; new.packages 还没有安装的 R 包 new.packages() %&gt;% head() #&gt; [1] &quot;A3&quot; &quot;aaSEA&quot; &quot;ABACUS&quot; &quot;abbyyR&quot; &quot;abc&quot; &quot;abc.data&quot; packageStatus 查看已安装的 R 包状态，可更新、可下载等 packageStatus() #&gt; Number of installed packages: #&gt; #&gt; ok upgrade unavailable #&gt; /home/travis/R/Library 203 1 2 #&gt; /usr/local/lib/R/site-library 0 0 0 #&gt; /home/travis/R-bin/lib/R/library 29 0 0 #&gt; #&gt; Number of available packages (each package counted only once): #&gt; #&gt; installed not installed #&gt; https://cloud.r-project.org/src/contrib 218 15101 #&gt; https://nowosad.github.io/drat/src/contrib 1 0 packageDescription 查询 R 包描述信息 packageDescription(&#39;graphics&#39;) #&gt; Package: graphics #&gt; Version: 4.0.0 #&gt; Priority: base #&gt; Title: The R Graphics Package #&gt; Author: R Core Team and contributors worldwide #&gt; Maintainer: R Core Team &lt;R-core@r-project.org&gt; .... 查询 R 包的依赖关系 # rmarkdown 依赖的 R 包 tools::package_dependencies(&#39;rmarkdown&#39;, recursive = TRUE) #&gt; $rmarkdown #&gt; [1] &quot;tools&quot; &quot;utils&quot; &quot;knitr&quot; &quot;yaml&quot; &quot;htmltools&quot; &quot;evaluate&quot; #&gt; [7] &quot;base64enc&quot; &quot;jsonlite&quot; &quot;mime&quot; &quot;tinytex&quot; &quot;xfun&quot; &quot;methods&quot; #&gt; [13] &quot;stringr&quot; &quot;digest&quot; &quot;Rcpp&quot; &quot;rlang&quot; &quot;highr&quot; &quot;markdown&quot; #&gt; [19] &quot;glue&quot; &quot;magrittr&quot; &quot;stringi&quot; &quot;stats&quot; # 依赖 rmarkdown 的 R 包 tools::dependsOnPkgs(&#39;rmarkdown&#39;, recursive = TRUE) #&gt; [1] &quot;bookdown&quot; &quot;reprex&quot; &quot;tidyverse&quot; ggplot2 生态，仅列出以 gg 开头的 R 包 pdb &lt;- available.packages() gg &lt;- tools::dependsOnPkgs(&quot;ggplot2&quot;, recursive = FALSE, installed = pdb) grep(&quot;^gg&quot;, gg, value = TRUE) #&gt; [1] &quot;gg.gap&quot; &quot;ggallin&quot; &quot;ggalluvial&quot; #&gt; [4] &quot;ggalt&quot; &quot;gganimate&quot; &quot;ggasym&quot; #&gt; [7] &quot;ggbeeswarm&quot; &quot;ggBubbles&quot; &quot;ggbuildr&quot; #&gt; [10] &quot;ggChernoff&quot; &quot;ggconf&quot; &quot;ggcorrplot&quot; #&gt; [13] &quot;ggdag&quot; &quot;ggdark&quot; &quot;ggdemetra&quot; #&gt; [16] &quot;ggdendro&quot; &quot;ggdistribute&quot; &quot;ggdmc&quot; #&gt; [19] &quot;ggeasy&quot; &quot;ggedit&quot; &quot;ggenealogy&quot; #&gt; [22] &quot;ggetho&quot; &quot;ggExtra&quot; &quot;ggfan&quot; #&gt; [25] &quot;ggfittext&quot; &quot;ggfocus&quot; &quot;ggforce&quot; #&gt; [28] &quot;ggformula&quot; &quot;ggfortify&quot; &quot;gggenes&quot; #&gt; [31] &quot;ggghost&quot; &quot;gggibbous&quot; &quot;ggguitar&quot; #&gt; [34] &quot;gghalfnorm&quot; &quot;gghalves&quot; &quot;gghighlight&quot; #&gt; [37] &quot;ggimage&quot; &quot;gginference&quot; &quot;gginnards&quot; #&gt; [40] &quot;ggiraph&quot; &quot;ggiraphExtra&quot; &quot;ggjoy&quot; #&gt; [43] &quot;gglogo&quot; &quot;ggloop&quot; &quot;gglorenz&quot; #&gt; [46] &quot;ggmap&quot; &quot;ggmcmc&quot; &quot;ggmosaic&quot; #&gt; [49] &quot;ggmsa&quot; &quot;ggmuller&quot; &quot;ggnetwork&quot; #&gt; [52] &quot;ggnewscale&quot; &quot;ggnormalviolin&quot; &quot;ggpage&quot; #&gt; [55] &quot;ggparallel&quot; &quot;ggparliament&quot; &quot;ggparty&quot; #&gt; [58] &quot;ggperiodic&quot; &quot;ggplot.multistats&quot; &quot;ggplotAssist&quot; #&gt; [61] &quot;ggplotgui&quot; &quot;ggplotify&quot; &quot;ggplotlyExtra&quot; #&gt; [64] &quot;ggpmisc&quot; &quot;ggPMX&quot; &quot;ggpointdensity&quot; #&gt; [67] &quot;ggpol&quot; &quot;ggpolypath&quot; &quot;ggpubr&quot; #&gt; [70] &quot;ggpval&quot; &quot;ggQC&quot; &quot;ggQQunif&quot; #&gt; [73] &quot;ggquickeda&quot; &quot;ggquiver&quot; &quot;ggRandomForests&quot; #&gt; [76] &quot;ggraph&quot; &quot;ggraptR&quot; &quot;ggrasp&quot; #&gt; [79] &quot;ggrepel&quot; &quot;ggResidpanel&quot; &quot;ggridges&quot; #&gt; [82] &quot;ggROC&quot; &quot;ggsci&quot; &quot;ggseas&quot; #&gt; [85] &quot;ggseqlogo&quot; &quot;ggsignif&quot; &quot;ggsn&quot; #&gt; [88] &quot;ggsoccer&quot; &quot;ggsolvencyii&quot; &quot;ggsom&quot; #&gt; [91] &quot;ggspatial&quot; &quot;ggspectra&quot; &quot;ggstance&quot; #&gt; [94] &quot;ggstatsplot&quot; &quot;ggswissmaps&quot; &quot;ggtern&quot; #&gt; [97] &quot;ggThemeAssist&quot; &quot;ggthemes&quot; &quot;ggTimeSeries&quot; #&gt; [100] &quot;ggupset&quot; &quot;ggVennDiagram&quot; &quot;ggvoronoi&quot; #&gt; [103] &quot;ggwordcloud&quot; 重装R包，与 R 版本号保持一致 db &lt;- installed.packages() db &lt;- as.data.frame(db, stringsAsFactors = FALSE) pkgs &lt;- db[db$Built &lt; getRversion(), &quot;Package&quot;] install.packages(pkgs) 2.12 查找函数 lookup R 函数完整定义，包括编译的代码，S3 和 S4 方法。目前 lookup 包处于开发版，我们可以用 remotes::install_github 函数来安装它 # install.packages(&quot;remotes&quot;) remotes::install_github(&quot;jimhester/lookup&quot;) R-level 的源代码都可以直接看 body #&gt; function (fun = sys.function(sys.parent())) #&gt; { #&gt; if (is.character(fun)) #&gt; fun &lt;- get(fun, mode = &quot;function&quot;, envir = parent.frame()) #&gt; .Internal(body(fun)) #&gt; } #&gt; &lt;bytecode: 0x4a9e828&gt; #&gt; &lt;environment: namespace:base&gt; 此外，lookup 可以定位到 C-level 的源代码，需要联网才能查看，lookup 基于 Winston Chang 在 Github 上维护的 R 源码镜像 lookup(body) base::body [closure] function (fun = sys.function(sys.parent())) { if (is.character(fun)) fun &lt;- get(fun, mode = &quot;function&quot;, envir = parent.frame()) .Internal(body(fun)) } &lt;bytecode: 0x00000000140d6158&gt; &lt;environment: namespace:base&gt; // c source: src/main/builtin.c#L264-L277 SEXP attribute_hidden do_body(SEXP call, SEXP op, SEXP args, SEXP rho) { checkArity(op, args); if (TYPEOF(CAR(args)) == CLOSXP) { SEXP b = BODY_EXPR(CAR(args)); RAISE_NAMED(b, NAMED(CAR(args))); return b; } else { if(!(TYPEOF(CAR(args)) == BUILTINSXP || TYPEOF(CAR(args)) == SPECIALSXP)) warningcall(call, _(&quot;argument is not a function&quot;)); return R_NilValue; } } 2.13 运行环境 xfun::session_info(packages = c(&quot;magrittr&quot;, &quot;fs&quot;)) #&gt; R Under development (unstable) (2020-02-04 r77771) #&gt; Platform: x86_64-pc-linux-gnu (64-bit) #&gt; Running under: Ubuntu 16.04.6 LTS #&gt; #&gt; Locale: #&gt; LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C #&gt; LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 #&gt; LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 #&gt; LC_PAPER=en_US.UTF-8 LC_NAME=C #&gt; LC_ADDRESS=C LC_TELEPHONE=C #&gt; LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C #&gt; #&gt; Package version: #&gt; fs_1.3.1 graphics_4.0.0 grDevices_4.0.0 magrittr_1.5 #&gt; methods_4.0.0 Rcpp_1.0.3 stats_4.0.0 utils_4.0.0 https://github.com/libarchive/libarchive/wiki/FormatTar↩︎ 继 Rtools35 之后， RTools40 主要为 R 3.6.0 准备的，包含有 GCC 8 及其它编译R包需要的工具包，详情请看的幻灯片↩︎ https://github.com/rwinlib/utils↩︎ "],
["data-objects.html", "第 3 章 对象在哪里 3.1 类型 3.2 日期 3.3 空值 3.4 字符串 3.5 表达式 3.6 矩阵 3.7 数组 3.8 数据框 3.9 表格 3.10 列表 3.11 时间序列 3.12 空间数据", " 第 3 章 对象在哪里 可用于绘图的数据对象，向量 vector 等，只涉及基础操作和绘图，关键在入门引导式的介绍，点到即止 数据类型：字符、数值：字符数据操作：按数据类型介绍各类数据操作，重复之处如前所述，数据处理的分类：按数据类型来，一共是 table matrix data.frame 和 vector The trouble with nonstandard evaluation is that it doesn’t follow standard evaluation rules… — Peter Dalgaard (about nonstandard evaluation in the curve() function) R-help (June 2011) 向量，列表， 数据框 data frame 在 R 里面可以用三种不同类型的数据对象来表达 从历史脉络来看，为什么会出现三种不同的东西，它们之间的区别和联系是什么，能否用一张表来描述 data.frame 设计的历史，首次包含在 R 里面是什么时候，R 是否一发布就包含了这个数据类型 The function data.frame() creates data frames, tightly coupled collections of variables which share many of the properties of matrices and of lists, used as the fundamental data structure by most of R’s modeling software. data.table 2006 年 4 月 15 日首次登陆 CRAN 发布 1.0 版本，差不多恰好 10 年后 tibble 在 2016 年 3 月 23 日首次登陆 CRAN 发布 1.0 版本 data.frame()， tibble() 和 data.table() 的区别，去看函数的帮助文档 Provides a ‘tbl_df’ class (the ‘tibble’) that provides stricter checking and better formatting than the traditional data frame. vctrs 和 rlang 包 R 内置的 R Language Definition 3.1 类型 x &lt;- &quot;abc&quot; # 数据对象 typeof(x) # 数据类型 #&gt; [1] &quot;character&quot; mode(x) # 存储模式 #&gt; [1] &quot;character&quot; storage.mode(x) # 存储类型 #&gt; [1] &quot;character&quot; 表 3.1: 函数 typeof() 返回的数据类型14 符号 含义 NULL 空值 symbol 可变的名称/变量 pairlist pairlist 对象*** closure 函数闭包 environment 环境 promise 实现惰性求值的对象 language R 语言构造 special 内部函数，不计算参数 builtin 内部函数，计算参数 char scalar 型字符对象*** logical 逻辑向量 integer 整数向量 double 实值向量 complex 复值向量 character 字符向量 ... 可变长度的参数*** any 匹配任意类型 expression 表达式对象 list 列表 bytecode 位代码*** externalptr 外部指针对象 weakref 弱引用对象 raw 位向量 S4 S4 对象 表 3.2: R/Rcpp 提供的基本数据类型 Value R vector Rcpp vector Rcpp matrix Rcpp scalar C++ scalar Logical logical LogicalVector LogicalMatrix - bool Integer integer IntegerVector IntegerMatrix - int Real numeric NumericVector NumericMatrix - double Complex complex ComplexVector ComplexMatrix Rcomplex complex String character CharacterVector (StringVector) CharacterMatrix (StringMatrix) String string Date Date DateVector - Date - Datetime POSIXct DatetimeVector - Datetime time_t 3.2 日期 注意观察时间转化 Sys.Date() #&gt; [1] &quot;2020-02-05&quot; Sys.time() #&gt; [1] &quot;2020-02-05 13:15:01 CST&quot; c(Sys.time(), Sys.Date()) #&gt; [1] &quot;2020-02-05 13:15:01 CST&quot; &quot;1970-01-01 13:04:57 CST&quot; data.table::year(Sys.Date()) #&gt; [1] 2020 data.table::year(Sys.time()) #&gt; [1] 2020 data.table::year(c(Sys.time(), Sys.Date())) #&gt; [1] 2020 1970 x &lt;- Sys.time() class(x) #&gt; [1] &quot;POSIXct&quot; &quot;POSIXt&quot; format(x, format = &quot;%Y-%m-%d&quot;) #&gt; [1] &quot;2020-02-05&quot; x &lt;- c(&quot;2019-12-21&quot;, &quot;2019/12/21&quot;) data.table::year(&quot;2019-12-21&quot;) #&gt; [1] 2019 data.table::year(&quot;2019/12/21&quot;) #&gt; [1] 2019 但是，下面这样会报错 data.table::year(x) #&gt; Error in as.POSIXlt.character(x): character string is not in a standard unambiguous format 正确的姿势是首先将表示日期的字符串格式统一 gsub(pattern = &quot;/&quot;, replacement = &quot;-&quot;, x) %&gt;% data.table::year() #&gt; [1] 2019 2019 date-times 表示 POSIXct 和 POSIXlt 类型的日期对象 (x &lt;- Sys.time()) #&gt; [1] &quot;2020-02-05 13:15:01 CST&quot; class(x) #&gt; [1] &quot;POSIXct&quot; &quot;POSIXt&quot; data.table::second(x) # 取秒 #&gt; [1] 1 format(x, format = &quot;%S&quot;) #&gt; [1] &quot;01&quot; data.table::minute(x) # 取分 #&gt; [1] 15 format(x, format = &quot;%M&quot;) #&gt; [1] &quot;15&quot; data.table::hour(x) # 取时 #&gt; [1] 13 format(x, format = &quot;%H&quot;) #&gt; [1] &quot;13&quot; data.table::yday(x) # 此刻在一年的第几天 #&gt; [1] 36 data.table::wday(x) # 此刻在一周的第几天，星期日是第1天，星期六是第7天 #&gt; [1] 4 data.table::mday(x) # 此刻在当月第几天 #&gt; [1] 5 format(x, format = &quot;%d&quot;) #&gt; [1] &quot;05&quot; weekdays(x) #&gt; [1] &quot;Wednesday&quot; weekdays(x, abbreviate = T) #&gt; [1] &quot;Wed&quot; data.table::week(x) # 此刻在第几周 #&gt; [1] 6 data.table::isoweek(x) #&gt; [1] 6 data.table::month(x) # 此刻在第几月 #&gt; [1] 2 format(x, format = &quot;%m&quot;) #&gt; [1] &quot;02&quot; months(x) #&gt; [1] &quot;February&quot; months(x, abbreviate = T) #&gt; [1] &quot;Feb&quot; data.table::quarter(x) # 此刻在第几季度 #&gt; [1] 1 quarters(x) #&gt; [1] &quot;Q1&quot; data.table::year(x) # 取年 #&gt; [1] 2020 format(x, format = &quot;%Y&quot;) #&gt; [1] &quot;2020&quot; format() 是一个泛型函数，此刻命名空间有 76 方法。 format.Date()， format.difftime()， format.POSIXct() 和 format.POSIXlt() 四个函数通过格式化不同类型的日期数据对象抽取指定部分。 format(difftime(Sys.time(), x, units = &quot;secs&quot;)) #&gt; [1] &quot;0.05605173 secs&quot; 日期转化详见 (???; ???) 3.3 空值 移除list() 列表里的为 NULL 元素 rm_null &lt;- function(l) Filter(Negate(is.null), l) 3.4 字符串 3.5 表达式 # %||% 中缀符 # x 是空值或者长度为 0 则保留 y 否则保留 x function(x, y) if (is.null(x) || length(x) == 0) y else x #&gt; function(x, y) if (is.null(x) || length(x) == 0) y else x 3.6 矩阵 3.7 数组 更多数组操作 rray 3.8 数据框 3.9 表格 3.10 列表 3.11 时间序列 Jeffrey A. Ryan 开发的 xts 和 quantmod 包，Joshua M. Ulrich 开发的 zoo 是处理时间序列数据的主要工具 Jeffrey A. Ryan 在开设了一门免费课程教大家如何在 R 语言中使用 xts 和 zoo 包操作时间序列数据15 xts (eXtensible Time Series) 扩展的 zoo 对象 xts(x = NULL, order.by = index(x), frequency = NULL, unique = TRUE, tzone = Sys.getenv(&quot;TZ&quot;), ...) library(zoo) library(xts) x = matrix(1:4, ncol = 2,nrow = 2) idx &lt;- as.Date(c(&quot;2018-01-01&quot;, &quot;2019-12-12&quot;)) # xts = matrix + index xts(x, order.by = idx) #&gt; [,1] [,2] #&gt; 2018-01-01 1 3 #&gt; 2019-12-12 2 4 Date，POSIX times，timeDate，chron 等各种各样处理日期数据的对象 3.12 空间数据 sp sf raster 等对象 表格中带 *** 标记的类型，用户不能轻易获得↩︎ https://www.datacamp.com/courses/manipulating-time-series-data-in-r-with-xts-zoo↩︎ "],
["data-import.html", "第 4 章 数据搬运工 4.1 导入数据 4.2 其它数据格式 4.3 导入大数据集 4.4 从数据库导入 4.5 批量导入数据 4.6 批量导出数据 4.7 导出数据 4.8 运行环境", " 第 4 章 数据搬运工 导入数据与导出数据，各种数据格式，数据库 4.1 导入数据 Base R 针对不同的数据格式文件，提供了大量的数据导入和导出函数，不愧是专注数据分析20余年的优秀统计软件。 除了函数 write.ftable 和 read.ftable 来自 stats 包，都来自 base 和 utils 包 # 当前环境的搜索路径 searchpaths() #&gt; [1] &quot;.GlobalEnv&quot; #&gt; [2] &quot;/home/travis/R-bin/lib/R/library/stats&quot; #&gt; [3] &quot;/home/travis/R-bin/lib/R/library/graphics&quot; #&gt; [4] &quot;/home/travis/R-bin/lib/R/library/grDevices&quot; #&gt; [5] &quot;/home/travis/R-bin/lib/R/library/utils&quot; #&gt; [6] &quot;/home/travis/R-bin/lib/R/library/datasets&quot; #&gt; [7] &quot;/home/travis/R-bin/lib/R/library/methods&quot; #&gt; [8] &quot;Autoloads&quot; #&gt; [9] &quot;/home/travis/R-bin/lib/R/library/base&quot; # 返回匹配结果及其所在路径的编号 apropos(&quot;^(read|write)&quot;, where = TRUE, mode = &quot;function&quot;) #&gt; 5 5 9 5 #&gt; &quot;read.csv&quot; &quot;read.csv2&quot; &quot;read.dcf&quot; &quot;read.delim&quot; #&gt; 5 5 5 2 #&gt; &quot;read.delim2&quot; &quot;read.DIF&quot; &quot;read.fortran&quot; &quot;read.ftable&quot; #&gt; 5 5 5 9 #&gt; &quot;read.fwf&quot; &quot;read.socket&quot; &quot;read.table&quot; &quot;readBin&quot; #&gt; 9 5 9 9 #&gt; &quot;readChar&quot; &quot;readCitationFile&quot; &quot;readline&quot; &quot;readLines&quot; #&gt; 9 9 9 5 #&gt; &quot;readRDS&quot; &quot;readRenviron&quot; &quot;write&quot; &quot;write.csv&quot; #&gt; 5 9 2 5 #&gt; &quot;write.csv2&quot; &quot;write.dcf&quot; &quot;write.ftable&quot; &quot;write.socket&quot; #&gt; 5 9 9 9 #&gt; &quot;write.table&quot; &quot;writeBin&quot; &quot;writeChar&quot; &quot;writeLines&quot; 4.1.1 scan scan(file = &quot;&quot;, what = double(), nmax = -1, n = -1, sep = &quot;&quot;, quote = if(identical(sep, &quot;\\n&quot;)) &quot;&quot; else &quot;&#39;\\&quot;&quot;, dec = &quot;.&quot;, skip = 0, nlines = 0, na.strings = &quot;NA&quot;, flush = FALSE, fill = FALSE, strip.white = FALSE, quiet = FALSE, blank.lines.skip = TRUE, multi.line = TRUE, comment.char = &quot;&quot;, allowEscapes = FALSE, fileEncoding = &quot;&quot;, encoding = &quot;unknown&quot;, text, skipNul = FALSE) 首先让我们用 cat 函数创建一个练习数据集 ex.data cat(&quot;TITLE extra line&quot;, &quot;2 3 5 7&quot;, &quot;11 13 17&quot;) #&gt; TITLE extra line 2 3 5 7 11 13 17 cat(&quot;TITLE extra line&quot;, &quot;2 3 5 7&quot;, &quot;11 13 17&quot;, file = &quot;data/ex.data&quot;, sep = &quot;\\n&quot;) 以此练习数据集，介绍 scan 函数最常用的参数 scan(&quot;data/ex.data&quot;) #&gt; Error in scan(&quot;data/ex.data&quot;): scan() expected &#39;a real&#39;, got &#39;TITLE&#39; 从上面的报错信息，我们发现 scan 函数只能读取同一类型的数据，如布尔型 logical， 整型 integer，数值型 numeric(double)， 复数型 complex，字符型 character，raw 和列表 list。所以我们设置参数 skip = 1 把第一行跳过，就成功读取了数据 scan(&quot;data/ex.data&quot;, skip = 1) #&gt; [1] 2 3 5 7 11 13 17 如果设置参数 quiet = TRUE 就不会报告读取的数据量 scan(&quot;data/ex.data&quot;, skip = 1, quiet = TRUE) #&gt; [1] 2 3 5 7 11 13 17 参数 nlines = 1 表示只读取一行数据 scan(&quot;data/ex.data&quot;, skip = 1, nlines = 1) # only 1 line after the skipped one #&gt; [1] 2 3 5 7 默认参数 flush = TRUE 表示读取最后一个请求的字段后，刷新到行尾，下面对比一下读取的结果 scan(&quot;data/ex.data&quot;, what = list(&quot;&quot;, &quot;&quot;, &quot;&quot;)) # flush is F -&gt; read &quot;7&quot; #&gt; Warning in scan(&quot;data/ex.data&quot;, what = list(&quot;&quot;, &quot;&quot;, &quot;&quot;)): number of items read #&gt; is not a multiple of the number of columns #&gt; [[1]] #&gt; [1] &quot;TITLE&quot; &quot;2&quot; &quot;7&quot; &quot;17&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;extra&quot; &quot;3&quot; &quot;11&quot; &quot;&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;line&quot; &quot;5&quot; &quot;13&quot; &quot;&quot; scan(&quot;data/ex.data&quot;, what = list(&quot;&quot;, &quot;&quot;, &quot;&quot;), flush = TRUE) #&gt; [[1]] #&gt; [1] &quot;TITLE&quot; &quot;2&quot; &quot;11&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;extra&quot; &quot;3&quot; &quot;13&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;line&quot; &quot;5&quot; &quot;17&quot; 临时文件 ex.data 用完了，我们调用 unlink 函数将其删除，以免留下垃圾文件 unlink(&quot;data/ex.data&quot;) # tidy up 4.1.2 read.table read.table(file, header = FALSE, sep = &quot;&quot;, quote = &quot;\\&quot;&#39;&quot;, dec = &quot;.&quot;, numerals = c(&quot;allow.loss&quot;, &quot;warn.loss&quot;, &quot;no.loss&quot;), row.names, col.names, as.is = !stringsAsFactors, na.strings = &quot;NA&quot;, colClasses = NA, nrows = -1, skip = 0, check.names = TRUE, fill = !blank.lines.skip, strip.white = FALSE, blank.lines.skip = TRUE, comment.char = &quot;#&quot;, allowEscapes = FALSE, flush = FALSE, stringsAsFactors = default.stringsAsFactors(), fileEncoding = &quot;&quot;, encoding = &quot;unknown&quot;, text, skipNul = FALSE) read.csv(file, header = TRUE, sep = &quot;,&quot;, quote = &quot;\\&quot;&quot;, dec = &quot;.&quot;, fill = TRUE, comment.char = &quot;&quot;, ...) read.csv2(file, header = TRUE, sep = &quot;;&quot;, quote = &quot;\\&quot;&quot;, dec = &quot;,&quot;, fill = TRUE, comment.char = &quot;&quot;, ...) read.delim(file, header = TRUE, sep = &quot;\\t&quot;, quote = &quot;\\&quot;&quot;, dec = &quot;.&quot;, fill = TRUE, comment.char = &quot;&quot;, ...) read.delim2(file, header = TRUE, sep = &quot;\\t&quot;, quote = &quot;\\&quot;&quot;, dec = &quot;,&quot;, fill = TRUE, comment.char = &quot;&quot;, ...) 变量名是不允许以下划线开头的，同样在数据框里，列名也不推荐使用下划线开头。默认情况下，read.table 都会通过参数 check.names 检查列名的有效性，该参数实际调用了函数 make.names 去检查。如果想尽量保持数据集原来的样子可以设置参数 check.names = FALSE, stringsAsFactors = FALSE。 默认情形下，read.table 还会将字符串转化为因子变量，这是 R 的历史原因，作为一门统计学家的必备语言，在统计模型中，字符常用来描述类别，而类别变量在 R 环境中常用因子类型来表示，而且大量内置的统计模型也是将它们视为因子变量，如 lm 、glm 等 dat1 = read.table(header = TRUE, check.names = TRUE, text = &quot; _a _b _c 1 2 a1 3 4 a2 &quot;) dat1 #&gt; X_a X_b X_c #&gt; 1 1 2 a1 #&gt; 2 3 4 a2 dat2 = read.table(header = TRUE, check.names = FALSE, text = &quot; _a _b _c 1 2 a1 3 4 a2 &quot;) dat2 #&gt; _a _b _c #&gt; 1 1 2 a1 #&gt; 2 3 4 a2 dat3 = read.table(header = TRUE, check.names = FALSE, stringsAsFactors = FALSE, text = &quot; _a _b _c 1 2 a1 3 4 a2 &quot;) dat3 #&gt; _a _b _c #&gt; 1 1 2 a1 #&gt; 2 3 4 a2 4.1.3 readLines readLines(con = stdin(), n = -1L, ok = TRUE, warn = TRUE, encoding = &quot;unknown&quot;, skipNul = FALSE) 让我们折腾一波，读进来又写出去，只有 R 3.5.3 以上才能保持原样的正确输入输出，因为这里有一个之前版本包含的 BUG writeLines(readLines(system.file(&quot;DESCRIPTION&quot;, package = &quot;splines&quot;)), &quot;data/DESCRIPTION&quot;) # 比较一下 identical( readLines(system.file(&quot;DESCRIPTION&quot;, package = &quot;splines&quot;)), readLines(&quot;data/DESCRIPTION&quot;) ) #&gt; [1] TRUE 这次我们创建一个真的临时文件，因为重新启动 R 这个文件和文件夹就没有了，回收掉了 fil &lt;- tempfile(fileext = &quot;.data&quot;) cat(&quot;TITLE extra line&quot;, &quot;2 3 5 7&quot;, &quot;&quot;, &quot;11 13 17&quot;, file = fil, sep = &quot;\\n&quot;) fil #&gt; [1] &quot;/tmp/RtmpSNk2fa/file4b57479cd947.data&quot; 设置参数 n = -1 表示将文件 fil 的内容从头读到尾 readLines(fil, n = -1) #&gt; [1] &quot;TITLE extra line&quot; &quot;2 3 5 7&quot; &quot;&quot; &quot;11 13 17&quot; 作为拥有良好习惯的 R 用户，这种垃圾文件最好用后即焚 unlink(fil) # tidy up 再举个例子，我们创建一个新的临时文件 fil，文件内容只有 cat(&quot;123\\nabc&quot;) #&gt; 123 #&gt; abc fil &lt;- tempfile(&quot;test&quot;) cat(&quot;123\\nabc\\n&quot;, file = fil, append = TRUE) fil #&gt; [1] &quot;/tmp/RtmpSNk2fa/test4b5750c4f64a&quot; readLines(fil) #&gt; [1] &quot;123&quot; &quot;abc&quot; 这次读取文件的过程给出了警告，原因是 fil 没有以空行结尾，warn = TRUE 表示这种情况要给出警告，如果设置参数 warn = FALSE 就没有警告。我们还是建议大家尽量遵循规范。 再举一个例子，从一个连接读取数据，建立连接的方式有很多，参见 ?file，下面设置参数 blocking con &lt;- file(fil, &quot;r&quot;, blocking = FALSE) readLines(con) #&gt; [1] &quot;123&quot; &quot;abc&quot; cat(&quot; def\\n&quot;, file = fil, append = TRUE) readLines(con) #&gt; [1] &quot; def&quot; # 关闭连接 close(con) # 清理垃圾文件 unlink(fil) 4.1.4 readRDS 序列化数据操作，Mark Klik 开发的 fst 和 Travers Ching 开发的 qs， Hadley Wickham 开发的 feather 包实现跨语言环境快速的读写数据 表 4.1: fst 序列化数据框对象性能比较 BaseR、 data.table 和 feather16 Method Format Time (ms) Size (MB) Speed (MB/s) N readRDS bin 1577 1000 633 112 saveRDS bin 2042 1000 489 112 fread csv 2925 1038 410 232 fwrite csv 2790 1038 358 241 read_feather bin 3950 813 253 112 write_feather bin 1820 813 549 112 read_fst bin 457 303 2184 282 write_fst bin 314 303 3180 291 目前比较好的是 qs 和 fst 包 4.2 其它数据格式 来自其它格式的数据形式，如 JSON、XML、YAML 需要转化清理成 R 中数据框的形式 data.frame Data Rectangling with jq Mongolite User Manual introduction to using MongoDB with the mongolite client in R jsonlite 读取 *.json 格式的文件，jsonlite::write_json 函数将 R对象保存为 JSON 文件，jsonlite::fromJSON 将 json 字符串或文件转化为 R 对象，jsonlite::toJSON 函数正好与之相反 library(jsonlite) # 从 json 格式的文件导入 # jsonlite::read_json(path = &quot;path/to/filename.json&quot;) # A JSON array of primitives json &lt;- &#39;[&quot;Mario&quot;, &quot;Peach&quot;, null, &quot;Bowser&quot;]&#39; # 简化为原子向量atomic vector fromJSON(json) #&gt; [1] &quot;Mario&quot; &quot;Peach&quot; NA &quot;Bowser&quot; # 默认返回一个列表 fromJSON(json, simplifyVector = FALSE) #&gt; [[1]] #&gt; [1] &quot;Mario&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;Peach&quot; #&gt; #&gt; [[3]] #&gt; NULL #&gt; #&gt; [[4]] #&gt; [1] &quot;Bowser&quot; yaml 包读取 *.yml 格式文件，返回一个列表，yaml::write_yaml 函数将 R 对象写入 yaml 格式 library(yaml) yaml::read_yaml(file = &#39;_bookdown.yml&#39;) #&gt; $delete_merged_file #&gt; [1] TRUE #&gt; #&gt; $language #&gt; $language$label #&gt; $language$label$fig #&gt; [1] &quot;图 &quot; #&gt; #&gt; $language$label$tab #&gt; [1] &quot;表 &quot; #&gt; #&gt; #&gt; $language$ui #&gt; $language$ui$edit #&gt; [1] &quot;编辑&quot; #&gt; #&gt; $language$ui$chapter_name #&gt; [1] &quot;第 &quot; &quot; 章&quot; #&gt; #&gt; #&gt; #&gt; $output_dir #&gt; [1] &quot;_book&quot; #&gt; #&gt; $new_session #&gt; [1] TRUE #&gt; #&gt; $before_chapter_script #&gt; [1] &quot;_common.R&quot; #&gt; #&gt; $rmd_files #&gt; [1] &quot;index.Rmd&quot; &quot;preface.Rmd&quot; #&gt; [3] &quot;setup.Rmd&quot; &quot;files.Rmd&quot; #&gt; [5] &quot;data-objects.Rmd&quot; &quot;data-import.Rmd&quot; #&gt; [7] &quot;data-frame.Rmd&quot; &quot;data-tibble.Rmd&quot; #&gt; [9] &quot;data-table.Rmd&quot; &quot;data-parallel.Rmd&quot; #&gt; [11] &quot;dc-string-manipulation.Rmd&quot; &quot;dc-regular-expressions.Rmd&quot; #&gt; [13] &quot;dv-plot.Rmd&quot; &quot;dv-ggplot2.Rmd&quot; #&gt; [15] &quot;dv-plotly.Rmd&quot; &quot;dv-plot3d.Rmd&quot; #&gt; [17] &quot;dv-colors-fonts.Rmd&quot; &quot;dv-highcharter.Rmd&quot; #&gt; [19] &quot;dv-lattice.Rmd&quot; &quot;dv-network.Rmd&quot; #&gt; [21] &quot;dv-spatio-temporal.Rmd&quot; &quot;dynamic-documents.Rmd&quot; #&gt; [23] &quot;animated-graphics.Rmd&quot; &quot;interactive-graphics.Rmd&quot; #&gt; [25] &quot;cs-cran-network.Rmd&quot; &quot;99-references.Rmd&quot; 表 4.2: 导入来自其它数据分析软件产生的数据集 统计软件 R函数 R包 ERSI ArcGIS read.shapefile shapefiles Matlab readMat R.matlab minitab read.mtp foreign SAS (permanent data) read.ssd foreign SAS (XPORT format) read.xport foreign SPSS read.spss foreign Stata read.dta foreign Systat read.systat foreign Octave read.octave foreign 表 4.3: 导入来自其它格式的数据集 文件格式 R函数 R包 列联表数据 read.ftable stats 二进制数据 readBin base 字符串数据 readChar base 剪贴板数据 readClipboard utils read.dcf 函数读取 Debian 控制格式文件，这种类型的文件以人眼可读的形式在存储数据，如 R 包的 DESCRIPTION 文件或者包含所有 CRAN 上 R 包描述的文件 https://cran.r-project.org/src/contrib/PACKAGES x &lt;- read.dcf(file = system.file(&quot;DESCRIPTION&quot;, package = &quot;splines&quot;), fields = c(&quot;Package&quot;, &quot;Version&quot;, &quot;Title&quot;)) x #&gt; Package Version Title #&gt; [1,] &quot;splines&quot; &quot;4.0.0&quot; &quot;Regression Spline Functions and Classes&quot; 最后要提及拥有瑞士军刀之称的 rio 包，它集合了当前 R 可以读取的所有统计分析软件导出的数据。 4.3 导入大数据集 在不使用数据库的情况下，从命令行导入大数据集，如几百 M 或几个 G 的 csv 文件。利用 data.table 包的 fread 去读取 https://stackoverflow.com/questions/1727772/ 4.4 从数据库导入 Hands-On Programming with R 数据读写章节17 以及 R, Databases and Docker 将大量的 txt 文本存进 MySQL 数据库中，通过操作数据库来聚合文本，极大降低内存消耗18，而 ODBC 与 DBI 包是其它数据库接口的基础，knitr 提供了一个支持 SQL 代码的引擎，它便是基于 DBI，因此可以在 R Markdown 文档中直接使用 SQL 代码块19。这里制作一个归纳表格，左边数据库右边对应其 R 接口，两边都包含链接，如表 4.4 所示 表 4.4: 数据库接口 数据库 官网 R接口 开发仓 MySQL https://www.mysql.com/ RMySQL https://github.com/r-dbi/RMySQL SQLite https://www.sqlite.org RSQLite https://github.com/r-dbi/RSQLite PostgreSQL https://www.postgresql.org/ RPostgres https://github.com/r-dbi/RPostgres MariaDB https://mariadb.org/ RMariaDB https://github.com/r-dbi/RMariaDB 4.4.1 PostgreSQL odbc 可以支持很多数据库，下面以连接 PostgreSQL 数据库为例介绍其过程 首先在某台机器上，拉取 PostgreSQL 的 Docker 镜像 docker pull postgres 在 Docker 上运行 PostgreSQL，主机端口号 8181 映射给数据库 PostgreSQL 的默认端口号 5432（或其它你的 DBA 分配给你的端口） docker run --name psql -d -p 8181:5432 -e ROOT=TRUE \\ -e USER=xiangyun -e PASSWORD=cloud postgres 在主机 Ubuntu 上配置 sudo apt-get install unixodbc unixodbc-dev odbc-postgresql 端口 5432 是分配给 PostgreSQL 的默认端口，host 可以是云端的地址，如 你的亚马逊账户下的 PostgreSQL 数据库地址 &lt;ec2-54-83-201-96.compute-1.amazonaws.com&gt;，也可以是本地局域网IP地址，如&lt;192.168.1.200&gt;。通过参数 dbname 连接到指定的 PostgreSQL 数据库，如 Heroku，这里作为演示就以默认的数据库 postgres 为例 查看配置系统文件路径 odbcinst -j unixODBC 2.3.6 DRIVERS............: /etc/odbcinst.ini SYSTEM DATA SOURCES: /etc/odbc.ini FILE DATA SOURCES..: /etc/ODBCDataSources USER DATA SOURCES..: /root/.odbc.ini SQLULEN Size.......: 8 SQLLEN Size........: 8 SQLSETPOSIROW Size.: 8 不推荐修改全局配置文件，可设置 ODBCSYSINI 环境变量指定配置文件路径，如 ODBCSYSINI=~/ODBC http://www.unixodbc.org/odbcinst.html 安装完驱动程序，/etc/odbcinst.ini 文件内容自动更新，我们可以不必修改，如果你想自定义不妨手动修改，我们查看在 R 环境中注册的数据库，可以看到 PostgreSQL 的驱动已经配置好 odbc::odbcListDrivers() name attribute value 1 PostgreSQL ANSI Description PostgreSQL ODBC driver (ANSI version) 2 PostgreSQL ANSI Driver psqlodbca.so 3 PostgreSQL ANSI Setup libodbcpsqlS.so 4 PostgreSQL ANSI Debug 0 5 PostgreSQL ANSI CommLog 1 6 PostgreSQL ANSI UsageCount 1 7 PostgreSQL Unicode Description PostgreSQL ODBC driver (Unicode version) 8 PostgreSQL Unicode Driver psqlodbcw.so 9 PostgreSQL Unicode Setup libodbcpsqlS.so 10 PostgreSQL Unicode Debug 0 11 PostgreSQL Unicode CommLog 1 12 PostgreSQL Unicode UsageCount 1 系统配置文件 /etc/odbcinst.ini 已经包含有 PostgreSQL 的驱动配置，无需再重复配置 [PostgreSQL ANSI] Description=PostgreSQL ODBC driver (ANSI version) Driver=psqlodbca.so Setup=libodbcpsqlS.so Debug=0 CommLog=1 UsageCount=1 [PostgreSQL Unicode] Description=PostgreSQL ODBC driver (Unicode version) Driver=psqlodbcw.so Setup=libodbcpsqlS.so Debug=0 CommLog=1 UsageCount=1 只需将如下内容存放在 ~/.odbc.ini 文件中， [PostgreSQL] Driver = PostgreSQL Unicode Database = postgres Servername = 172.17.0.1 UserName = postgres Password = default Port = 8080 最后，一行命令 DNS 配置连接 https://github.com/r-dbi/odbc 这样就实现了代码中无任何敏感信息，这里为了展示这个配置过程故而把相关信息公开。 注意下面的内容需要在容器中运行， Windows 环境下的配置 PostgreSQL 的驱动有点麻烦就不搞了，意义也不大，现在数据库基本都是跑在 Linux 系统上 docker-machine.exe ip default 可以获得本地 Docker 的 IP，比如 192.168.99.101。 Travis 上 ip addr 可以查看 Docker 的 IP，如 172.17.0.1 library(DBI) con &lt;- dbConnect(RPostgres::Postgres(), dbname = &quot;postgres&quot;, host = ifelse(is_on_travis, Sys.getenv(&quot;DOCKER_HOST_IP&quot;), &quot;192.168.99.101&quot;), port = 8080, user = &quot;postgres&quot;, password = &quot;default&quot; ) library(DBI) con &lt;- dbConnect(odbc::odbc(), &quot;PostgreSQL&quot;) 列出数据库中的所有表 dbListTables(con) 第一次启动从 Docker Hub 上下载的镜像，默认的数据库是 postgres 里面没有任何表，所以将 R 环境中的 mtcars 数据集写入 postgres 数据库 将数据集 mtcars 写入 PostgreSQL 数据库中，基本操作，写入表的操作也不能缓存，即不能缓存数据库中的表 mtcars dbWriteTable(con, &quot;mtcars&quot;, mtcars, overwrite = TRUE) 现在可以看到数据表 mtcars 的各个字段 dbListFields(con, &quot;mtcars&quot;) 最后执行一条 SQL 语句 res &lt;- dbSendQuery(con, &quot;SELECT * FROM mtcars WHERE cyl = 4&quot;) # 发送 SQL 语句 dbFetch(res) # 获取查询结果 dbClearResult(res) # 清理查询通道 或者一条命令搞定 dbGetQuery(con, &quot;SELECT * FROM mtcars WHERE cyl = 4&quot;) 再复杂一点的 SQL 查询操作 dbGetQuery(con, &quot;SELECT cyl, AVG(mpg) AS mpg FROM mtcars GROUP BY cyl ORDER BY cyl&quot;) aggregate(mpg ~ cyl, data = mtcars, mean) 得益于 knitr (Xie 2015) 开发的钩子，这里直接写 SQL 语句块，打印出来见表 ??，值得注意的是 SQL 代码块不能启用缓存，数据库连接通道也不能缓存，如果数据库中还没有写入表，那么写入表的操作也不能缓存， tab.cap = \"表格标题\" 输出的内容是一个表格 SELECT cyl, AVG(mpg) AS mpg FROM mtcars GROUP BY cyl ORDER BY cyl 如果将查询结果导出到变量，在 Chunk 设置 output.var = \"agg_cyl\" 可以使用缓存，下面将 mpg 按 cyl 分组聚合的结果打印出来，ref.label = \"mtcars\" 引用上一个 SQL 代码块的内容 这种基于 odbc 的方式的好处就不需要再安装 R 包 RPostgres 和相关系统依赖，最后关闭连接通道 dbDisconnect(con) 4.4.2 MySQL MySQL 是一个很常见，应用也很广泛的数据库，数据分析的常见环境是在一个R Notebook 里，我们可以在正文之前先设定数据库连接信息 ```{r setup} library(DBI) # 指定数据库连接信息 db &lt;- dbConnect(RMySQL::MySQL(), dbname = &#39;dbtest&#39;, username = &#39;user_test&#39;, password = &#39;password&#39;, host = &#39;10.10.101.10&#39;, port = 3306 ) # 创建默认连接 knitr::opts_chunk$set(connection = &#39;db&#39;) # 设置字符编码，以免中文查询乱码 DBI::dbSendQuery(db, &#39;SET NAMES utf8&#39;) # 设置日期变量，以运用在SQL中 idate &lt;- &#39;2019-05-03&#39; ``` SQL 代码块中使用 R 环境中的变量，并将查询结果输出为R环境中的数据框 ```{sql, output.var=&#39;data_output&#39;} SELECT * FROM user_table where date_format(created_date,&#39;%Y-%m-%d&#39;)&gt;=?idate ``` 以上代码会将 SQL 的运行结果存在 data_output 这是数据库中，idate 取之前设置的日期2019-05-03，user_table 是 MySQL 数据库中的表名，created_date 是创建user_table时，指定的日期名。 如果 SQL 比较长，为了代码美观，把带有变量的 SQL 保存为demo.sql脚本，只需要在 SQL 的 chunk 中直接读取 SQL 文件20。 ```{sql, code=readLines(&#39;demo.sql&#39;), output.var=&#39;data_output&#39;} ``` 如果我们需要每天或者按照指定的日期重复地运行这个 R Markdown 文件，可以在 YAML 部分引入参数21 --- params: date: &quot;2019-05-03&quot; # 参数化日期 --- ```{r setup, include=FALSE} idate = params$date # 将参数化日期传递给 idate 变量 ``` 我们将这个 Rmd 文件命名为 MyDocument.Rmd，运行这个文件可以从 R 控制台执行或在 RStudio 点击 knit。 rmarkdown::render(&quot;MyDocument.Rmd&quot;, params = list( date = &quot;2019-05-03&quot; )) 如果在文档的 YAML 位置已经指定日期，这里可以不指定。注意在这里设置日期会覆盖 YAML 处指定的参数值，这样做的好处是可以批量化操作。 4.4.3 Spark 当数据分析报告遇上 Spark 时，就需要 SparkR、 sparklyr、 arrow 或 rsparking 接口了， Javier Luraschi 写了一本书 The R in Spark: Learning Apache Spark with R 详细介绍了相关扩展和应用 首先安装 sparklyr 包，RStudio 公司 Javier Lurasch 开发了 sparklyr 包，作为 Spark 与 R 语言之间的接口，安装完 sparklyr 包，还是需要 Spark 和 Hadoop 环境 install.packages(&#39;sparklyr&#39;) library(sparklyr) spark_install() # Installing Spark 2.4.0 for Hadoop 2.7 or later. # Downloading from: # - &#39;https://archive.apache.org/dist/spark/spark-2.4.0/spark-2.4.0-bin-hadoop2.7.tgz&#39; # Installing to: # - &#39;~/spark/spark-2.4.0-bin-hadoop2.7&#39; # trying URL &#39;https://archive.apache.org/dist/spark/spark-2.4.0/spark-2.4.0-bin-hadoop2.7.tgz&#39; # Content type &#39;application/x-gzip&#39; length 227893062 bytes (217.3 MB) # ================================================== # downloaded 217.3 MB # # Installation complete. 既然 sparklyr 已经安装了 Spark 和 Hadoop 环境，安装 SparkR 后，只需配置好路径，就可以加载 SparkR 包 install.packages(&#39;SparkR&#39;) if (nchar(Sys.getenv(&quot;SPARK_HOME&quot;)) &lt; 1) { Sys.setenv(SPARK_HOME = &quot;~/spark/spark-2.4.0-bin-hadoop2.7&quot;) } library(SparkR, lib.loc = c(file.path(Sys.getenv(&quot;SPARK_HOME&quot;), &quot;R&quot;, &quot;lib&quot;))) sparkR.session(master = &quot;local[*]&quot;, sparkConfig = list(spark.driver.memory = &quot;2g&quot;)) rscala 架起了 R 和 Scala 两门语言之间交流的桥梁，使得彼此之间可以互相调用 是否存在这样的可能， Spark 提供了大量的 MLib 库的调用接口，R 的功能支持是最少的，Java/Scala 是原生的，那么要么自己开发新的功能整合到 SparkR 中，要么借助 rscala 将 scala 接口代码封装进来 在本地，Windows 主机上，可以在 .Rprofile 中给 Spark 添加环境变量 SPARK_HOME 指定其安装路径， # Windows 平台默认安装路径 Sys.setenv(SPARK_HOME = &quot;C:/Users/XiangYun/AppData/Local/spark/spark-2.4.3-bin-hadoop2.7&quot;) library(sparklyr) sc &lt;- spark_connect(master = &quot;local&quot;, version = &quot;2.4&quot;) 将 R 环境中的数据集 mtcars 传递到 Spark 上 cars &lt;- copy_to(sc, mtcars) cars # Source: spark&lt;mtcars&gt; [?? x 11] mpg cyl disp hp drat wt qsec vs am gear carb &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 # ... with more rows 监控和分析命令执行的情况，可以在浏览器中，见图 4.1 spark_web(sc) 图 4.1: Spark Web 接口 传递 SQL 查询语句，比如数据集 mtcars 有多少行 library(DBI) dbGetQuery(sc, &quot;SELECT count(*) FROM mtcars&quot;) count(1) 1 32 进一步地，我们可以调用 dplyr 包来写数据操作，避免写复杂逻辑的 SQL 语句， # library(dplyr) # 数据操作 library(tidyverse) # 提供更多功能，包括数据可视化 count(cars) 再举一个稍复杂的操作，先从数据集 cars 中选择两个字段 hp 和 mpg select(cars, hp, mpg) %&gt;% sample_n(100) %&gt;% # 随机选择 100 行 collect() %&gt;% # 执行 SQL 查询，将结果返回到本地 ggplot(aes(hp, mpg)) + # 绘图 geom_point() 数据查询和结果可视化，见图 4.2 图 4.2: 数据聚合和可视化 用完要记得关闭连接 spark_disconnect(sc) 不要使用 SparkR 接口，要使用 sparklyr， 后者的功能已经全面覆盖前者，生态方面更是更是已经远远超越，它有大厂 RStudio 支持，是公司支持的旗舰项目。但是 sparklyr 的版本稍微比最新的 Spark 低一两个版本，这是开发周期和出于稳定性的考虑，无伤大雅！ Spark 提供了官方 R 语言接口 SparkR。Spark JVM 和 SparkR 包版本要匹配，比如从 CRAN 上安装了最新版的 SparkR，比如版本 2.4.4 就要去 Spark 官网下载最新版的预编译文件 spark-2.4.4-bin-hadoop2.7，解压到本地磁盘，比如 D:/spark-2.4.4-bin-hadoop2.7 Sys.setenv(SPARK_HOME = &quot;D:/spark-2.4.4-bin-hadoop2.7&quot;) # Sys.setenv(R_HOME = &quot;C:/Program Files/R/R-3.6.1/&quot;) library(SparkR, lib.loc = c(file.path(Sys.getenv(&quot;SPARK_HOME&quot;), &quot;R&quot;, &quot;lib&quot;))) sparkR.session(master = &quot;local[*]&quot;, sparkConfig = list(spark.driver.memory = &quot;4g&quot;), enableHiveSupport = TRUE) 从数据集 mtcars（数据类型是 R 的 data.frame） 创建 Spark 的 DataFrame 类型数据 cars &lt;- as.DataFrame(mtcars) # 显示 SparkDataFrame 的前几行 head(cars) mpg cyl disp hp drat wt qsec vs am gear carb 1 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 2 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 3 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 4 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 5 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 6 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 打印数据集 cars 的 schema 各个字段的 printSchema(cars) root |-- mpg: double (nullable = true) |-- cyl: double (nullable = true) |-- disp: double (nullable = true) |-- hp: double (nullable = true) |-- drat: double (nullable = true) |-- wt: double (nullable = true) |-- qsec: double (nullable = true) |-- vs: double (nullable = true) |-- am: double (nullable = true) |-- gear: double (nullable = true) |-- carb: double (nullable = true) 从本地 JSON 文件创建 DataFrame path &lt;- file.path(Sys.getenv(&quot;SPARK_HOME&quot;), &quot;examples/src/main/resources/people.json&quot;) peopleDF &lt;- read.json(path) printSchema(peopleDF) root |-- age: long (nullable = true) |-- name: string (nullable = true) peopleDF SparkDataFrame[age:bigint, name:string] showDF(peopleDF) +----+-------+ | age| name| +----+-------+ |null|Michael| | 30| Andy| | 19| Justin| +----+-------+ peopleDF 转成 Hive 中的表 people createOrReplaceTempView(peopleDF, &quot;people&quot;) 调用 sql 传递 SQL 语句查询数据，启动 sparkR.session 时，设置 enableHiveSupport = TRUE，就是执行不出来，报错，不知道哪里配置存在问题 teenagers &lt;- SparkR::sql(&quot;SELECT name FROM people WHERE age &gt;= 13 AND age &lt;= 19&quot;) show(people) Error in handleErrors(returnStatus, conn) : org.apache.spark.sql.AnalysisException: java.lang.RuntimeException: java.io.IOException: (null) entry in command string: null chmod 0733 F:\\tmp\\hive; at org.apache.spark.sql.hive.HiveExternalCatalog.withClient(HiveExternalCatalog.scala:106) at org.apache.spark.sql.hive.HiveExternalCatalog.databaseExists(HiveExternalCatalog.scala:214) at org.apache.spark.sql.internal.SharedState.externalCatalog$lzycompute(SharedState.scala:114) at org.apache.spark.sql.internal.SharedState.externalCatalog(SharedState.scala:102) at org.apache.spark.sql.internal.SharedState.globalTempViewManager$lzycompute(SharedState.scala:141) at org.apache.spark.sql.internal.SharedState.globalTempViewManager(SharedState.scala:136) at org.apache.spark.sql.hive.HiveSessionStateBuilder$$anonfun$2.apply(HiveSessionStateBuilder.scala:55) at org.apache.spark.sql.hive.HiveSessionStateBuilder$$anonfun$2.apply(HiveSessionStateBuilder.scala:55) at org.apache.spark.sql.catalyst.catalog.SessionCatalog.gl 调用 collect 函数执行查询，并将结果返回到本地 data.frame 类型 teenagersLocalDF &lt;- collect(teenagers) 查看数据集 teenagersLocalDF 的属性 print(teenagersLocalDF) 最后，关闭 SparkSession 会话 sparkR.session.stop() 4.5 批量导入数据 library(tidyverse) read_list &lt;- function(list_of_datasets, read_func) { read_and_assign &lt;- function(dataset, read_func) { dataset_name &lt;- as.name(dataset) dataset_name &lt;- read_func(dataset) } # invisible is used to suppress the unneeded output output &lt;- invisible( sapply(list_of_datasets, read_and_assign, read_func = read_func, simplify = FALSE, USE.NAMES = TRUE ) ) # Remove the extension at the end of the data set names names_of_datasets &lt;- c(unlist(strsplit(list_of_datasets, &quot;[.]&quot;))[c(T, F)]) names(output) &lt;- names_of_datasets return(output) } 批量导入文件扩展名为 .csv 的数据文件，即逗号分割的文件 data_files &lt;- list.files(path = &quot;path/to/csv/dir&quot;, pattern = &quot;.csv&quot;, full.names = TRUE) print(data_files) 相比于 Base R 提供的 read.csv 函数，使用 readr 包的 read_csv 函数可以更快地读取csv格式文件，特别是在读取GB级数据文件时，效果特别明显。 list_of_data_sets &lt;- read_list(data_files, readr::read_csv) 使用 tibble 包的glimpse函数可以十分方便地对整个数据集有一个大致的了解，展示方式和信息量相当于 str 加 head 函数 tibble::glimpse(list_of_data_sets) 4.6 批量导出数据 假定我们有一个列表，其每个元素都是一个数据框，现在要把每个数据框分别存入 xlsx 表的工作薄中，以 mtcars 数据集为例，将其按分类变量 cyl 分组拆分，获得一个列表 list dat &lt;- split(mtcars, mtcars$cyl) dat #&gt; $`4` #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 #&gt; Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 #&gt; Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 #&gt; Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 #&gt; Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 #&gt; Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 #&gt; Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 #&gt; Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 #&gt; Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 #&gt; Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 #&gt; Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 #&gt; #&gt; $`6` #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 #&gt; Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 #&gt; Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 #&gt; Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 #&gt; Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 #&gt; Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 #&gt; Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 #&gt; #&gt; $`8` #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 #&gt; Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 #&gt; Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 #&gt; Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 #&gt; Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 #&gt; Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 #&gt; Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 #&gt; Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 #&gt; Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 #&gt; AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 #&gt; Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 #&gt; Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 #&gt; Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 #&gt; Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 将 xlsx 表格初始化，创建空白的工作薄， openxlsx 包不依赖 Java 环境，读写效率也高 ## 加载 openxlsx 包 library(openxlsx) ## 创建空白的工作薄 wb &lt;- createWorkbook() 将列表里的每张表分别存入 xlsx 表格的每个 worksheet，worksheet 的名字就是分组变量的名字 Map(function(data, name){ addWorksheet(wb, name) writeData(wb, name, data) }, dat, names(dat)) 最后保存数据到磁盘，见图 4.3 saveWorkbook(wb, file = &quot;data/matcars.xlsx&quot;, overwrite = TRUE) 图 4.3: 批量导出数据 处理 Excel 2003 (XLS) 和 Excel 2007 (XLSX) 文件还可以使用 WriteXLS 包，不过它依赖于 Perl，另一个 R 包 xlsx 与之功能类似，依赖 Java 环境。Jennifer Bryan 和 Hadley Wickham 开发的 readxl 包和 Jeroen Ooms 开发的 writexl 包专门处理 xlsx 格式并且无任何系统依赖 4.7 导出数据 4.7.1 导出运行结果 capture.output(..., file = NULL, append = FALSE, type = c(&quot;output&quot;, &quot;message&quot;), split = FALSE) capture.output 将一段R代码执行结果，保存到文件，参数为表达式。capture.output 和 sink 的关系相当于 with 和 attach 的关系。 glmout &lt;- capture.output(summary(glm(case ~ spontaneous + induced, data = infert, family = binomial() )), file = &quot;data/capture.txt&quot;) capture.output(1 + 1, 2 + 2) #&gt; [1] &quot;[1] 2&quot; &quot;[1] 4&quot; capture.output({ 1 + 1 2 + 2 }) #&gt; [1] &quot;[1] 4&quot; sink 函数将控制台输出结果保存到文件，只将 outer 函数运行的结果保存到 ex-sink.txt 文件，outer 函数计算的是直积，在这里相当于 seq(10) %*% t(seq(10))，而在 R 语言中，更加有效的计算方式是 tcrossprod(seq(10),seq(10)) sink(&quot;data/ex-sink.txt&quot;) i &lt;- 1:10 outer(i, i, &quot;*&quot;) #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #&gt; [1,] 1 2 3 4 5 6 7 8 9 10 #&gt; [2,] 2 4 6 8 10 12 14 16 18 20 #&gt; [3,] 3 6 9 12 15 18 21 24 27 30 #&gt; [4,] 4 8 12 16 20 24 28 32 36 40 #&gt; [5,] 5 10 15 20 25 30 35 40 45 50 #&gt; [6,] 6 12 18 24 30 36 42 48 54 60 #&gt; [7,] 7 14 21 28 35 42 49 56 63 70 #&gt; [8,] 8 16 24 32 40 48 56 64 72 80 #&gt; [9,] 9 18 27 36 45 54 63 72 81 90 #&gt; [10,] 10 20 30 40 50 60 70 80 90 100 sink() 4.7.2 导出数据对象 load(file, envir = parent.frame(), verbose = FALSE) save(..., list = character(), file = stop(&quot;&#39;file&#39; must be specified&quot;), ascii = FALSE, version = NULL, envir = parent.frame(), compress = isTRUE(!ascii), compression_level, eval.promises = TRUE, precheck = TRUE) save.image(file = &quot;.RData&quot;, version = NULL, ascii = FALSE, compress = !ascii, safe = TRUE) load 和save 函数加载或保存包含工作环境信息的数据对象，save.image 保存当前工作环境到磁盘，即保存工作空间中所有数据对象，数据格式为 .RData，即相当于 save(list = ls(all.names = TRUE), file = &quot;.RData&quot;, envir = .GlobalEnv) dump 保存数据对象 AirPassengers 到文件 AirPassengers.txt，文件内容是 R 命令，可把AirPassengers.txt看作代码文档执行，dput 保存数据对象内容到文件AirPassengers.dat，文件中不包含变量名 AirPassengers。注意到 dump 输入是一个字符串，而 dput 要求输入数据对象的名称，source 函数与 dump 对应，而 dget 与 dput对应。 # 加载数据 data(AirPassengers, package = &quot;datasets&quot;) # 将数据以R代码块的形式保存到文件 dump(&#39;AirPassengers&#39;, file = &#39;data/AirPassengers.txt&#39;) # source(file = &#39;data/AirPassengers.txt&#39;) 接下来，我们读取 AirPassengers.txt 的文件内容，可见它是一段完整的 R 代码，可以直接复制到 R 的控制台中运行，并且得到一个与原始 AirPassengers 变量一样的结果 cat(readLines(&#39;data/AirPassengers.txt&#39;), sep = &quot;\\n&quot;) #&gt; AirPassengers &lt;- #&gt; structure(c(112, 118, 132, 129, 121, 135, 148, 148, 136, 119, #&gt; 104, 118, 115, 126, 141, 135, 125, 149, 170, 170, 158, 133, 114, #&gt; 140, 145, 150, 178, 163, 172, 178, 199, 199, 184, 162, 146, 166, #&gt; 171, 180, 193, 181, 183, 218, 230, 242, 209, 191, 172, 194, 196, #&gt; 196, 236, 235, 229, 243, 264, 272, 237, 211, 180, 201, 204, 188, #&gt; 235, 227, 234, 264, 302, 293, 259, 229, 203, 229, 242, 233, 267, #&gt; 269, 270, 315, 364, 347, 312, 274, 237, 278, 284, 277, 317, 313, #&gt; 318, 374, 413, 405, 355, 306, 271, 306, 315, 301, 356, 348, 355, #&gt; 422, 465, 467, 404, 347, 305, 336, 340, 318, 362, 348, 363, 435, #&gt; 491, 505, 404, 359, 310, 337, 360, 342, 406, 396, 420, 472, 548, #&gt; 559, 463, 407, 362, 405, 417, 391, 419, 461, 472, 535, 622, 606, #&gt; 508, 461, 390, 432), .Tsp = c(1949, 1960.91666666667, 12), class = &quot;ts&quot;) dput 函数类似 dump 函数，保存数据对象到磁盘文件 # 将 R 对象保存/导出到磁盘 dput(AirPassengers, file = &#39;data/AirPassengers.dat&#39;) AirPassengers Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec 1949 112 118 132 129 121 135 148 148 136 119 104 118 1950 115 126 141 135 125 149 170 170 158 133 114 140 1951 145 150 178 163 172 178 199 199 184 162 146 166 1952 171 180 193 181 183 218 230 242 209 191 172 194 1953 196 196 236 235 229 243 264 272 237 211 180 201 1954 204 188 235 227 234 264 302 293 259 229 203 229 1955 242 233 267 269 270 315 364 347 312 274 237 278 1956 284 277 317 313 318 374 413 405 355 306 271 306 1957 315 301 356 348 355 422 465 467 404 347 305 336 1958 340 318 362 348 363 435 491 505 404 359 310 337 1959 360 342 406 396 420 472 548 559 463 407 362 405 1960 417 391 419 461 472 535 622 606 508 461 390 432 # dget 作用与 dput 相反 AirPassengers2 &lt;- dget(file = &#39;data/AirPassengers.dat&#39;) AirPassengers2 Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec 1949 112 118 132 129 121 135 148 148 136 119 104 118 1950 115 126 141 135 125 149 170 170 158 133 114 140 1951 145 150 178 163 172 178 199 199 184 162 146 166 1952 171 180 193 181 183 218 230 242 209 191 172 194 1953 196 196 236 235 229 243 264 272 237 211 180 201 1954 204 188 235 227 234 264 302 293 259 229 203 229 1955 242 233 267 269 270 315 364 347 312 274 237 278 1956 284 277 317 313 318 374 413 405 355 306 271 306 1957 315 301 356 348 355 422 465 467 404 347 305 336 1958 340 318 362 348 363 435 491 505 404 359 310 337 1959 360 342 406 396 420 472 548 559 463 407 362 405 1960 417 391 419 461 472 535 622 606 508 461 390 432 同样地，现在我们观察 dput 函数保存的文件 AirPassengers.dat 内容，和dump 函数保存的文件 AirPassengers.txt相比，就缺一个赋值变量 cat(readLines(&#39;data/AirPassengers.dat&#39;), sep = &quot;\\n&quot;) structure(c(112, 118, 132, 129, 121, 135, 148, 148, 136, 119, 104, 118, 115, 126, 141, 135, 125, 149, 170, 170, 158, 133, 114, 140, 145, 150, 178, 163, 172, 178, 199, 199, 184, 162, 146, 166, 171, 180, 193, 181, 183, 218, 230, 242, 209, 191, 172, 194, 196, 196, 236, 235, 229, 243, 264, 272, 237, 211, 180, 201, 204, 188, 235, 227, 234, 264, 302, 293, 259, 229, 203, 229, 242, 233, 267, 269, 270, 315, 364, 347, 312, 274, 237, 278, 284, 277, 317, 313, 318, 374, 413, 405, 355, 306, 271, 306, 315, 301, 356, 348, 355, 422, 465, 467, 404, 347, 305, 336, 340, 318, 362, 348, 363, 435, 491, 505, 404, 359, 310, 337, 360, 342, 406, 396, 420, 472, 548, 559, 463, 407, 362, 405, 417, 391, 419, 461, 472, 535, 622, 606, 508, 461, 390, 432), .Tsp = c(1949, 1960.91666666667, 12), class = &quot;ts&quot;) 4.8 运行环境 xfun::session_info() #&gt; R Under development (unstable) (2020-02-04 r77771) #&gt; Platform: x86_64-pc-linux-gnu (64-bit) #&gt; Running under: Ubuntu 16.04.6 LTS #&gt; #&gt; Locale: #&gt; LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C #&gt; LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 #&gt; LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 #&gt; LC_PAPER=en_US.UTF-8 LC_NAME=C #&gt; LC_ADDRESS=C LC_TELEPHONE=C #&gt; LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C #&gt; #&gt; Package version: #&gt; base64enc_0.1.3 bookdown_0.17 compiler_4.0.0 curl_4.3 #&gt; digest_0.6.23 evaluate_0.14 glue_1.3.1 graphics_4.0.0 #&gt; grDevices_4.0.0 highr_0.8 htmltools_0.4.0 jsonlite_1.6.1 #&gt; knitr_1.26 magrittr_1.5 markdown_1.1 methods_4.0.0 #&gt; mime_0.9 Rcpp_1.0.3 rlang_0.4.4 rmarkdown_2.1 #&gt; stats_4.0.0 stringi_1.4.5 stringr_1.4.0 tinytex_0.19 #&gt; tools_4.0.0 utils_4.0.0 xfun_0.12 yaml_2.2.1 参考文献 "],
["data-frame.html", "第 5 章 数据操作手 5.1 查看数据 5.2 数据变形 5.3 数据转换 5.4 提取子集 5.5 按列排序 5.6 数据拆分 5.7 数据合并 5.8 数据去重 5.9 数据缺失 5.10 数据聚合 5.11 表格统计 5.12 索引访问 5.13 多维数组 5.14 其它操作 5.15 运行环境", " 第 5 章 数据操作手 参考 Data Manipulation With R (Spector 2008) 重新捋一遍本章 本章的操作对象是 data.frame 介绍 Base R 提供的数据操作，关于采用 Base R 还是 tidyverse 做数据操作的 讨论 数据操作的动画展示参考 https://github.com/gadenbuie/tidyexplain 提供 Base R 对应的实现 什么是 Base R? Base R 指的是 R 语言/软件的核心组件，由 R Core Team 维护 Pkgs &lt;- sapply(list.files(R.home(&quot;library&quot;)), function(x) packageDescription(pkg = x, fields = &quot;Priority&quot;)) names(Pkgs[Pkgs == &quot;base&quot; &amp; !is.na(Pkgs)]) #&gt; [1] &quot;base&quot; &quot;compiler&quot; &quot;datasets&quot; &quot;graphics&quot; &quot;grDevices&quot; &quot;grid&quot; #&gt; [7] &quot;methods&quot; &quot;parallel&quot; &quot;splines&quot; &quot;stats&quot; &quot;stats4&quot; &quot;tcltk&quot; #&gt; [13] &quot;tools&quot; &quot;utils&quot; names(Pkgs[Pkgs == &quot;recommended&quot; &amp; !is.na(Pkgs)]) #&gt; [1] &quot;boot&quot; &quot;class&quot; &quot;cluster&quot; &quot;codetools&quot; &quot;foreign&quot; #&gt; [6] &quot;KernSmooth&quot; &quot;lattice&quot; &quot;MASS&quot; &quot;Matrix&quot; &quot;mgcv&quot; #&gt; [11] &quot;nlme&quot; &quot;nnet&quot; &quot;rpart&quot; &quot;spatial&quot; &quot;survival&quot; 数据变形，分组统计聚合等，用以作为模型的输入，绘图的对象，操作的数据对象是数据框(data.frame)类型的，而且如果没有特别说明，文中出现的数据集都是 Base R 内置的，第三方 R 包或者来源于网上的数据集都会加以说明。 5.1 查看数据 查看属性 str(iris) #&gt; &#39;data.frame&#39;: 150 obs. of 5 variables: #&gt; $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... #&gt; $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... #&gt; $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... #&gt; $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... #&gt; $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1.. 查看部分数据集 head(iris, 5) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 1 5.1 3.5 1.4 0.2 setosa #&gt; 2 4.9 3.0 1.4 0.2 setosa #&gt; 3 4.7 3.2 1.3 0.2 setosa #&gt; 4 4.6 3.1 1.5 0.2 setosa #&gt; 5 5.0 3.6 1.4 0.2 setosa tail(iris, 5) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 146 6.7 3.0 5.2 2.3 virginica #&gt; 147 6.3 2.5 5.0 1.9 virginica #&gt; 148 6.5 3.0 5.2 2.0 virginica #&gt; 149 6.2 3.4 5.4 2.3 virginica #&gt; 150 5.9 3.0 5.1 1.8 virginica 查看文件前（后）5行 head -n 5 test.csv tail -n 5 test.csv 对象的类型，存储方式 class(iris) #&gt; [1] &quot;data.frame&quot; mode(iris) #&gt; [1] &quot;list&quot; typeof(iris) #&gt; [1] &quot;list&quot; 查看对象在R环境中所占空间的大小 object.size(iris) #&gt; 7256 bytes object.size(letters) #&gt; 1712 bytes object.size(ls) #&gt; 89880 bytes format(object.size(library), units = &quot;auto&quot;) #&gt; [1] &quot;1.8 Mb&quot; 5.2 数据变形 重复测量数据的变形 Reshape Grouped Data，将宽格式 wide 的数据框变长格式 long的，反之也行。reshape 还支持正则表达式 str(Indometh) #&gt; Classes &#39;nfnGroupedData&#39;, &#39;nfGroupedData&#39;, &#39;groupedData&#39; and &#39;data.frame&#39;: 66 obs. of 3 variables: #&gt; $ Subject: Ord.factor w/ 6 levels &quot;1&quot;&lt;&quot;4&quot;&lt;&quot;2&quot;&lt;&quot;5&quot;&lt;..: 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ time : num 0.25 0.5 0.75 1 1.25 2 3 4 5 6 ... #&gt; $ conc : num 1.5 0.94 0.78 0.48 0.37 0.19 0.12 0.11 0.08 0.07 ... #&gt; - attr(*, &quot;formula&quot;)=Class &#39;formula&#39; language conc ~ time | Subject #&gt; .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_EmptyEnv&gt; #&gt; - attr(*, &quot;labels&quot;)=List of 2 #&gt; ..$ x: chr &quot;Time since drug administration&quot; #&gt; ..$ y: chr &quot;Indomethacin concentration&quot; #&gt; - attr(*, &quot;units&quot;)=List of 2 #&gt; ..$ x: chr &quot;(hr)&quot; #&gt; ..$ y: chr &quot;(mcg/ml)&quot; summary(Indometh) #&gt; Subject time conc #&gt; 1:11 Min. :0.250 Min. :0.0500 #&gt; 4:11 1st Qu.:0.750 1st Qu.:0.1100 #&gt; 2:11 Median :2.000 Median :0.3400 #&gt; 5:11 Mean :2.886 Mean :0.5918 #&gt; 6:11 3rd Qu.:5.000 3rd Qu.:0.8325 #&gt; 3:11 Max. :8.000 Max. :2.7200 # 长的变宽 wide &lt;- reshape(Indometh, v.names = &quot;conc&quot;, idvar = &quot;Subject&quot;, timevar = &quot;time&quot;, direction = &quot;wide&quot; ) wide[, 1:6] #&gt; Subject conc.0.25 conc.0.5 conc.0.75 conc.1 conc.1.25 #&gt; 1 1 1.50 0.94 0.78 0.48 0.37 #&gt; 12 2 2.03 1.63 0.71 0.70 0.64 #&gt; 23 3 2.72 1.49 1.16 0.80 0.80 #&gt; 34 4 1.85 1.39 1.02 0.89 0.59 #&gt; 45 5 2.05 1.04 0.81 0.39 0.30 .... # 宽的变长 reshape(wide, direction = &quot;long&quot;) #&gt; Subject time conc #&gt; 1.0.25 1 0.25 1.50 #&gt; 2.0.25 2 0.25 2.03 #&gt; 3.0.25 3 0.25 2.72 #&gt; 4.0.25 4 0.25 1.85 #&gt; 5.0.25 5 0.25 2.05 .... 宽的格式变成长的格式 https://stackoverflow.com/questions/2185252 长的格式变成宽的格式 https://stackoverflow.com/questions/5890584/ set.seed(45) dat &lt;- data.frame( name = rep(c(&quot;Orange&quot;, &quot;Apple&quot;), each=4), numbers = rep(1:4, 2), value = rnorm(8)) dat #&gt; name numbers value #&gt; 1 Orange 1 0.3407997 #&gt; 2 Orange 2 -0.7033403 #&gt; 3 Orange 3 -0.3795377 #&gt; 4 Orange 4 -0.7460474 #&gt; 5 Apple 1 -0.8981073 #&gt; 6 Apple 2 -0.3347941 #&gt; 7 Apple 3 -0.5013782 #&gt; 8 Apple 4 -0.1745357 reshape(dat, idvar = &quot;name&quot;, timevar = &quot;numbers&quot;, direction = &quot;wide&quot;) #&gt; name value.1 value.2 value.3 value.4 #&gt; 1 Orange 0.3407997 -0.7033403 -0.3795377 -0.7460474 #&gt; 5 Apple -0.8981073 -0.3347941 -0.5013782 -0.1745357 ## times need not be numeric df &lt;- data.frame(id = rep(1:4, rep(2,4)), visit = I(rep(c(&quot;Before&quot;,&quot;After&quot;), 4)), x = rnorm(4), y = runif(4)) df #&gt; id visit x y #&gt; 1 1 Before 1.8090374 0.89106978 #&gt; 2 1 After -0.2301050 0.06920426 #&gt; 3 2 Before -1.1304182 0.94623103 #&gt; 4 2 After 0.2159889 0.74850150 #&gt; 5 3 Before 1.8090374 0.89106978 #&gt; 6 3 After -0.2301050 0.06920426 #&gt; 7 4 Before -1.1304182 0.94623103 #&gt; 8 4 After 0.2159889 0.74850150 reshape(df, timevar = &quot;visit&quot;, idvar = &quot;id&quot;, direction = &quot;wide&quot;) #&gt; id x.Before y.Before x.After y.After #&gt; 1 1 1.809037 0.8910698 -0.2301050 0.06920426 #&gt; 3 2 -1.130418 0.9462310 0.2159889 0.74850150 #&gt; 5 3 1.809037 0.8910698 -0.2301050 0.06920426 #&gt; 7 4 -1.130418 0.9462310 0.2159889 0.74850150 ## warns that y is really varying reshape(df, timevar = &quot;visit&quot;, idvar = &quot;id&quot;, direction = &quot;wide&quot;, v.names = &quot;x&quot;) #&gt; Warning in reshapeWide(data, idvar = idvar, timevar = timevar, varying = #&gt; varying, : some constant variables (y) are really varying #&gt; id y x.Before x.After #&gt; 1 1 0.8910698 1.809037 -0.2301050 #&gt; 3 2 0.9462310 -1.130418 0.2159889 #&gt; 5 3 0.8910698 1.809037 -0.2301050 #&gt; 7 4 0.9462310 -1.130418 0.2159889 更加复杂的例子， gambia 数据集，重塑的效果是使得个体水平的长格式变为村庄水平的宽格式 # data(gambia, package = &quot;geoR&quot;) # 在线下载数据集 gambia &lt;- read.table( file = paste(&quot;http://www.leg.ufpr.br/lib/exe/fetch.php&quot;, &quot;pessoais:paulojus:mbgbook:datasets:gambia.txt&quot;, sep = &quot;/&quot; ), header = TRUE ) head(gambia) # Building a &quot;village-level&quot; data frame ind &lt;- paste(&quot;x&quot;, gambia[, 1], &quot;y&quot;, gambia[, 2], sep = &quot;&quot;) village &lt;- gambia[!duplicated(ind), c(1:2, 7:8)] village$prev &lt;- as.vector(tapply(gambia$pos, ind, mean)) head(village) 5.3 数据转换 transform 对数据框中的某些列做计算，取对数，将计算的结果单存一列加到数据框中 transform(iris, scale.sl = (max(Sepal.Length) - Sepal.Length) / (max(Sepal.Length) - min(Sepal.Length))) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species scale.sl #&gt; 1 5.1 3.5 1.4 0.2 setosa 0.77777778 #&gt; 2 4.9 3.0 1.4 0.2 setosa 0.83333333 #&gt; 3 4.7 3.2 1.3 0.2 setosa 0.88888889 #&gt; 4 4.6 3.1 1.5 0.2 setosa 0.91666667 #&gt; 5 5.0 3.6 1.4 0.2 setosa 0.80555556 .... 验证一下 scale.sl 变量的第一个值 (max(iris$Sepal.Length) - 5.1) / (max(iris$Sepal.Length) - min(iris$Sepal.Length)) #&gt; [1] 0.7777778 Warning: This is a convenience function intended for use interactively. For programming it is better to use the standard subsetting arithmetic functions, and in particular the non-standard evaluation of argument transform can have unanticipated consequences. 5.4 提取子集 subset(x, subset, select, drop = FALSE, ...) 参数 subset代表行操作，select 代表列操作，函数 subset 从数据框中提取部分数据 subset(iris, Species == &quot;virginica&quot;) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 101 6.3 3.3 6.0 2.5 virginica #&gt; 102 5.8 2.7 5.1 1.9 virginica #&gt; 103 7.1 3.0 5.9 2.1 virginica #&gt; 104 6.3 2.9 5.6 1.8 virginica #&gt; 105 6.5 3.0 5.8 2.2 virginica .... # summary(iris$Sepal.Length) mean(iris$Sepal.Length) # 且的逻辑 # subset(iris, Species == &quot;virginica&quot; &amp; Sepal.Length &gt; 5.84333) subset(iris, Species == &quot;virginica&quot; &amp; Sepal.Length &gt; mean(Sepal.Length)) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 101 6.3 3.3 6.0 2.5 virginica #&gt; 103 7.1 3.0 5.9 2.1 virginica #&gt; 104 6.3 2.9 5.6 1.8 virginica #&gt; 105 6.5 3.0 5.8 2.2 virginica #&gt; 106 7.6 3.0 6.6 2.1 virginica .... # 在行的子集范围内 subset(iris, Species %in% c(&quot;virginica&quot;, &quot;versicolor&quot;) &amp; Sepal.Length &gt; mean(Sepal.Length)) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 51 7.0 3.2 4.7 1.4 versicolor #&gt; 52 6.4 3.2 4.5 1.5 versicolor #&gt; 53 6.9 3.1 4.9 1.5 versicolor #&gt; 55 6.5 2.8 4.6 1.5 versicolor #&gt; 57 6.3 3.3 4.7 1.6 versicolor .... # 在列的子集内 先选中列 subset(iris, Sepal.Length &gt; mean(Sepal.Length), select = c(&quot;Sepal.Length&quot;, &quot;Species&quot;) ) #&gt; Sepal.Length Species #&gt; 51 7.0 versicolor #&gt; 52 6.4 versicolor #&gt; 53 6.9 versicolor #&gt; 55 6.5 versicolor #&gt; 57 6.3 versicolor .... 高级操作：加入正则表达式筛选 ## sometimes requiring a logical &#39;subset&#39; argument is a nuisance nm &lt;- rownames(state.x77) start_with_M &lt;- nm %in% grep(&quot;^M&quot;, nm, value = TRUE) subset(state.x77, start_with_M, Illiteracy:Murder) #&gt; Illiteracy Life Exp Murder #&gt; Maine 0.7 70.39 2.7 #&gt; Maryland 0.9 70.22 8.5 #&gt; Massachusetts 1.1 71.83 3.3 #&gt; Michigan 0.9 70.63 11.1 #&gt; Minnesota 0.6 72.96 2.3 #&gt; Mississippi 2.4 68.09 12.5 #&gt; Missouri 0.8 70.69 9.3 #&gt; Montana 0.6 70.56 5.0 # 简化 subset(state.x77, subset = grepl(&quot;^M&quot;, rownames(state.x77)), select = Illiteracy:Murder) #&gt; Illiteracy Life Exp Murder #&gt; Maine 0.7 70.39 2.7 #&gt; Maryland 0.9 70.22 8.5 #&gt; Massachusetts 1.1 71.83 3.3 #&gt; Michigan 0.9 70.63 11.1 #&gt; Minnesota 0.6 72.96 2.3 #&gt; Mississippi 2.4 68.09 12.5 #&gt; Missouri 0.8 70.69 9.3 #&gt; Montana 0.6 70.56 5.0 # 继续简化 subset(state.x77, grepl(&quot;^M&quot;, rownames(state.x77)), Illiteracy:Murder) #&gt; Illiteracy Life Exp Murder #&gt; Maine 0.7 70.39 2.7 #&gt; Maryland 0.9 70.22 8.5 #&gt; Massachusetts 1.1 71.83 3.3 #&gt; Michigan 0.9 70.63 11.1 #&gt; Minnesota 0.6 72.96 2.3 #&gt; Mississippi 2.4 68.09 12.5 #&gt; Missouri 0.8 70.69 9.3 #&gt; Montana 0.6 70.56 5.0 警告：这是一个为了交互使用打造的便捷函数。对于编程，最好使用标准的子集函数，如 [，特别地，参数 subset 的非标准计算(non-standard evaluation)22 可能带来意想不到的后果。 使用索引 [ iris[iris$Species == &quot;virginica&quot;, ] #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 101 6.3 3.3 6.0 2.5 virginica #&gt; 102 5.8 2.7 5.1 1.9 virginica #&gt; 103 7.1 3.0 5.9 2.1 virginica #&gt; 104 6.3 2.9 5.6 1.8 virginica #&gt; 105 6.5 3.0 5.8 2.2 virginica .... iris[iris$Species == &quot;virginica&quot; &amp; iris$Sepal.Length &gt; mean(iris$Sepal.Length), ] #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 101 6.3 3.3 6.0 2.5 virginica #&gt; 103 7.1 3.0 5.9 2.1 virginica #&gt; 104 6.3 2.9 5.6 1.8 virginica #&gt; 105 6.5 3.0 5.8 2.2 virginica #&gt; 106 7.6 3.0 6.6 2.1 virginica .... iris[ iris$Species == &quot;virginica&quot; &amp; iris$Sepal.Length &gt; mean(iris$Sepal.Length), c(&quot;Sepal.Length&quot;, &quot;Species&quot;) ] #&gt; Sepal.Length Species #&gt; 101 6.3 virginica #&gt; 103 7.1 virginica #&gt; 104 6.3 virginica #&gt; 105 6.5 virginica #&gt; 106 7.6 virginica .... 5.5 按列排序 在数据框内，根据(order)某一列或几列对行进行排序(sort)，根据鸢尾花(iris)的类别(Species)对萼片(sepal)的长度进行排序，其余的列随之变化 # 对萼片的长度排序 iris[order(iris$Species, iris$Sepal.Length), ] #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 14 4.3 3.0 1.1 0.1 setosa #&gt; 9 4.4 2.9 1.4 0.2 setosa #&gt; 39 4.4 3.0 1.3 0.2 setosa #&gt; 43 4.4 3.2 1.3 0.2 setosa #&gt; 42 4.5 2.3 1.3 0.3 setosa .... # 对花瓣的长度排序 iris[order(iris$Species, iris$Petal.Length), ] #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 23 4.6 3.6 1.0 0.2 setosa #&gt; 14 4.3 3.0 1.1 0.1 setosa #&gt; 15 5.8 4.0 1.2 0.2 setosa #&gt; 36 5.0 3.2 1.2 0.2 setosa #&gt; 3 4.7 3.2 1.3 0.2 setosa .... # 先对花瓣的宽度排序，再对花瓣的长度排序 iris[order(iris$Petal.Width, iris$Petal.Length), ] #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 14 4.3 3.0 1.1 0.1 setosa #&gt; 13 4.8 3.0 1.4 0.1 setosa #&gt; 38 4.9 3.6 1.4 0.1 setosa #&gt; 10 4.9 3.1 1.5 0.1 setosa #&gt; 33 5.2 4.1 1.5 0.1 setosa .... sort/ordered 排序， 默认是升序 dd &lt;- data.frame( b = factor(c(&quot;Hi&quot;, &quot;Med&quot;, &quot;Hi&quot;, &quot;Low&quot;), levels = c(&quot;Low&quot;, &quot;Med&quot;, &quot;Hi&quot;), ordered = TRUE ), x = c(&quot;A&quot;, &quot;D&quot;, &quot;A&quot;, &quot;C&quot;), y = c(8, 3, 9, 9), z = c(1, 1, 1, 2) ) str(dd) #&gt; &#39;data.frame&#39;: 4 obs. of 4 variables: #&gt; $ b: Ord.factor w/ 3 levels &quot;Low&quot;&lt;&quot;Med&quot;&lt;&quot;Hi&quot;: 3 2 3 1 #&gt; $ x: chr &quot;A&quot; &quot;D&quot; &quot;A&quot; &quot;C&quot; #&gt; $ y: num 8 3 9 9 #&gt; $ z: num 1 1 1 2 dd[order(-dd[,4], dd[,1]), ] #&gt; b x y z #&gt; 4 Low C 9 2 #&gt; 2 Med D 3 1 #&gt; 1 Hi A 8 1 #&gt; 3 Hi A 9 1 根据变量 z dd[order(dd$z, dd$b), ] #&gt; b x y z #&gt; 2 Med D 3 1 #&gt; 1 Hi A 8 1 #&gt; 3 Hi A 9 1 #&gt; 4 Low C 9 2 5.6 数据拆分 数据拆分通常是按找某一个分类变量分组，分完组就是计算，计算完就把结果按照原来的分组方式合并 ## Notice that assignment form is not used since a variable is being added g &lt;- airquality$Month l &lt;- split(airquality, g) # 分组 l &lt;- lapply(l, transform, Oz.Z = scale(Ozone)) # 计算：按月对 Ozone 标准化 aq2 &lt;- unsplit(l, g) # 合并 head(aq2) #&gt; Ozone Solar.R Wind Temp Month Day Oz.Z #&gt; 1 41 190 7.4 67 5 1 0.7822293 #&gt; 2 36 118 8.0 72 5 2 0.5572518 #&gt; 3 12 149 12.6 74 5 3 -0.5226399 #&gt; 4 18 313 11.5 62 5 4 -0.2526670 #&gt; 5 NA NA 14.3 56 5 5 NA #&gt; 6 28 NA 14.9 66 5 6 0.1972879 tapply 自带分组的功能，按月份 Month 对 Ozone 中心标准化，其返回一个列表 with(airquality, tapply(Ozone, Month, scale)) #&gt; $`5` #&gt; [,1] #&gt; [1,] 0.78222929 #&gt; [2,] 0.55725184 #&gt; [3,] -0.52263993 #&gt; [4,] -0.25266698 #&gt; [5,] NA #&gt; [6,] 0.19728792 #&gt; [7,] -0.02768953 #&gt; [8,] -0.20767149 .... 上面的过程等价于 do.call(&quot;rbind&quot;, lapply(split(airquality, airquality$Month), transform, Oz.Z = scale(Ozone))) #&gt; Ozone Solar.R Wind Temp Month Day Oz.Z #&gt; 5.1 41 190 7.4 67 5 1 0.782229293 #&gt; 5.2 36 118 8.0 72 5 2 0.557251841 #&gt; 5.3 12 149 12.6 74 5 3 -0.522639926 #&gt; 5.4 18 313 11.5 62 5 4 -0.252666984 #&gt; 5.5 NA NA 14.3 56 5 5 NA #&gt; 5.6 28 NA 14.9 66 5 6 0.197287919 #&gt; 5.7 23 299 8.6 65 5 7 -0.027689532 #&gt; 5.8 19 99 13.8 59 5 8 -0.207671494 #&gt; 5.9 8 19 20.1 61 5 9 -0.702621887 .... 由于上面对 Ozone 正态标准化，所以标准化后的 Oz.z 再按月分组计算方差自然每个月都是 1，而均值都是 0。 with(aq2, tapply(Oz.Z, Month, sd, na.rm = TRUE)) #&gt; 5 6 7 8 9 #&gt; 1 1 1 1 1 with(aq2, tapply(Oz.Z, Month, mean, na.rm = TRUE)) #&gt; 5 6 7 8 9 #&gt; -4.240273e-17 1.052760e-16 5.841432e-17 5.898060e-17 2.571709e-17 循着这个思路，我们可以用 tapply 实现分组计算，上面函数 sd 和 mean 完全可以用自定义的更加复杂的函数替代 cut 函数可以将连续型变量划分为分类变量 set.seed(2019) Z &lt;- stats::rnorm(10) cut(Z, breaks = -6:6) #&gt; [1] (0,1] (-1,0] (-2,-1] (0,1] (-2,-1] (0,1] (-1,0] (0,1] (-2,-1] #&gt; [10] (-1,0] #&gt; 12 Levels: (-6,-5] (-5,-4] (-4,-3] (-3,-2] (-2,-1] (-1,0] (0,1] ... (5,6] # labels = FALSE 返回每个数所落的区间位置 cut(Z, breaks = -6:6, labels = FALSE) #&gt; [1] 7 6 5 7 5 7 6 7 5 6 我们还可以指定参数 dig.lab 设置分组的精度，ordered 将分组变量看作是有序的，breaks 传递单个数时，表示分组数，而不是断点 cut(Z, breaks = 3, dig.lab = 4, ordered = TRUE) #&gt; [1] (0.06396,0.9186] (-0.7881,0.06396] (-1.643,-0.7881] (0.06396,0.9186] #&gt; [5] (-1.643,-0.7881] (0.06396,0.9186] (-0.7881,0.06396] (0.06396,0.9186] #&gt; [9] (-1.643,-0.7881] (-0.7881,0.06396] #&gt; Levels: (-1.643,-0.7881] &lt; (-0.7881,0.06396] &lt; (0.06396,0.9186] 此时，统计每组的频数，如图 5.1 # 条形图 plot(cut(Z, breaks = -6:6)) # 直方图 hist(Z, breaks = -6:6) 图 5.1: 连续型变量分组统计 在指定分组数的情况下，我们还想获取分组的断点 labs &lt;- levels(cut(Z, 3)) labs #&gt; [1] &quot;(-1.64,-0.788]&quot; &quot;(-0.788,0.064]&quot; &quot;(0.064,0.919]&quot; 用正则表达式抽取断点 cbind( lower = as.numeric(sub(&quot;\\\\((.+),.*&quot;, &quot;\\\\1&quot;, labs)), upper = as.numeric(sub(&quot;[^,]*,([^]]*)\\\\]&quot;, &quot;\\\\1&quot;, labs)) ) #&gt; lower upper #&gt; [1,] -1.640 -0.788 #&gt; [2,] -0.788 0.064 #&gt; [3,] 0.064 0.919 更多相关函数可以参考 findInterval 和 embed tabulate 和 table 有所不同，它表示排列 t(combn(8, 4, tabulate, nbins = 8)) #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #&gt; [1,] 1 1 1 1 0 0 0 0 #&gt; [2,] 1 1 1 0 1 0 0 0 #&gt; [3,] 1 1 1 0 0 1 0 0 #&gt; [4,] 1 1 1 0 0 0 1 0 #&gt; [5,] 1 1 1 0 0 0 0 1 .... 5.7 数据合并 merge 合并两个数据框 authors &lt;- data.frame( ## I(*) : use character columns of names to get sensible sort order surname = I(c(&quot;Tukey&quot;, &quot;Venables&quot;, &quot;Tierney&quot;, &quot;Ripley&quot;, &quot;McNeil&quot;)), nationality = c(&quot;US&quot;, &quot;Australia&quot;, &quot;US&quot;, &quot;UK&quot;, &quot;Australia&quot;), deceased = c(&quot;yes&quot;, rep(&quot;no&quot;, 4)) ) authorN &lt;- within(authors, { name &lt;- surname rm(surname) }) books &lt;- data.frame( name = I(c( &quot;Tukey&quot;, &quot;Venables&quot;, &quot;Tierney&quot;, &quot;Ripley&quot;, &quot;Ripley&quot;, &quot;McNeil&quot;, &quot;R Core&quot; )), title = c( &quot;Exploratory Data Analysis&quot;, &quot;Modern Applied Statistics ...&quot;, &quot;LISP-STAT&quot;, &quot;Spatial Statistics&quot;, &quot;Stochastic Simulation&quot;, &quot;Interactive Data Analysis&quot;, &quot;An Introduction to R&quot; ), other.author = c( NA, &quot;Ripley&quot;, NA, NA, NA, NA, &quot;Venables &amp; Smith&quot; ) ) authors #&gt; surname nationality deceased #&gt; 1 Tukey US yes #&gt; 2 Venables Australia no #&gt; 3 Tierney US no #&gt; 4 Ripley UK no #&gt; 5 McNeil Australia no authorN #&gt; nationality deceased name #&gt; 1 US yes Tukey #&gt; 2 Australia no Venables #&gt; 3 US no Tierney #&gt; 4 UK no Ripley #&gt; 5 Australia no McNeil books #&gt; name title other.author #&gt; 1 Tukey Exploratory Data Analysis &lt;NA&gt; #&gt; 2 Venables Modern Applied Statistics ... Ripley #&gt; 3 Tierney LISP-STAT &lt;NA&gt; #&gt; 4 Ripley Spatial Statistics &lt;NA&gt; #&gt; 5 Ripley Stochastic Simulation &lt;NA&gt; #&gt; 6 McNeil Interactive Data Analysis &lt;NA&gt; #&gt; 7 R Core An Introduction to R Venables &amp; Smith 默认找到同名的列，然后是同名的行合并，多余的没有匹配到的就丢掉 merge(authorN, books) #&gt; name nationality deceased title other.author #&gt; 1 McNeil Australia no Interactive Data Analysis &lt;NA&gt; #&gt; 2 Ripley UK no Spatial Statistics &lt;NA&gt; #&gt; 3 Ripley UK no Stochastic Simulation &lt;NA&gt; #&gt; 4 Tierney US no LISP-STAT &lt;NA&gt; #&gt; 5 Tukey US yes Exploratory Data Analysis &lt;NA&gt; #&gt; 6 Venables Australia no Modern Applied Statistics ... Ripley 还可以指定合并的列，先按照 surname 合并，留下 surname merge(authors, books, by.x = &quot;surname&quot;, by.y = &quot;name&quot;) #&gt; surname nationality deceased title other.author #&gt; 1 McNeil Australia no Interactive Data Analysis &lt;NA&gt; #&gt; 2 Ripley UK no Spatial Statistics &lt;NA&gt; #&gt; 3 Ripley UK no Stochastic Simulation &lt;NA&gt; #&gt; 4 Tierney US no LISP-STAT &lt;NA&gt; #&gt; 5 Tukey US yes Exploratory Data Analysis &lt;NA&gt; #&gt; 6 Venables Australia no Modern Applied Statistics ... Ripley 留下的是 name merge(books, authors, by.x = &quot;name&quot;, by.y = &quot;surname&quot;) #&gt; name title other.author nationality deceased #&gt; 1 McNeil Interactive Data Analysis &lt;NA&gt; Australia no #&gt; 2 Ripley Spatial Statistics &lt;NA&gt; UK no #&gt; 3 Ripley Stochastic Simulation &lt;NA&gt; UK no #&gt; 4 Tierney LISP-STAT &lt;NA&gt; US no #&gt; 5 Tukey Exploratory Data Analysis &lt;NA&gt; US yes #&gt; 6 Venables Modern Applied Statistics ... Ripley Australia no 为了比较清楚地观察几种合并的区别，这里提供对应的动画展示 https://github.com/gadenbuie/tidyexplain (inner, outer, left, right, cross) join 共5种合并方式详情请看 https://stackoverflow.com/questions/1299871 cbind 和 rbind 分别是按列和行合并数据框 5.8 数据去重 单个数值型向量去重，此时和 unique 函数作用一样 (x &lt;- c(9:20, 1:5, 3:7, 0:8)) #&gt; [1] 9 10 11 12 13 14 15 16 17 18 19 20 1 2 3 4 5 3 4 5 6 7 0 1 2 #&gt; [26] 3 4 5 6 7 8 ## extract unique elements x[!duplicated(x)] #&gt; [1] 9 10 11 12 13 14 15 16 17 18 19 20 1 2 3 4 5 6 7 0 8 unique(x) #&gt; [1] 9 10 11 12 13 14 15 16 17 18 19 20 1 2 3 4 5 6 7 0 8 数据框类型数据中，去除重复的行，这个重复可以是多个变量对应的向量 set.seed(123) df &lt;- data.frame( x = sample(0:1, 10, replace = T), y = sample(0:1, 10, replace = T), z = 1:10 ) df #&gt; x y z #&gt; 1 0 1 1 #&gt; 2 0 1 2 #&gt; 3 0 1 3 #&gt; 4 1 0 4 #&gt; 5 0 1 5 #&gt; 6 1 0 6 #&gt; 7 1 1 7 #&gt; 8 1 0 8 #&gt; 9 0 0 9 #&gt; 10 0 0 10 df[!duplicated(df[, 1:2]), ] #&gt; x y z #&gt; 1 0 1 1 #&gt; 4 1 0 4 #&gt; 7 1 1 7 #&gt; 9 0 0 9 5.9 数据缺失 缺失数据操作 data(&quot;airquality&quot;) head(airquality) #&gt; Ozone Solar.R Wind Temp Month Day #&gt; 1 41 190 7.4 67 5 1 #&gt; 2 36 118 8.0 72 5 2 #&gt; 3 12 149 12.6 74 5 3 #&gt; 4 18 313 11.5 62 5 4 #&gt; 5 NA NA 14.3 56 5 5 #&gt; 6 28 NA 14.9 66 5 6 对缺失值的处理默认是 na.action = na.omit # Ozone 最高的那天 aggregate(data = airquality, Ozone ~ Month, max) #&gt; Month Ozone #&gt; 1 5 115 #&gt; 2 6 71 #&gt; 3 7 135 #&gt; 4 8 168 #&gt; 5 9 96 # 每月 Ozone, Solar.R, Wind, Temp 平均值 aggregate(data = airquality, Ozone ~ Month, mean) #&gt; Month Ozone #&gt; 1 5 23.61538 #&gt; 2 6 29.44444 #&gt; 3 7 59.11538 #&gt; 4 8 59.96154 #&gt; 5 9 31.44828 缺失值处理 library(DataExplorer) plot_missing(airquality) 查看包含缺失的记录，不完整的记录 airquality[!complete.cases(airquality), ] #&gt; Ozone Solar.R Wind Temp Month Day #&gt; 5 NA NA 14.3 56 5 5 #&gt; 6 28 NA 14.9 66 5 6 #&gt; 10 NA 194 8.6 69 5 10 #&gt; 11 7 NA 6.9 74 5 11 #&gt; 25 NA 66 16.6 57 5 25 #&gt; 26 NA 266 14.9 58 5 26 #&gt; 27 NA NA 8.0 57 5 27 #&gt; 32 NA 286 8.6 78 6 1 #&gt; 33 NA 287 9.7 74 6 2 #&gt; 34 NA 242 16.1 67 6 3 #&gt; 35 NA 186 9.2 84 6 4 #&gt; 36 NA 220 8.6 85 6 5 #&gt; 37 NA 264 14.3 79 6 6 #&gt; 39 NA 273 6.9 87 6 8 #&gt; 42 NA 259 10.9 93 6 11 #&gt; 43 NA 250 9.2 92 6 12 #&gt; 45 NA 332 13.8 80 6 14 #&gt; 46 NA 322 11.5 79 6 15 #&gt; 52 NA 150 6.3 77 6 21 #&gt; 53 NA 59 1.7 76 6 22 #&gt; 54 NA 91 4.6 76 6 23 #&gt; 55 NA 250 6.3 76 6 24 #&gt; 56 NA 135 8.0 75 6 25 #&gt; 57 NA 127 8.0 78 6 26 #&gt; 58 NA 47 10.3 73 6 27 #&gt; 59 NA 98 11.5 80 6 28 #&gt; 60 NA 31 14.9 77 6 29 #&gt; 61 NA 138 8.0 83 6 30 #&gt; 65 NA 101 10.9 84 7 4 #&gt; 72 NA 139 8.6 82 7 11 #&gt; 75 NA 291 14.9 91 7 14 #&gt; 83 NA 258 9.7 81 7 22 #&gt; 84 NA 295 11.5 82 7 23 #&gt; 96 78 NA 6.9 86 8 4 #&gt; 97 35 NA 7.4 85 8 5 #&gt; 98 66 NA 4.6 87 8 6 #&gt; 102 NA 222 8.6 92 8 10 #&gt; 103 NA 137 11.5 86 8 11 #&gt; 107 NA 64 11.5 79 8 15 #&gt; 115 NA 255 12.6 75 8 23 #&gt; 119 NA 153 5.7 88 8 27 #&gt; 150 NA 145 13.2 77 9 27 Ozone 和 Solar.R 同时包含缺失值的行 airquality[is.na(airquality$Ozone) &amp; is.na(airquality$Solar.R), ] #&gt; Ozone Solar.R Wind Temp Month Day #&gt; 5 NA NA 14.3 56 5 5 #&gt; 27 NA NA 8.0 57 5 27 5.10 数据聚合 分组求和 https://stackoverflow.com/questions/1660124 主要是分组统计 apropos(&quot;apply&quot;) #&gt; [1] &quot;apply&quot; &quot;dendrapply&quot; &quot;eapply&quot; &quot;kernapply&quot; &quot;lapply&quot; #&gt; [6] &quot;mapply&quot; &quot;rapply&quot; &quot;sapply&quot; &quot;tapply&quot; &quot;vapply&quot; # 分组求和 colSums colMeans max unique(iris$Species) #&gt; [1] setosa versicolor virginica #&gt; Levels: setosa versicolor virginica # 分类求和 # colSums(iris[iris$Species == &quot;setosa&quot;, -5]) # colSums(iris[iris$Species == &quot;virginica&quot;, -5]) colSums(iris[iris$Species == &quot;versicolor&quot;, -5]) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; 296.8 138.5 213.0 66.3 # apply(iris[iris$Species == &quot;setosa&quot;, -5], 2, sum) # apply(iris[iris$Species == &quot;setosa&quot;, -5], 2, mean) # apply(iris[iris$Species == &quot;setosa&quot;, -5], 2, min) # apply(iris[iris$Species == &quot;setosa&quot;, -5], 2, max) apply(iris[iris$Species == &quot;setosa&quot;, -5], 2, quantile) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; 0% 4.3 2.300 1.000 0.1 #&gt; 25% 4.8 3.200 1.400 0.2 #&gt; 50% 5.0 3.400 1.500 0.2 #&gt; 75% 5.2 3.675 1.575 0.3 #&gt; 100% 5.8 4.400 1.900 0.6 aggregate: Compute Summary Statistics of Data Subsets # 按分类变量 Species 分组求和 # aggregate(subset(iris, select = -Species), by = list(iris[, &quot;Species&quot;]), FUN = sum) aggregate(iris[, -5], list(iris[, 5]), sum) #&gt; Group.1 Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; 1 setosa 250.3 171.4 73.1 12.3 #&gt; 2 versicolor 296.8 138.5 213.0 66.3 #&gt; 3 virginica 329.4 148.7 277.6 101.3 # 先确定位置，假设有很多分类变量 ind &lt;- which(&quot;Species&quot; == colnames(iris)) # 分组统计 aggregate(iris[, -ind], list(iris[, ind]), sum) #&gt; Group.1 Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; 1 setosa 250.3 171.4 73.1 12.3 #&gt; 2 versicolor 296.8 138.5 213.0 66.3 #&gt; 3 virginica 329.4 148.7 277.6 101.3 按照 Species 划分的类别，分组计算，使用公式表示形式，右边一定是分类变量，否则会报错误或者警告，输出奇怪的结果，请读者尝试运行aggregate(Species ~ Sepal.Length, data = iris, mean)。公式法表示分组计算，~ 左手边可以做加 + 减 - 乘 * 除 / 取余 %% 等数学运算。下面以数据集 iris 为例，只对 Sepal.Length 按 Species 分组计算 aggregate(Sepal.Length ~ Species, data = iris, mean) #&gt; Species Sepal.Length #&gt; 1 setosa 5.006 #&gt; 2 versicolor 5.936 #&gt; 3 virginica 6.588 与上述分组统计结果一样的命令，在大数据集上， 与 aggregate 相比，tapply 要快很多，by 是 tapply 的包裹，处理速度差不多。读者可以构造伪随机数据集验证。 # tapply(iris$Sepal.Length, list(iris$Species), mean) with(iris, tapply(Sepal.Length, Species, mean)) #&gt; setosa versicolor virginica #&gt; 5.006 5.936 6.588 by(iris$Sepal.Length, iris$Species, mean) #&gt; iris$Species: setosa #&gt; [1] 5.006 #&gt; ----------------------------------------------------------- #&gt; iris$Species: versicolor #&gt; [1] 5.936 #&gt; ----------------------------------------------------------- #&gt; iris$Species: virginica #&gt; [1] 6.588 对所有变量按 Species 分组计算 aggregate(. ~ Species, data = iris, mean) #&gt; Species Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; 1 setosa 5.006 3.428 1.462 0.246 #&gt; 2 versicolor 5.936 2.770 4.260 1.326 #&gt; 3 virginica 6.588 2.974 5.552 2.026 对变量 Sepal.Length 和 Sepal.Width 求和后，按 Species 分组计算 aggregate(Sepal.Length + Sepal.Width ~ Species, data = iris, mean) #&gt; Species Sepal.Length + Sepal.Width #&gt; 1 setosa 8.434 #&gt; 2 versicolor 8.706 #&gt; 3 virginica 9.562 对多个分类变量做分组计算，在数据集 ChickWeight 中 Chick和Diet都是数字编码的分类变量，其中 Chick 是有序的因子变量，Diet 是无序的因子变量，而 Time 是数值型的变量，表示小鸡出生的天数。 # 查看数据 str(ChickWeight) #&gt; Classes &#39;nfnGroupedData&#39;, &#39;nfGroupedData&#39;, &#39;groupedData&#39; and &#39;data.frame&#39;: 578 obs. of 4 variables: #&gt; $ weight: num 42 51 59 64 76 93 106 125 149 171 ... #&gt; $ Time : num 0 2 4 6 8 10 12 14 16 18 ... #&gt; $ Chick : Ord.factor w/ 50 levels &quot;18&quot;&lt;&quot;16&quot;&lt;&quot;15&quot;&lt;..: 15 15 15 15 15 15 15 15.. #&gt; $ Diet : Factor w/ 4 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;: 1 1 1 1 1 1 1 1 1 1 ... #&gt; - attr(*, &quot;formula&quot;)=Class &#39;formula&#39; language weight ~ Time | Chick #&gt; .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_EmptyEnv&gt; #&gt; - attr(*, &quot;outer&quot;)=Class &#39;formula&#39; language ~Diet #&gt; .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_EmptyEnv&gt; #&gt; - attr(*, &quot;labels&quot;)=List of 2 #&gt; ..$ x: chr &quot;Time&quot; #&gt; ..$ y: chr &quot;Body weight&quot; #&gt; - attr(*, &quot;units&quot;)=List of 2 #&gt; ..$ x: chr &quot;(days)&quot; #&gt; ..$ y: chr &quot;(gm)&quot; 查看数据集ChickWeight的前几行 head(ChickWeight) #&gt; weight Time Chick Diet #&gt; 1 42 0 1 1 #&gt; 2 51 2 1 1 #&gt; 3 59 4 1 1 #&gt; 4 64 6 1 1 #&gt; 5 76 8 1 1 .... str(ChickWeight) #&gt; Classes &#39;nfnGroupedData&#39;, &#39;nfGroupedData&#39;, &#39;groupedData&#39; and &#39;data.frame&#39;: 578 obs. of 4 variables: #&gt; $ weight: num 42 51 59 64 76 93 106 125 149 171 ... #&gt; $ Time : num 0 2 4 6 8 10 12 14 16 18 ... #&gt; $ Chick : Ord.factor w/ 50 levels &quot;18&quot;&lt;&quot;16&quot;&lt;&quot;15&quot;&lt;..: 15 15 15 15 15 15 15 15.. #&gt; $ Diet : Factor w/ 4 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;: 1 1 1 1 1 1 1 1 1 1 ... #&gt; - attr(*, &quot;formula&quot;)=Class &#39;formula&#39; language weight ~ Time | Chick .... 对于数据集ChickWeight中的有序变量Chick，aggregate 会按照既定顺序返回分组计算的结果 aggregate(weight ~ Chick, data = ChickWeight, mean) #&gt; Chick weight #&gt; 1 18 37.00000 #&gt; 2 16 49.71429 #&gt; 3 15 60.12500 #&gt; 4 13 67.83333 #&gt; 5 9 81.16667 .... aggregate(weight ~ Diet, data = ChickWeight, mean) #&gt; Diet weight #&gt; 1 1 102.6455 #&gt; 2 2 122.6167 #&gt; 3 3 142.9500 #&gt; 4 4 135.2627 分类变量没有用数字编码，以 CO2 数据集为例，该数据集描述草植对二氧化碳的吸收情况，Plant 是具有12个水平的有序的因子变量，Type表示植物的源头分别是魁北克(Quebec)和密西西比(Mississippi)，Treatment表示冷却(chilled)和不冷却(nonchilled)两种处理方式，conc表示周围环境中二氧化碳的浓度，uptake表示植物吸收二氧化碳的速率。 # 查看数据集 head(CO2) #&gt; Plant Type Treatment conc uptake #&gt; 1 Qn1 Quebec nonchilled 95 16.0 #&gt; 2 Qn1 Quebec nonchilled 175 30.4 #&gt; 3 Qn1 Quebec nonchilled 250 34.8 #&gt; 4 Qn1 Quebec nonchilled 350 37.2 #&gt; 5 Qn1 Quebec nonchilled 500 35.3 #&gt; 6 Qn1 Quebec nonchilled 675 39.2 str(CO2) #&gt; Classes &#39;nfnGroupedData&#39;, &#39;nfGroupedData&#39;, &#39;groupedData&#39; and &#39;data.frame&#39;: 84 obs. of 5 variables: #&gt; $ Plant : Ord.factor w/ 12 levels &quot;Qn1&quot;&lt;&quot;Qn2&quot;&lt;&quot;Qn3&quot;&lt;..: 1 1 1 1 1 1 1 2 2.. #&gt; $ Type : Factor w/ 2 levels &quot;Quebec&quot;,&quot;Mississippi&quot;: 1 1 1 1 1 1 1 1 1 1 .. #&gt; $ Treatment: Factor w/ 2 levels &quot;nonchilled&quot;,&quot;chilled&quot;: 1 1 1 1 1 1 1 1 1 1 .. #&gt; $ conc : num 95 175 250 350 500 675 1000 95 175 250 ... #&gt; $ uptake : num 16 30.4 34.8 37.2 35.3 39.2 39.7 13.6 27.3 37.1 ... #&gt; - attr(*, &quot;formula&quot;)=Class &#39;formula&#39; language uptake ~ conc | Plant #&gt; .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_EmptyEnv&gt; #&gt; - attr(*, &quot;outer&quot;)=Class &#39;formula&#39; language ~Treatment * Type #&gt; .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_EmptyEnv&gt; #&gt; - attr(*, &quot;labels&quot;)=List of 2 #&gt; ..$ x: chr &quot;Ambient carbon dioxide concentration&quot; #&gt; ..$ y: chr &quot;CO2 uptake rate&quot; #&gt; - attr(*, &quot;units&quot;)=List of 2 #&gt; ..$ x: chr &quot;(uL/L)&quot; #&gt; ..$ y: chr &quot;(umol/m^2 s)&quot; 对单个变量分组统计 aggregate(uptake ~ Plant, data = CO2, mean) #&gt; Plant uptake #&gt; 1 Qn1 33.22857 #&gt; 2 Qn2 35.15714 #&gt; 3 Qn3 37.61429 #&gt; 4 Qc1 29.97143 #&gt; 5 Qc3 32.58571 #&gt; 6 Qc2 32.70000 #&gt; 7 Mn3 24.11429 #&gt; 8 Mn2 27.34286 #&gt; 9 Mn1 26.40000 #&gt; 10 Mc2 12.14286 #&gt; 11 Mc3 17.30000 #&gt; 12 Mc1 18.00000 aggregate(uptake ~ Type, data = CO2, mean) #&gt; Type uptake #&gt; 1 Quebec 33.54286 #&gt; 2 Mississippi 20.88333 aggregate(uptake ~ Treatment, data = CO2, mean) #&gt; Treatment uptake #&gt; 1 nonchilled 30.64286 #&gt; 2 chilled 23.78333 对多个变量分组统计，查看二氧化碳吸收速率uptake随类型Type和处理方式Treatment aggregate(uptake ~ Type + Treatment, data = CO2, mean) #&gt; Type Treatment uptake #&gt; 1 Quebec nonchilled 35.33333 #&gt; 2 Mississippi nonchilled 25.95238 #&gt; 3 Quebec chilled 31.75238 #&gt; 4 Mississippi chilled 15.81429 tapply(CO2$uptake, list(CO2$Type, CO2$Treatment), mean) #&gt; nonchilled chilled #&gt; Quebec 35.33333 31.75238 #&gt; Mississippi 25.95238 15.81429 by(CO2$uptake, list(CO2$Type, CO2$Treatment), mean) #&gt; : Quebec #&gt; : nonchilled #&gt; [1] 35.33333 #&gt; ----------------------------------------------------------- #&gt; : Mississippi #&gt; : nonchilled #&gt; [1] 25.95238 #&gt; ----------------------------------------------------------- #&gt; : Quebec #&gt; : chilled #&gt; [1] 31.75238 #&gt; ----------------------------------------------------------- #&gt; : Mississippi #&gt; : chilled #&gt; [1] 15.81429 在这个例子中 tapply 和 by 的输出结果的表示形式不一样，aggregate 返回一个 data.frame 数据框，tapply 返回一个表格 table，by 返回特殊的数据类型 by。 Function by is an object-oriented wrapper for tapply applied to data frames. # 分组求和 # by(iris[, 1], INDICES = list(iris$Species), FUN = sum) # by(iris[, 2], INDICES = list(iris$Species), FUN = sum) by(iris[, 3], INDICES = list(iris$Species), FUN = sum) #&gt; : setosa #&gt; [1] 73.1 #&gt; ----------------------------------------------------------- #&gt; : versicolor #&gt; [1] 213 #&gt; ----------------------------------------------------------- #&gt; : virginica #&gt; [1] 277.6 by(iris[1:3], INDICES = list(iris$Species), FUN = sum) #&gt; : setosa #&gt; [1] 494.8 #&gt; ----------------------------------------------------------- #&gt; : versicolor #&gt; [1] 648.3 #&gt; ----------------------------------------------------------- #&gt; : virginica #&gt; [1] 755.7 by(iris[1:3], INDICES = list(iris$Species), FUN = summary) #&gt; : setosa #&gt; Sepal.Length Sepal.Width Petal.Length #&gt; Min. :4.300 Min. :2.300 Min. :1.000 #&gt; 1st Qu.:4.800 1st Qu.:3.200 1st Qu.:1.400 #&gt; Median :5.000 Median :3.400 Median :1.500 #&gt; Mean :5.006 Mean :3.428 Mean :1.462 #&gt; 3rd Qu.:5.200 3rd Qu.:3.675 3rd Qu.:1.575 #&gt; Max. :5.800 Max. :4.400 Max. :1.900 #&gt; ----------------------------------------------------------- #&gt; : versicolor #&gt; Sepal.Length Sepal.Width Petal.Length #&gt; Min. :4.900 Min. :2.000 Min. :3.00 #&gt; 1st Qu.:5.600 1st Qu.:2.525 1st Qu.:4.00 #&gt; Median :5.900 Median :2.800 Median :4.35 #&gt; Mean :5.936 Mean :2.770 Mean :4.26 #&gt; 3rd Qu.:6.300 3rd Qu.:3.000 3rd Qu.:4.60 #&gt; Max. :7.000 Max. :3.400 Max. :5.10 #&gt; ----------------------------------------------------------- #&gt; : virginica #&gt; Sepal.Length Sepal.Width Petal.Length #&gt; Min. :4.900 Min. :2.200 Min. :4.500 #&gt; 1st Qu.:6.225 1st Qu.:2.800 1st Qu.:5.100 #&gt; Median :6.500 Median :3.000 Median :5.550 #&gt; Mean :6.588 Mean :2.974 Mean :5.552 #&gt; 3rd Qu.:6.900 3rd Qu.:3.175 3rd Qu.:5.875 #&gt; Max. :7.900 Max. :3.800 Max. :6.900 by(iris, INDICES = list(iris$Species), FUN = summary) #&gt; : setosa #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; Min. :4.300 Min. :2.300 Min. :1.000 Min. :0.100 #&gt; 1st Qu.:4.800 1st Qu.:3.200 1st Qu.:1.400 1st Qu.:0.200 #&gt; Median :5.000 Median :3.400 Median :1.500 Median :0.200 #&gt; Mean :5.006 Mean :3.428 Mean :1.462 Mean :0.246 #&gt; 3rd Qu.:5.200 3rd Qu.:3.675 3rd Qu.:1.575 3rd Qu.:0.300 #&gt; Max. :5.800 Max. :4.400 Max. :1.900 Max. :0.600 #&gt; Species #&gt; setosa :50 #&gt; versicolor: 0 #&gt; virginica : 0 #&gt; #&gt; #&gt; #&gt; ----------------------------------------------------------- #&gt; : versicolor #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; Min. :4.900 Min. :2.000 Min. :3.00 Min. :1.000 #&gt; 1st Qu.:5.600 1st Qu.:2.525 1st Qu.:4.00 1st Qu.:1.200 #&gt; Median :5.900 Median :2.800 Median :4.35 Median :1.300 #&gt; Mean :5.936 Mean :2.770 Mean :4.26 Mean :1.326 #&gt; 3rd Qu.:6.300 3rd Qu.:3.000 3rd Qu.:4.60 3rd Qu.:1.500 #&gt; Max. :7.000 Max. :3.400 Max. :5.10 Max. :1.800 #&gt; Species #&gt; setosa : 0 #&gt; versicolor:50 #&gt; virginica : 0 #&gt; #&gt; #&gt; #&gt; ----------------------------------------------------------- #&gt; : virginica #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; Min. :4.900 Min. :2.200 Min. :4.500 Min. :1.400 #&gt; 1st Qu.:6.225 1st Qu.:2.800 1st Qu.:5.100 1st Qu.:1.800 #&gt; Median :6.500 Median :3.000 Median :5.550 Median :2.000 #&gt; Mean :6.588 Mean :2.974 Mean :5.552 Mean :2.026 #&gt; 3rd Qu.:6.900 3rd Qu.:3.175 3rd Qu.:5.875 3rd Qu.:2.300 #&gt; Max. :7.900 Max. :3.800 Max. :6.900 Max. :2.500 #&gt; Species #&gt; setosa : 0 #&gt; versicolor: 0 #&gt; virginica :50 #&gt; #&gt; #&gt; Group Averages Over Level Combinations of Factors 分组平均 str(warpbreaks) #&gt; &#39;data.frame&#39;: 54 obs. of 3 variables: #&gt; $ breaks : num 26 30 54 25 70 52 51 26 67 18 ... #&gt; $ wool : Factor w/ 2 levels &quot;A&quot;,&quot;B&quot;: 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ tension: Factor w/ 3 levels &quot;L&quot;,&quot;M&quot;,&quot;H&quot;: 1 1 1 1 1 1 1 1 1 2 ... head(warpbreaks) #&gt; breaks wool tension #&gt; 1 26 A L #&gt; 2 30 A L #&gt; 3 54 A L #&gt; 4 25 A L #&gt; 5 70 A L #&gt; 6 52 A L ave(warpbreaks$breaks, warpbreaks$wool) #&gt; [1] 31.03704 31.03704 31.03704 31.03704 31.03704 31.03704 31.03704 31.03704 #&gt; [9] 31.03704 31.03704 31.03704 31.03704 31.03704 31.03704 31.03704 31.03704 #&gt; [17] 31.03704 31.03704 31.03704 31.03704 31.03704 31.03704 31.03704 31.03704 #&gt; [25] 31.03704 31.03704 31.03704 25.25926 25.25926 25.25926 25.25926 25.25926 #&gt; [33] 25.25926 25.25926 25.25926 25.25926 25.25926 25.25926 25.25926 25.25926 #&gt; [41] 25.25926 25.25926 25.25926 25.25926 25.25926 25.25926 25.25926 25.25926 #&gt; [49] 25.25926 25.25926 25.25926 25.25926 25.25926 25.25926 with(warpbreaks, ave(breaks, tension, FUN = function(x) mean(x, trim = 0.1))) #&gt; [1] 35.6875 35.6875 35.6875 35.6875 35.6875 35.6875 35.6875 35.6875 35.6875 #&gt; [10] 26.3125 26.3125 26.3125 26.3125 26.3125 26.3125 26.3125 26.3125 26.3125 #&gt; [19] 21.0625 21.0625 21.0625 21.0625 21.0625 21.0625 21.0625 21.0625 21.0625 #&gt; [28] 35.6875 35.6875 35.6875 35.6875 35.6875 35.6875 35.6875 35.6875 35.6875 #&gt; [37] 26.3125 26.3125 26.3125 26.3125 26.3125 26.3125 26.3125 26.3125 26.3125 #&gt; [46] 21.0625 21.0625 21.0625 21.0625 21.0625 21.0625 21.0625 21.0625 21.0625 # 分组求和 with(warpbreaks, ave(breaks, tension, FUN = function(x) sum(x))) #&gt; [1] 655 655 655 655 655 655 655 655 655 475 475 475 475 475 475 475 475 475 #&gt; [19] 390 390 390 390 390 390 390 390 390 655 655 655 655 655 655 655 655 655 #&gt; [37] 475 475 475 475 475 475 475 475 475 390 390 390 390 390 390 390 390 390 # 分组求和 with(iris, ave(Sepal.Length, Species, FUN = function(x) sum(x))) #&gt; [1] 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 #&gt; [13] 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 #&gt; [25] 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 #&gt; [37] 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 #&gt; [49] 250.3 250.3 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 #&gt; [61] 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 #&gt; [73] 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 #&gt; [85] 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 #&gt; [97] 296.8 296.8 296.8 296.8 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 #&gt; [109] 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 #&gt; [121] 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 #&gt; [133] 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 #&gt; [145] 329.4 329.4 329.4 329.4 329.4 329.4 5.11 表格统计 介绍操作表格的 table, addmargins, prop.table, xtabs, margin.table, ftabe 等函数 table 多个分类变量分组计数统计 介绍 warpbreaks 和 airquality 纽约空气质量监测数据集 二维的数据框 UCBAdmissions 1973 年加州大学伯克利分校的院系录取数据集 3维的列联表 Titanic 4维的列联表数据 泰坦尼克号幸存者数据集 with(warpbreaks, table(wool, tension)) #&gt; tension #&gt; wool L M H #&gt; A 9 9 9 #&gt; B 9 9 9 以 iris 数据集为例，table 的第一个参数是自己制造的第二个分类变量，原始分类变量是 Species with(iris, table(Sepal.check = Sepal.Length &gt; 7, Species)) #&gt; Species #&gt; Sepal.check setosa versicolor virginica #&gt; FALSE 50 50 38 #&gt; TRUE 0 0 12 with(iris, table(Sepal.check = Sepal.Length &gt; mean(Sepal.Length), Species)) #&gt; Species #&gt; Sepal.check setosa versicolor virginica #&gt; FALSE 50 24 6 #&gt; TRUE 0 26 44 以 airquality 数据集为例，看看月份中臭氧含量比较高的几天 aiq.tab &lt;- with(airquality, table(Oz.high = Ozone &gt; 80, Month)) aiq.tab #&gt; Month #&gt; Oz.high 5 6 7 8 9 #&gt; FALSE 25 9 20 19 27 #&gt; TRUE 1 0 6 7 2 对表格按行和列求和，即求表格的边际，查看总体情况 addmargins(aiq.tab, 1:2) #&gt; Month #&gt; Oz.high 5 6 7 8 9 Sum #&gt; FALSE 25 9 20 19 27 100 #&gt; TRUE 1 0 6 7 2 16 #&gt; Sum 26 9 26 26 29 116 臭氧含量超 80 的天数在每个月的占比，addmargins 的第二个参数 1 表示对列求和 aiq.prop &lt;- prop.table(aiq.tab, 2) aiq.prop #&gt; Month #&gt; Oz.high 5 6 7 8 9 #&gt; FALSE 0.96153846 1.00000000 0.76923077 0.73076923 0.93103448 #&gt; TRUE 0.03846154 0.00000000 0.23076923 0.26923077 0.06896552 aiq.marprop &lt;- addmargins(aiq.prop, 1) aiq.marprop #&gt; Month #&gt; Oz.high 5 6 7 8 9 #&gt; FALSE 0.96153846 1.00000000 0.76923077 0.73076923 0.93103448 #&gt; TRUE 0.03846154 0.00000000 0.23076923 0.26923077 0.06896552 #&gt; Sum 1.00000000 1.00000000 1.00000000 1.00000000 1.00000000 转换成百分比，将小数四舍五入转化为百分数，保留两位小数点 round(100 * aiq.marprop, 2) #&gt; Month #&gt; Oz.high 5 6 7 8 9 #&gt; FALSE 96.15 100.00 76.92 73.08 93.10 #&gt; TRUE 3.85 0.00 23.08 26.92 6.90 #&gt; Sum 100.00 100.00 100.00 100.00 100.00 pairs(airquality, panel = panel.smooth, main = &quot;airquality data&quot;) 以 UCBAdmissions 数据集为例，使用 xtabs 函数把数据组织成列联表，先查看数据的内容 UCBAdmissions #&gt; , , Dept = A #&gt; #&gt; Gender #&gt; Admit Male Female #&gt; Admitted 512 89 #&gt; Rejected 313 19 .... UCBA2DF &lt;- as.data.frame(UCBAdmissions) UCBA2DF #&gt; Admit Gender Dept Freq #&gt; 1 Admitted Male A 512 #&gt; 2 Rejected Male A 313 #&gt; 3 Admitted Female A 89 #&gt; 4 Rejected Female A 19 #&gt; 5 Admitted Male B 353 .... 接着将 UCBA2DF 数据集转化为表格的形式 UCBA2DF.tab &lt;- xtabs(Freq ~ Gender + Admit + Dept, data = UCBA2DF) ftable(UCBA2DF.tab) #&gt; Dept A B C D E F #&gt; Gender Admit #&gt; Male Admitted 512 353 120 138 53 22 #&gt; Rejected 313 207 205 279 138 351 #&gt; Female Admitted 89 17 202 131 94 24 #&gt; Rejected 19 8 391 244 299 317 将录取性别和院系进行对比 prop.table(margin.table(UCBA2DF.tab, c(1, 3)), 1) #&gt; Dept #&gt; Gender A B C D E F #&gt; Male 0.30657748 0.20810108 0.12077295 0.15496098 0.07097733 0.13861018 #&gt; Female 0.05885559 0.01362398 0.32316076 0.20435967 0.21416894 0.18583106 男生倾向于申请院系 A 和 B，女生倾向于申请院系 C 到 F，院系 A 和 B 是最容易录取的。 5.12 索引访问 which 与引用 [ 性能比较，在区间 \\([0,1]\\) 上生成 10 万个服从均匀分布的随机数，随机抽取其中\\(\\frac{1}{4}\\)。 n &lt;- 100000 x &lt;- runif(n) i &lt;- logical(n) i[sample(n, n / 4)] &lt;- TRUE microbenchmark::microbenchmark(x[i], x[which(i)], times = 1000) 使用 subset 函数与 [ 比较 5.13 多维数组 多维数组的行列是怎么定义的 ?array 轴的概念，画个图表示数组 array(1:27, c(3, 3, 3)) #&gt; , , 1 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 1 4 7 #&gt; [2,] 2 5 8 #&gt; [3,] 3 6 9 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 10 13 16 #&gt; [2,] 11 14 17 #&gt; [3,] 12 15 18 #&gt; #&gt; , , 3 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 19 22 25 #&gt; [2,] 20 23 26 #&gt; [3,] 21 24 27 垂直于Z轴的平面去截三维立方体，3 代表 z 轴，得到三个截面（二维矩阵） asplit(array(1:27, c(3, 3, 3)), 3) #&gt; [[1]] #&gt; [,1] [,2] [,3] #&gt; [1,] 1 4 7 #&gt; [2,] 2 5 8 #&gt; [3,] 3 6 9 #&gt; #&gt; [[2]] #&gt; [,1] [,2] [,3] #&gt; [1,] 10 13 16 #&gt; [2,] 11 14 17 #&gt; [3,] 12 15 18 #&gt; #&gt; [[3]] #&gt; [,1] [,2] [,3] #&gt; [1,] 19 22 25 #&gt; [2,] 20 23 26 #&gt; [3,] 21 24 27 对每个二维矩阵按列求和 lapply(asplit(array(1:27, c(3, 3, 3)), 3), apply, 2, sum) #&gt; [[1]] #&gt; [1] 6 15 24 #&gt; #&gt; [[2]] #&gt; [1] 33 42 51 #&gt; #&gt; [[3]] #&gt; [1] 60 69 78 asplit 和 lapply 组合处理多维数组的计算问题，多维数组23 三维数组的矩阵运算 abind 包提供更多的数组操作，如合并，替换 数组操作 aperm 数组转置 Array Transposition asplit 数组拆分 其后接 lapply 或者 vapply apply 数组计算 rray 包 https://github.com/r-lib/rray 5.14 其它操作 成对的数据操作有 list 与 unlist、stack 与 unstack、class 与 unclass、attach 与 detach 以及 with 和 within，它们在数据操作过程中有时会起到一定的补充作用。 5.14.1 列表属性 # 创建列表 list(...) pairlist(...) # 转化列表 as.list(x, ...) ## S3 method for class &#39;environment&#39; as.list(x, all.names = FALSE, sorted = FALSE, ...) as.pairlist(x) # 检查列表 is.list(x) is.pairlist(x) alist(...) list 函数用来构造、转化和检查 R 列表对象。下面创建一个临时列表对象 tmp ，它包含两个元素 A 和 B，两个元素都是向量，前者是数值型，后者是字符型 (tmp &lt;- list(A = c(1, 2, 3), B = c(&quot;a&quot;, &quot;b&quot;))) #&gt; $A #&gt; [1] 1 2 3 #&gt; #&gt; $B #&gt; [1] &quot;a&quot; &quot;b&quot; unlist(x, recursive = TRUE, use.names = TRUE) unlist 函数将给定的列表对象 x 简化为原子向量 (atomic vector)，我们发现简化之后变成一个字符型向量 unlist(tmp) #&gt; A1 A2 A3 B1 B2 #&gt; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;a&quot; &quot;b&quot; unlist(tmp, use.names = FALSE) #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;a&quot; &quot;b&quot; unlist 的逆操作是 relist 5.14.2 堆叠向量 stack(x, ...) ## Default S3 method: stack(x, drop = FALSE, ...) ## S3 method for class &#39;data.frame&#39; stack(x, select, drop = FALSE, ...) unstack(x, ...) ## Default S3 method: unstack(x, form, ...) ## S3 method for class &#39;data.frame&#39; unstack(x, form, ...) stack 与 unstack 将多个向量堆在一起组成一个向量 # 查看数据集 PlantGrowth class(PlantGrowth) #&gt; [1] &quot;data.frame&quot; head(PlantGrowth) #&gt; weight group #&gt; 1 4.17 ctrl #&gt; 2 5.58 ctrl #&gt; 3 5.18 ctrl #&gt; 4 6.11 ctrl #&gt; 5 4.50 ctrl #&gt; 6 4.61 ctrl # 检查默认的公式 formula(PlantGrowth) #&gt; weight ~ group # 根据公式解除堆叠 # 下面等价于 unstack(PlantGrowth, form = weight ~ group) (pg &lt;- unstack(PlantGrowth)) #&gt; ctrl trt1 trt2 #&gt; 1 4.17 4.81 6.31 #&gt; 2 5.58 4.17 5.12 #&gt; 3 5.18 4.41 5.54 #&gt; 4 6.11 3.59 5.50 #&gt; 5 4.50 5.87 5.37 #&gt; 6 4.61 3.83 5.29 #&gt; 7 5.17 6.03 4.92 #&gt; 8 4.53 4.89 6.15 #&gt; 9 5.33 4.32 5.80 #&gt; 10 5.14 4.69 5.26 现在再将变量 pg 堆叠起来，还可以指定要堆叠的列 stack(pg) #&gt; values ind #&gt; 1 4.17 ctrl #&gt; 2 5.58 ctrl #&gt; 3 5.18 ctrl #&gt; 4 6.11 ctrl #&gt; 5 4.50 ctrl .... stack(pg, select = -ctrl) #&gt; values ind #&gt; 1 4.81 trt1 #&gt; 2 4.17 trt1 #&gt; 3 4.41 trt1 #&gt; 4 3.59 trt1 #&gt; 5 5.87 trt1 .... 形式上和 reshape 有一些相似之处，数据框可以由长变宽或由宽变长 5.14.3 属性转化 class(x) class(x) &lt;- value unclass(x) inherits(x, what, which = FALSE) oldClass(x) oldClass(x) &lt;- value class 和 unclass 函数用来查看、设置类属性和取消类属性，常用于面向对象的编程设计中 class(iris) #&gt; [1] &quot;data.frame&quot; class(iris$Species) #&gt; [1] &quot;factor&quot; unclass(iris$Species) #&gt; [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #&gt; [38] 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 #&gt; [75] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 #&gt; [112] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 #&gt; [149] 3 3 #&gt; attr(,&quot;levels&quot;) .... 5.14.4 绑定环境 attach(what, pos = 2L, name = deparse(substitute(what), backtick = FALSE), warn.conflicts = TRUE ) detach(name, pos = 2L, unload = FALSE, character.only = FALSE, force = FALSE ) attach 和 detach 是否绑定数据框的列名，不推荐操作，推荐使用 with attach(iris) head(Species) #&gt; [1] setosa setosa setosa setosa setosa setosa #&gt; Levels: setosa versicolor virginica detach(iris) 5.14.5 数据环境 with(data, expr, ...) within(data, expr, ...) ## S3 method for class &#39;list&#39; within(data, expr, keepAttrs = TRUE, ...) data 参数 data 用来构造表达式计算的环境。其默认值可以是一个环境，列表，数据框。在 within 函数中 data 参数只能是列表或数据框。 expr 参数 expr 包含要计算的表达式。在 within 中通常包含一个复合表达式，比如 { a &lt;- somefun() b &lt;- otherfun() ... rm(unused1, temp) } with 和 within 计算一组表达式，计算的环境是由数据构造的，后者可以修改原始的数据 with(mtcars, mpg[cyl == 8 &amp; disp &gt; 350]) #&gt; [1] 18.7 14.3 10.4 10.4 14.7 19.2 15.8 和下面计算的结果一样，但是更加简洁漂亮 mtcars$mpg[mtcars$cyl == 8 &amp; mtcars$disp &gt; 350] #&gt; [1] 18.7 14.3 10.4 10.4 14.7 19.2 15.8 within 函数可以修改原数据环境中的多个变量，比如删除、修改和添加等 # 原数据集 airquality head(airquality) #&gt; Ozone Solar.R Wind Temp Month Day #&gt; 1 41 190 7.4 67 5 1 #&gt; 2 36 118 8.0 72 5 2 #&gt; 3 12 149 12.6 74 5 3 #&gt; 4 18 313 11.5 62 5 4 #&gt; 5 NA NA 14.3 56 5 5 #&gt; 6 28 NA 14.9 66 5 6 aq &lt;- within(airquality, { lOzone &lt;- log(Ozone) # 取对数 Month &lt;- factor(month.abb[Month]) # 字符串型转因子型 cTemp &lt;- round((Temp - 32) * 5 / 9, 1) # 从华氏温度到摄氏温度转化 S.cT &lt;- Solar.R / cTemp # 使用新创建的变量 rm(Day, Temp) }) # 修改后的数据集 head(aq) #&gt; Ozone Solar.R Wind Month S.cT cTemp lOzone #&gt; 1 41 190 7.4 May 9.793814 19.4 3.713572 #&gt; 2 36 118 8.0 May 5.315315 22.2 3.583519 #&gt; 3 12 149 12.6 May 6.394850 23.3 2.484907 #&gt; 4 18 313 11.5 May 18.742515 16.7 2.890372 #&gt; 5 NA NA 14.3 May NA 13.3 NA #&gt; 6 28 NA 14.9 May NA 18.9 3.332205 下面再举一个复杂的绘图例子，这个例子来自 boxplot 函数 with(ToothGrowth, { boxplot(len ~ dose, boxwex = 0.25, at = 1:3 - 0.2, subset = (supp == &quot;VC&quot;), col = &quot;#4285f4&quot;, main = &quot;Guinea Pigs&#39; Tooth Growth&quot;, xlab = &quot;Vitamin C dose mg&quot;, ylab = &quot;tooth length&quot;, ylim = c(0, 35) ) boxplot(len ~ dose, add = TRUE, boxwex = 0.25, at = 1:3 + 0.2, subset = supp == &quot;OJ&quot;, col = &quot;#EA4335&quot; ) legend(2, 9, c(&quot;Ascorbic acid&quot;, &quot;Orange juice&quot;), fill = c(&quot;#4285f4&quot;, &quot;#EA4335&quot;) ) }) 将 boxplot 函数的 subset 参数单独提出来，调用数据子集选择函数 subset ，这里 with 中只包含一个表达式，所以也可以不用大括号 with( subset(ToothGrowth, supp == &quot;VC&quot;), boxplot(len ~ dose, boxwex = 0.25, at = 1:3 - 0.2, col = &quot;#4285f4&quot;, main = &quot;Guinea Pigs&#39; Tooth Growth&quot;, xlab = &quot;Vitamin C dose mg&quot;, ylab = &quot;tooth length&quot;, ylim = c(0, 35) ) ) with( subset(ToothGrowth, supp == &quot;OJ&quot;), boxplot(len ~ dose, add = TRUE, boxwex = 0.25, at = 1:3 + 0.2, col = &quot;#EA4335&quot; ) ) legend(2, 9, c(&quot;Ascorbic acid&quot;, &quot;Orange juice&quot;), fill = c(&quot;#4285f4&quot;, &quot;#EA4335&quot;) ) 可以作为数据变换 transform 的一种替代，它也比较像 dplyr 包的 mutate 函数 within(mtcars[1:5,1:3],{ disp.cc &lt;- disp * 2.54^3 disp.l &lt;- disp.cc / 1e3 }) #&gt; mpg cyl disp disp.l disp.cc #&gt; Mazda RX4 21.0 6 160 2.621930 2621.930 #&gt; Mazda RX4 Wag 21.0 6 160 2.621930 2621.930 #&gt; Datsun 710 22.8 4 108 1.769803 1769.803 #&gt; Hornet 4 Drive 21.4 6 258 4.227863 4227.863 #&gt; Hornet Sportabout 18.7 8 360 5.899343 5899.343 # 只能使用已有的列，刚生成的列不能用 # transform( # mtcars[1:5, 1:3], # disp.cc = disp * 2.54^3, # disp.l = disp.cc / 1e3 # ) transform( mtcars[1:5, 1:3], disp.cc = disp * 2.54^3 ) #&gt; mpg cyl disp disp.cc #&gt; Mazda RX4 21.0 6 160 2621.930 #&gt; Mazda RX4 Wag 21.0 6 160 2621.930 #&gt; Datsun 710 22.8 4 108 1769.803 #&gt; Hornet 4 Drive 21.4 6 258 4227.863 #&gt; Hornet Sportabout 18.7 8 360 5899.343 transform 只能使用已有的列，变换中间生成的列不能用，所以相比于 transform 函数， within 显得更为灵活 5.15 运行环境 xfun::session_info() #&gt; R Under development (unstable) (2020-02-04 r77771) #&gt; Platform: x86_64-pc-linux-gnu (64-bit) #&gt; Running under: Ubuntu 16.04.6 LTS #&gt; #&gt; Locale: #&gt; LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C #&gt; LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 #&gt; LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 #&gt; LC_PAPER=en_US.UTF-8 LC_NAME=C #&gt; LC_ADDRESS=C LC_TELEPHONE=C #&gt; LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C #&gt; #&gt; Package version: #&gt; base64enc_0.1.3 bookdown_0.17 compiler_4.0.0 curl_4.3 #&gt; digest_0.6.23 evaluate_0.14 glue_1.3.1 graphics_4.0.0 #&gt; grDevices_4.0.0 highr_0.8 htmltools_0.4.0 jsonlite_1.6.1 #&gt; knitr_1.26 magrittr_1.5 markdown_1.1 methods_4.0.0 #&gt; mime_0.9 Rcpp_1.0.3 rlang_0.4.4 rmarkdown_2.1 #&gt; stats_4.0.0 stringi_1.4.5 stringr_1.4.0 tinytex_0.19 #&gt; tools_4.0.0 utils_4.0.0 xfun_0.12 yaml_2.2.1 参考文献 "],
["data-tibble.html", "第 6 章 净土化操作 6.1 常用操作 6.2 高频问题 6.3 管道操作 6.4 运行环境", " 第 6 章 净土化操作 常用操作和高频问题需要合并进之前的 data-manipulation，本章只介绍向量化计算 以 dplyr 为核心的 tidyverse 风数据操作 管道风操作 在不同规模的数据集上，Base R，dplyr 和 data.table 的处理性能应该属于低、中、高档搭配的情形 更加高级的数据变形操作，特别是数据类型的一致性，方便后续的可视化和建模，引入 tidyverse，数据处理或者叫特征工程 Base R vs data.table vs dplyr 它们各有优点，所以都加以介绍 参考 Jozef Hajnala 博文。 关于 tidyverse 提供的数据操作不要移动到 Base R 对应的章节，这二者已经越行越远，本章主要讲并行或分布式数据操作工具，如 sparklyr 针对大数据集上的操 Base R 的数据操作的一致性问题参见统计之都帖子 https://d.cosx.org/d/420763 Malcolm Barrett 以幻灯片的形式呈现 dplyr 和 purrr 的基础用法 Charlotte Wickham 的课程 A introduction to purrr purrr-tutorial 关于引用 quotation 相比于 SQL， dplyr 在数据库操作的不足，这是一些比较难的部分 https://dbi.r-dbi.org/articles/dbi-1#sec:open-issues 函数式编程 Functional Programming Languages 用于数据处理 rpivotTable 动态数据透视表 fuzzyjoin Join tables together on inexact matching dtplyr dtplyr is the data.table backend for dplyr. It provides S3 methods for data.table objects so that dplyr works the way you expect. bplyr basic dplyr and tidyr functionality without the tidyverse dependencies SqlRender 基于 Java 语言，借助 rJava 包支持参数化的 SQL 语句，并且可以将一种 SQL 语句（如 Microsoft SQL Server）转化为多种SQL语句（如Oracle, PostgreSQL, Amazon RedShift, Impala, IBM Netezza, Google BigQuery, Microsoft PDW, and SQLite） fastmap 实现键值存储，提供新的数据结构 Roaring bitmaps Bitsets, also called bitmaps, are commonly used as fast data structures. library(tidyverse) 数据操作的语法 第一代 Base R 数据操作已在第 5 章详细介绍 第二代 reshape （退休）使用函数 melt 和 cast 重构(restructure)和聚合(aggregate)数据 reshape2 （退休）是 reshape 的继任者，功能和 reshape 类似，提供两个函数 melt 和 cast 聚合数据，因此不再介绍 reshape，而鉴于 reshape2 还在活跃使用中，故而以它为例介绍 melt 和 cast 函数 plyr （退休）统一拆分(split)，计算(apply)，合并(combine)的数据处理流，由 dplyr（用于data.frame） 和 purrr （用于 list）继任 第三代 dplyr 操作数据的语法及其扩展 sparklyr 给 dplyr 提供 Spark 接口支持 dbplyr 给 dplyr 提供 DBI 数据库接口支持 dtplyr 给 dplyr 提供 data.table 支持 tidyr 提供 spread 和 gather 两个函数清洗数据 Garrett Grolemund 在 RStudio 主要从事教育教学，参考 Materials for the Tidyverse Train-the-trainer workshop 和 The Tidyverse Cookbook Dirk Eddelbuettel 的 Getting Started in R – Tinyverse Edition 6.1 常用操作 dplyr 由 Hadley Wickham 主要由开发和维护，是Rstudio公司开源的用于数据处理的一大利器，该包号称“数据操作的语法”，与 ggplot2 对应，也就是说数据处理那一套已经建立完整的和SQL一样的功能。它们都遵循同样的处理逻辑，只不过一个用SQL写，一个用R语言写，处理效率差不多，R语言写的 SQL 会被翻译为 SQL 语句，再传至数据库查询，当然它也支持内存内的数据操作。目前 dplyr 以 dbplyr 为后端支持的数据库有：MySQL、PostgreSQL，SQLite等，完整的支持列表请看 这里，连接特定数据库，都是基于 DBI，DBI 即 Database Interface， 是使用C/C++开发的底层数据库接口，是一个统一的关系型数据库连接框架，需要根据不同的具体的数据库进行实例化，才可使用。 dplyr 常用的函数是 7 个： arrange 排序 filter 过滤行 select 选择列 mutate 变换 summarise 汇总 group_by 分组 distinct 去重 以 ggplot2 包自带的钻石数据集 diamonds 为例介绍 6.1.1 查看 除了直接打印数据集的前几行，tibble 包还提供 glimpse 函数查看数据集，而 Base R 默认查看方式是调用 str 函数 diamonds #&gt; # A tibble: 53,940 x 10 #&gt; carat cut color clarity depth table price x y z #&gt; &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 #&gt; 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31 #&gt; 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31 #&gt; 4 0.290 Premium I VS2 62.4 58 334 4.2 4.23 2.63 #&gt; 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75 #&gt; 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 #&gt; # … with 5.393e+04 more rows glimpse(diamonds) #&gt; Observations: 53,940 #&gt; Variables: 10 #&gt; $ carat &lt;dbl&gt; 0.23, 0.21, 0.23, 0.29, 0.31, 0.24, 0.24, 0.26, 0.22, 0.23, … #&gt; $ cut &lt;ord&gt; Ideal, Premium, Good, Premium, Good, Very Good, Very Good, V… #&gt; $ color &lt;ord&gt; E, E, E, I, J, J, I, H, E, H, J, J, F, J, E, E, I, J, J, J, … #&gt; $ clarity &lt;ord&gt; SI2, SI1, VS1, VS2, SI2, VVS2, VVS1, SI1, VS2, VS1, SI1, VS1… #&gt; $ depth &lt;dbl&gt; 61.5, 59.8, 56.9, 62.4, 63.3, 62.8, 62.3, 61.9, 65.1, 59.4, … #&gt; $ table &lt;dbl&gt; 55, 61, 65, 58, 58, 57, 57, 55, 61, 61, 55, 56, 61, 54, 62, … #&gt; $ price &lt;int&gt; 326, 326, 327, 334, 335, 336, 336, 337, 337, 338, 339, 340, … #&gt; $ x &lt;dbl&gt; 3.95, 3.89, 4.05, 4.20, 4.34, 3.94, 3.95, 4.07, 3.87, 4.00, … #&gt; $ y &lt;dbl&gt; 3.98, 3.84, 4.07, 4.23, 4.35, 3.96, 3.98, 4.11, 3.78, 4.05, … #&gt; $ z &lt;dbl&gt; 2.43, 2.31, 2.31, 2.63, 2.75, 2.48, 2.47, 2.53, 2.49, 2.39, … 表 6.1: dplyr 定义的数据对象类型 类型 含义 int 整型 integer dbl （单）双精度浮点类型 chr 字符（串）类型 dttm data-time 类型 lgl 布尔类型 fctr 因子类型 factor date 日期类型 表 6.1 中 dttm 和 date 类型代指 lubridate 包指定的日期对象 POSIXct、 POSIXlt、 Date、 chron、 yearmon、 yearqtr、 zoo、 zooreg、 timeDate、 xts、 its、 ti、 jul、 timeSeries 和 fts。 6.1.2 筛选 按条件筛选数据的子集，按行筛选 diamonds %&gt;% filter(cut == &quot;Ideal&quot; , carat &gt;= 3) #&gt; # A tibble: 4 x 10 #&gt; carat cut color clarity depth table price x y z #&gt; &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 3.22 Ideal I I1 62.6 55 12545 9.49 9.42 5.92 #&gt; 2 3.5 Ideal H I1 62.8 57 12587 9.65 9.59 6.03 #&gt; 3 3.01 Ideal J SI2 61.7 58 16037 9.25 9.2 5.69 #&gt; 4 3.01 Ideal J I1 65.4 60 16538 8.99 8.93 5.86 先按行，再按列筛选 diamonds %&gt;% filter(carat &gt;= 3, color == &quot;I&quot;) %&gt;% select(cut, carat) #&gt; # A tibble: 16 x 2 #&gt; cut carat #&gt; &lt;ord&gt; &lt;dbl&gt; #&gt; 1 Premium 3.01 #&gt; 2 Fair 3.02 #&gt; 3 Good 3 #&gt; 4 Ideal 3.22 #&gt; 5 Premium 4.01 #&gt; 6 Very Good 3.04 #&gt; # … with 10 more rows 6.1.3 排序 arrange 默认升序排列，按钻石重量升序，按价格降序 diamonds %&gt;% filter(cut == &quot;Ideal&quot; , carat &gt;= 3) %&gt;% arrange(carat, desc(price)) #&gt; # A tibble: 4 x 10 #&gt; carat cut color clarity depth table price x y z #&gt; &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 3.01 Ideal J I1 65.4 60 16538 8.99 8.93 5.86 #&gt; 2 3.01 Ideal J SI2 61.7 58 16037 9.25 9.2 5.69 #&gt; 3 3.22 Ideal I I1 62.6 55 12545 9.49 9.42 5.92 #&gt; 4 3.5 Ideal H I1 62.8 57 12587 9.65 9.59 6.03 6.1.4 聚合 分组求和，求平均，计数 diamonds %&gt;% filter(carat &gt; 3, color == &quot;I&quot;) %&gt;% group_by(cut, clarity) %&gt;% summarise(sum_carat = sum(carat), mean_carat = mean(carat), n_count = n()) #&gt; # A tibble: 8 x 5 #&gt; # Groups: cut [5] #&gt; cut clarity sum_carat mean_carat n_count #&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 Fair I1 3.02 3.02 1 #&gt; 2 Fair SI2 6.02 3.01 2 #&gt; 3 Good SI2 6.02 3.01 2 #&gt; 4 Very Good I1 4 4 1 #&gt; 5 Very Good SI2 3.04 3.04 1 #&gt; 6 Premium I1 10.7 3.56 3 #&gt; # … with 2 more rows 6.1.5 合并 按行合并 set.seed(2018) one &lt;- diamonds %&gt;% filter(color == &quot;I&quot;) %&gt;% sample_n(5) two &lt;- diamonds %&gt;% filter(color == &quot;J&quot;) %&gt;% sample_n(5) # 按行合并数据框 one 和 two bind_rows(one, two) #&gt; # A tibble: 10 x 10 #&gt; carat cut color clarity depth table price x y z #&gt; &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.42 Ideal I VVS1 62.5 57 884 4.77 4.8 2.99 #&gt; 2 0.3 Ideal I VVS2 62.5 53.6 532 4.29 4.33 2.69 #&gt; 3 2.02 Good I VS1 57.9 63 17533 8.13 8.21 4.73 #&gt; 4 0.9 Premium I VS2 61.9 58 3398 6.18 6.23 3.84 #&gt; 5 1.98 Very Good I VS2 62.7 60 15083 7.9 7.96 4.98 #&gt; 6 1.51 Very Good J VVS2 62.6 63 8706 7.29 7.24 4.55 #&gt; # … with 4 more rows 按列合并 set.seed(2018) three &lt;- diamonds %&gt;% select(carat, color) %&gt;% sample_n(5) four &lt;- diamonds %&gt;% select(carat, color) %&gt;% sample_n(5) bind_cols(three, four) #&gt; # A tibble: 5 x 4 #&gt; carat color carat1 color1 #&gt; &lt;dbl&gt; &lt;ord&gt; &lt;dbl&gt; &lt;ord&gt; #&gt; 1 0.33 H 0.52 F #&gt; 2 1.09 F 0.51 F #&gt; 3 1.52 I 0.5 G #&gt; 4 0.95 G 0.38 E #&gt; 5 0.35 E 0.51 J 6.1.6 变换 添加一列，新的列或者改变原来的列 diamonds %&gt;% filter(carat &gt; 3, color == &quot;I&quot;) %&gt;% select(cut, carat) %&gt;% mutate(vol = if_else(carat &gt; 3.5, &quot;A&quot;, &quot;B&quot;)) #&gt; # A tibble: 13 x 3 #&gt; cut carat vol #&gt; &lt;ord&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 Premium 3.01 B #&gt; 2 Fair 3.02 B #&gt; 3 Ideal 3.22 B #&gt; 4 Premium 4.01 A #&gt; 5 Very Good 3.04 B #&gt; 6 Very Good 4 A #&gt; # … with 7 more rows 6.1.7 去重 数据去重在 dplyr 中的实现24。 set.seed(123) df &lt;- data.frame( x = sample(0:1, 10, replace = T), y = sample(0:1, 10, replace = T), z = 1:10 ) df #&gt; x y z #&gt; 1 0 1 1 #&gt; 2 0 1 2 #&gt; 3 0 1 3 #&gt; 4 1 0 4 #&gt; 5 0 1 5 #&gt; 6 1 0 6 #&gt; 7 1 1 7 #&gt; 8 1 0 8 #&gt; 9 0 0 9 #&gt; 10 0 0 10 去掉列重复的数据点 (x, y) df %&gt;% group_by(x, y) %&gt;% filter(row_number(z) == 1) #&gt; # A tibble: 4 x 3 #&gt; # Groups: x, y [4] #&gt; x y z #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 0 1 1 #&gt; 2 1 0 4 #&gt; 3 1 1 7 #&gt; 4 0 0 9 # 此处不对，没有了 z df %&gt;% distinct(x, y) #&gt; x y #&gt; 1 0 1 #&gt; 2 1 0 #&gt; 3 1 1 #&gt; 4 0 0 # 应该为 df %&gt;% distinct(x, y, .keep_all = TRUE) #&gt; x y z #&gt; 1 0 1 1 #&gt; 2 1 0 4 #&gt; 3 1 1 7 #&gt; 4 0 0 9 6.2 高频问题 常用的数据操作包含 创建空的数据框或者说初始化一个数据框， 按指定的列对数据框排序， 选择特定的一些列，复杂情况是可能需要正则表达式从列名或者值中筛选 合并两个数据框，分为 (inner outer left right) 四种情况 宽格式和长格式互相转换，即重塑操作 reshape，单独的 tidyr 包操作，是 reshape2 包的进化版，提供 spread 和 gather 两个主要函数 6.2.1 初始化数据框 创建空的数据框，就是不包含任何行、记录25 empty_df &lt;- data.frame( Doubles = double(), Ints = integer(), Factors = factor(), Logicals = logical(), Characters = character(), stringsAsFactors = FALSE ) str(empty_df) #&gt; &#39;data.frame&#39;: 0 obs. of 5 variables: #&gt; $ Doubles : num #&gt; $ Ints : int #&gt; $ Factors : Factor w/ 0 levels: #&gt; $ Logicals : logi #&gt; $ Characters: chr 如果数据框 df 包含数据，现在要依据它创建一个空的数据框 empty_df = df[FALSE,] 还可以使用 structure 构造一个数据框，并且我们发现它的效率更高 s &lt;- function() structure(list( Date = as.Date(character()), File = character(), User = character() ), class = &quot;data.frame&quot; ) d &lt;- function() data.frame( Date = as.Date(character()), File = character(), User = character(), stringsAsFactors = FALSE ) microbenchmark::microbenchmark(s(), d()) #&gt; Unit: microseconds #&gt; expr min lq mean median uq max neval #&gt; s() 16.802 19.5705 57.71463 23.2385 29.0040 2959.308 100 #&gt; d() 187.202 197.7280 244.77946 207.0375 221.6725 2824.444 100 6.2.2 移除缺失记录 只要行中包含缺失值，我们就把这样的行移除出去 airquality[complete.cases(airquality), ] #&gt; Ozone Solar.R Wind Temp Month Day #&gt; 1 41 190 7.4 67 5 1 #&gt; 2 36 118 8.0 72 5 2 #&gt; 3 12 149 12.6 74 5 3 #&gt; 4 18 313 11.5 62 5 4 #&gt; 7 23 299 8.6 65 5 7 #&gt; 8 19 99 13.8 59 5 8 #&gt; 9 8 19 20.1 61 5 9 #&gt; 12 16 256 9.7 69 5 12 #&gt; 13 11 290 9.2 66 5 13 .... 6.2.3 数据类型转化 str(PlantGrowth) #&gt; &#39;data.frame&#39;: 30 obs. of 2 variables: #&gt; $ weight: num 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ... #&gt; $ group : Factor w/ 3 levels &quot;ctrl&quot;,&quot;trt1&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... bob &lt;- PlantGrowth i &lt;- sapply(bob, is.factor) bob[i] &lt;- lapply(bob[i], as.character) str(bob) #&gt; &#39;data.frame&#39;: 30 obs. of 2 variables: #&gt; $ weight: num 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ... #&gt; $ group : chr &quot;ctrl&quot; &quot;ctrl&quot; &quot;ctrl&quot; &quot;ctrl&quot; ... 6.2.4 跨列分组求和 输入是一个数据框 data.frame，按照其中某一变量分组，然后计算任意数量的变量的行和和列和。 空气质量数据集 airquality 按月份 Month 分组，然后求取满足条件的列的和 Reduce(rbind, lapply(unique(airquality$Month), function(gv) { subdta &lt;- subset(airquality, subset = Month == gv) data.frame( Colsum = as.numeric( colSums(subdta[, grepl(&quot;[mM]&quot;, names(airquality))], na.rm = TRUE) ), Month = gv ) })) #&gt; Colsum Month #&gt; 1 2032 5 #&gt; 2 155 5 #&gt; 3 2373 6 #&gt; 4 180 6 #&gt; 5 2601 7 #&gt; 6 217 7 #&gt; 7 2603 8 #&gt; 8 248 8 #&gt; 9 2307 9 #&gt; 10 270 9 什么是函数式编程，R 语言环境下的函数式编程是如何操作的 6.3 管道操作 Stefan Milton Bache 开发了 magrittr 包实现管道操作，增加代码的可读性和维护性，但是这个 R 包的名字取的太奇葩，因为 记不住，它其实是一个复杂的法语发音，中式英语就叫它马格里特吧！这下应该好记多了吧！ 我要查看是否需要新添加一个 R 包依赖，假设该 R 包是 reticulate 没有出现在 DESCRIPTION 文件中，但是可能已经被其中某（个）些 R 包依赖了 &quot;reticulate&quot; %in% sort(unique(unlist(tools::package_dependencies(desc::desc_get_deps()$package, recursive = TRUE)))) #&gt; [1] FALSE 安装 pkg 的依赖 pkg &lt;- c( &quot;bookdown&quot;, &quot;e1071&quot;, &quot;formatR&quot;, &quot;lme4&quot;, &quot;mvtnorm&quot;, &quot;prettydoc&quot;, &quot;psych&quot;, &quot;reticulate&quot;, &quot;rstan&quot;, &quot;rstanarm&quot;, &quot;rticles&quot;, &quot;svglite&quot;, &quot;TMB&quot;, &quot;glmmTMB&quot; ) # 获取 pkg 的所有依赖 dep_pkg &lt;- tools::package_dependencies(pkg, recursive = TRUE) # 将列表 list 合并为向量 vector merge_pkg &lt;- Reduce(&quot;c&quot;, dep_pkg, accumulate = FALSE) # 所有未安装的 R 包 miss_pkg &lt;- setdiff(unique(merge_pkg), unique(.packages(TRUE))) # 除了 pkg 外，未安装的 R 包，安装 pkg 的依赖 sort(setdiff(miss_pkg, pkg)) #&gt; [1] &quot;bayesplot&quot; &quot;checkmate&quot; &quot;DT&quot; &quot;dygraphs&quot; &quot;gtools&quot; #&gt; [6] &quot;inline&quot; &quot;loo&quot; &quot;matrixStats&quot; &quot;minqa&quot; &quot;mnormt&quot; #&gt; [11] &quot;nloptr&quot; &quot;packrat&quot; &quot;pkgbuild&quot; &quot;rsconnect&quot; &quot;rstantools&quot; #&gt; [16] &quot;shinystan&quot; &quot;shinythemes&quot; &quot;StanHeaders&quot; &quot;threejs&quot; 转化为管道操作，增加可读性，26 再举一个关于数据模拟的例子 模拟 0-1 序列， set.seed(2019) binom_sample &lt;- function(n) { sum(sample(x = c(0,1), size = n, prob = c(0.8, 0.2), replace = TRUE))/n } # 频率估计概率 one_prob &lt;- sapply(10^(seq(8)), binom_sample) # 估计的误差 one_abs &lt;- abs(one_prob - 0.2) one_abs #&gt; [1] 1.000e-01 1.000e-02 1.100e-02 4.400e-03 1.460e-03 3.980e-04 4.700e-06 #&gt; [8] 9.552e-05 似然估计 6.4 运行环境 xfun::session_info() #&gt; R Under development (unstable) (2020-02-04 r77771) #&gt; Platform: x86_64-pc-linux-gnu (64-bit) #&gt; Running under: Ubuntu 16.04.6 LTS #&gt; #&gt; Locale: #&gt; LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C #&gt; LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 #&gt; LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 #&gt; LC_PAPER=en_US.UTF-8 LC_NAME=C #&gt; LC_ADDRESS=C LC_TELEPHONE=C #&gt; LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C #&gt; #&gt; Package version: #&gt; askpass_1.1 assertthat_0.2.1 backports_1.1.5 #&gt; base64enc_0.1.3 BH_1.72.0.3 bookdown_0.17 #&gt; broom_0.5.4 callr_3.4.1 cellranger_1.1.0 #&gt; cli_2.0.1 clipr_0.7.0 colorspace_1.4-1 #&gt; compiler_4.0.0 crayon_1.3.4 curl_4.3 #&gt; DBI_1.1.0 dbplyr_1.4.2 desc_1.2.0 #&gt; digest_0.6.23 dplyr_0.8.4 ellipsis_0.3.0 #&gt; evaluate_0.14 fansi_0.4.1 farver_2.0.3 #&gt; forcats_0.4.0 fs_1.3.1 generics_0.0.2 #&gt; ggplot2_3.2.1 glue_1.3.1 graphics_4.0.0 #&gt; grDevices_4.0.0 grid_4.0.0 gtable_0.3.0 #&gt; haven_2.2.0 highr_0.8 hms_0.5.3 #&gt; htmltools_0.4.0 httr_1.4.1 jsonlite_1.6.1 #&gt; knitr_1.26 labeling_0.3 lattice_0.20-38 #&gt; lazyeval_0.2.2 lifecycle_0.1.0 lubridate_1.7.4 #&gt; magrittr_1.5 markdown_1.1 MASS_7.3.51.5 #&gt; Matrix_1.2.18 methods_4.0.0 mgcv_1.8.31 #&gt; microbenchmark_1.4-7 mime_0.9 modelr_0.1.5 #&gt; munsell_0.5.0 nlme_3.1-143 openssl_1.4.1 #&gt; pillar_1.4.3 pkgconfig_2.0.3 plogr_0.2.0 #&gt; plyr_1.8.5 prettyunits_1.1.1 processx_3.4.1 #&gt; progress_1.2.2 ps_1.3.0 purrr_0.3.3 #&gt; R6_2.4.1 RColorBrewer_1.1.2 Rcpp_1.0.3 #&gt; readr_1.3.1 readxl_1.3.1 rematch_1.0.1 #&gt; reprex_0.3.0 reshape2_1.4.3 rlang_0.4.4 #&gt; rmarkdown_2.1 rprojroot_1.3-2 rstudioapi_0.10 #&gt; rvest_0.3.5 scales_1.1.0 selectr_0.4.2 #&gt; splines_4.0.0 stats_4.0.0 stringi_1.4.5 #&gt; stringr_1.4.0 sys_3.3 tibble_2.1.3 #&gt; tidyr_1.0.2 tidyselect_1.0.0 tidyverse_1.3.0 #&gt; tinytex_0.19 tools_4.0.0 utf8_1.1.4 #&gt; utils_4.0.0 vctrs_0.2.2 viridisLite_0.3.0 #&gt; whisker_0.4 withr_2.1.2 xfun_0.12 #&gt; xml2_1.2.2 yaml_2.2.1 https://stackoverflow.com/questions/22959635/↩︎ https://stackoverflow.com/questions/10689055↩︎ https://www.datacamp.com/community/tutorials/pipe-r-tutorial↩︎ "],
["data-table.html", "第 7 章 高级数据操作 7.1 选择 7.2 过滤 7.3 变换 7.4 聚合 7.5 去重 7.6 命名 7.7 排序 7.8 变形 7.9 分组 7.10 合并", " 第 7 章 高级数据操作 data.table 诞生于2006年4月15日（以在 CRAN 上发布的第一个版本时间为准），是基于 data.frame 的扩展和 Base R 的数据操作连贯一些，dplyr 诞生于2014年1月29日，号称数据操作的语法，其实二者套路一致，都是借用 SQL 语言的设计，实现方式不同罢了，前者主要依靠 C 语言完成底层数据操作，总代码量1.29M，C 占65.6%，后者主要依靠 C++ 语言完成底层数据操作，总代码量1.2M，C++ 占34.4%，上层的高级操作接口都是 R 语言。像这样的大神在写代码，码力应该差不多，编程语言会对数据操作的性能有比较大的影响，我想这也是为什么在很多场合下 data.table 霸榜！ 关于 data.table 和 dplyr 的对比，参看爆栈网的帖子 https://stackoverflow.com/questions/21435339 学习 data.table 包最快的方式就是在 R 控制台运行 example(data.table) 并研究其输出。 library(data.table) library(magrittr) 介绍 data.table 处理数据的方式，对标 dplyr 的基本操作 7.1 选择 选择操作是针对数据框的列（变量/特征/字段） mtcars$cars &lt;- rownames(mtcars) mtcars_df &lt;- as.data.table(mtcars) mtcars_df[, .(mpg, disp)] %&gt;% head() #&gt; mpg disp #&gt; 1: 21.0 160 #&gt; 2: 21.0 160 #&gt; 3: 22.8 108 #&gt; 4: 21.4 258 #&gt; 5: 18.7 360 #&gt; 6: 18.1 225 mtcars %&gt;% dplyr::select(mpg, disp) %&gt;% head() #&gt; mpg disp #&gt; Mazda RX4 21.0 160 #&gt; Mazda RX4 Wag 21.0 160 #&gt; Datsun 710 22.8 108 #&gt; Hornet 4 Drive 21.4 258 #&gt; Hornet Sportabout 18.7 360 #&gt; Valiant 18.1 225 7.2 过滤 过滤 cyl = 6 并且 gear = 4 的记录 mtcars_df[cyl == 6 &amp; gear == 4] #&gt; mpg cyl disp hp drat wt qsec vs am gear carb cars #&gt; 1: 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 Mazda RX4 #&gt; 2: 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 Mazda RX4 Wag #&gt; 3: 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 Merc 280 #&gt; 4: 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 Merc 280C 过滤操作是针对数据框的行（记录） mtcars_df[cyl == 6 &amp; gear == 4, .(mpg, disp)] #&gt; mpg disp #&gt; 1: 21.0 160.0 #&gt; 2: 21.0 160.0 #&gt; 3: 19.2 167.6 #&gt; 4: 17.8 167.6 subset(x = mtcars_df, subset = cyl == 6 &amp; gear == 4, select = c(mpg, disp)) #&gt; mpg disp #&gt; 1: 21.0 160.0 #&gt; 2: 21.0 160.0 #&gt; 3: 19.2 167.6 #&gt; 4: 17.8 167.6 mtcars %&gt;% dplyr::filter(cyl == 6 &amp; gear == 4) %&gt;% dplyr::select(mpg, disp) #&gt; mpg disp #&gt; 1 21.0 160.0 #&gt; 2 21.0 160.0 #&gt; 3 19.2 167.6 #&gt; 4 17.8 167.6 7.3 变换 根据已有的列生成新的列，或者修改已有的列，一次只能修改一列 mtcars_df[, mean_mpg := mean(mpg) ][, mean_disp := mean(disp) ][, .(mpg, disp, cars, mean_mpg, mean_disp)] #&gt; mpg disp cars mean_mpg mean_disp #&gt; 1: 21.0 160.0 Mazda RX4 20.09062 230.7219 #&gt; 2: 21.0 160.0 Mazda RX4 Wag 20.09062 230.7219 #&gt; 3: 22.8 108.0 Datsun 710 20.09062 230.7219 #&gt; 4: 21.4 258.0 Hornet 4 Drive 20.09062 230.7219 #&gt; 5: 18.7 360.0 Hornet Sportabout 20.09062 230.7219 #&gt; 6: 18.1 225.0 Valiant 20.09062 230.7219 #&gt; 7: 14.3 360.0 Duster 360 20.09062 230.7219 #&gt; 8: 24.4 146.7 Merc 240D 20.09062 230.7219 #&gt; 9: 22.8 140.8 Merc 230 20.09062 230.7219 #&gt; 10: 19.2 167.6 Merc 280 20.09062 230.7219 #&gt; 11: 17.8 167.6 Merc 280C 20.09062 230.7219 #&gt; 12: 16.4 275.8 Merc 450SE 20.09062 230.7219 #&gt; 13: 17.3 275.8 Merc 450SL 20.09062 230.7219 #&gt; 14: 15.2 275.8 Merc 450SLC 20.09062 230.7219 #&gt; 15: 10.4 472.0 Cadillac Fleetwood 20.09062 230.7219 #&gt; 16: 10.4 460.0 Lincoln Continental 20.09062 230.7219 #&gt; 17: 14.7 440.0 Chrysler Imperial 20.09062 230.7219 #&gt; 18: 32.4 78.7 Fiat 128 20.09062 230.7219 #&gt; 19: 30.4 75.7 Honda Civic 20.09062 230.7219 #&gt; 20: 33.9 71.1 Toyota Corolla 20.09062 230.7219 #&gt; 21: 21.5 120.1 Toyota Corona 20.09062 230.7219 #&gt; 22: 15.5 318.0 Dodge Challenger 20.09062 230.7219 #&gt; 23: 15.2 304.0 AMC Javelin 20.09062 230.7219 #&gt; 24: 13.3 350.0 Camaro Z28 20.09062 230.7219 #&gt; 25: 19.2 400.0 Pontiac Firebird 20.09062 230.7219 #&gt; 26: 27.3 79.0 Fiat X1-9 20.09062 230.7219 #&gt; 27: 26.0 120.3 Porsche 914-2 20.09062 230.7219 #&gt; 28: 30.4 95.1 Lotus Europa 20.09062 230.7219 #&gt; 29: 15.8 351.0 Ford Pantera L 20.09062 230.7219 #&gt; 30: 19.7 145.0 Ferrari Dino 20.09062 230.7219 #&gt; 31: 15.0 301.0 Maserati Bora 20.09062 230.7219 #&gt; 32: 21.4 121.0 Volvo 142E 20.09062 230.7219 #&gt; mpg disp cars mean_mpg mean_disp mtcars_df[, .(mean_mpg = mean(mpg), mean_disp = mean(disp))] #&gt; mean_mpg mean_disp #&gt; 1: 20.09062 230.7219 # mtcars_df[, .(mean_mpg := mean(mpg), mean_disp := mean(disp))] # 报错 # 正确的姿势 mtcars_df[, `:=`(mean_mpg = mean(mpg), mean_disp = mean(disp)) ][, .(mpg, disp, mean_mpg, mean_disp)] %&gt;% head() #&gt; mpg disp mean_mpg mean_disp #&gt; 1: 21.0 160 20.09062 230.7219 #&gt; 2: 21.0 160 20.09062 230.7219 #&gt; 3: 22.8 108 20.09062 230.7219 #&gt; 4: 21.4 258 20.09062 230.7219 #&gt; 5: 18.7 360 20.09062 230.7219 #&gt; 6: 18.1 225 20.09062 230.7219 mtcars %&gt;% dplyr::summarise(mean_mpg = mean(mpg), mean_disp = mean(disp)) #&gt; mean_mpg mean_disp #&gt; 1 20.09062 230.7219 mtcars %&gt;% dplyr::mutate(mean_mpg = mean(mpg), mean_disp = mean(disp)) %&gt;% dplyr::select(mpg, disp, mean_mpg, mean_disp) %&gt;% head() #&gt; mpg disp mean_mpg mean_disp #&gt; 1 21.0 160 20.09062 230.7219 #&gt; 2 21.0 160 20.09062 230.7219 #&gt; 3 22.8 108 20.09062 230.7219 #&gt; 4 21.4 258 20.09062 230.7219 #&gt; 5 18.7 360 20.09062 230.7219 #&gt; 6 18.1 225 20.09062 230.7219 7.4 聚合 分组统计 多个分组变量 dcast(mtcars_df, cyl ~ gear, value.var = &quot;mpg&quot;, fun = mean) #&gt; cyl 3 4 5 #&gt; 1: 4 21.50 26.925 28.2 #&gt; 2: 6 19.75 19.750 19.7 #&gt; 3: 8 15.05 NaN 15.4 tapply(mtcars$mpg, list(mtcars$cyl, mtcars$gear), mean) #&gt; 3 4 5 #&gt; 4 21.50 26.925 28.2 #&gt; 6 19.75 19.750 19.7 #&gt; 8 15.05 NA 15.4 mtcars_df[, .(mean_mpg = mean(mpg)), by = .(cyl, gear)] #&gt; cyl gear mean_mpg #&gt; 1: 6 4 19.750 #&gt; 2: 4 4 26.925 #&gt; 3: 6 3 19.750 #&gt; 4: 8 3 15.050 #&gt; 5: 4 3 21.500 #&gt; 6: 4 5 28.200 #&gt; 7: 8 5 15.400 #&gt; 8: 6 5 19.700 aggregate(data = mtcars_df, mpg ~ cyl + gear, FUN = mean) #&gt; cyl gear mpg #&gt; 1 4 3 21.500 #&gt; 2 6 3 19.750 #&gt; 3 8 3 15.050 #&gt; 4 4 4 26.925 #&gt; 5 6 4 19.750 #&gt; 6 4 5 28.200 #&gt; 7 6 5 19.700 #&gt; 8 8 5 15.400 mtcars %&gt;% dplyr::group_by(cyl, gear) %&gt;% dplyr::summarise(mean_mpg = mean(mpg)) #&gt; # A tibble: 8 x 3 #&gt; # Groups: cyl [3] #&gt; cyl gear mean_mpg #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 3 21.5 #&gt; 2 4 4 26.9 #&gt; 3 4 5 28.2 #&gt; 4 6 3 19.8 #&gt; 5 6 4 19.8 #&gt; 6 6 5 19.7 #&gt; # … with 2 more rows 7.5 去重 去掉字段 cyl 和 gear 有重复的记录 mtcars_df[!duplicated(mtcars_df, by = c(&quot;cyl&quot;, &quot;gear&quot;))][,.(mpg, cyl, gear)] #&gt; mpg cyl gear #&gt; 1: 21.0 6 4 #&gt; 2: 22.8 4 4 #&gt; 3: 21.4 6 3 #&gt; 4: 18.7 8 3 #&gt; 5: 21.5 4 3 #&gt; 6: 26.0 4 5 #&gt; 7: 15.8 8 5 #&gt; 8: 19.7 6 5 mtcars %&gt;% dplyr::distinct(cyl, gear, .keep_all = TRUE) %&gt;% dplyr::select(mpg, cyl, gear) #&gt; mpg cyl gear #&gt; 1 21.0 6 4 #&gt; 2 22.8 4 4 #&gt; 3 21.4 6 3 #&gt; 4 18.7 8 3 #&gt; 5 21.5 4 3 #&gt; 6 26.0 4 5 #&gt; 7 15.8 8 5 #&gt; 8 19.7 6 5 dplyr 的去重操作不需要拷贝一个新的数据对象 mtcars_df，并且可以以管道的方式将后续的选择操作连接起来，代码更加具有可读性。 mtcars_df[!duplicated(mtcars_df[, c(&quot;cyl&quot;, &quot;gear&quot;)]), c(&quot;mpg&quot;,&quot;cyl&quot;,&quot;gear&quot;)] #&gt; mpg cyl gear #&gt; 1: 21.0 6 4 #&gt; 2: 22.8 4 4 #&gt; 3: 21.4 6 3 #&gt; 4: 18.7 8 3 #&gt; 5: 21.5 4 3 #&gt; 6: 26.0 4 5 #&gt; 7: 15.8 8 5 #&gt; 8: 19.7 6 5 Base R 和 data.table 提供的 duplicated() 函数和 [ 函数一起实现去重的操作，选择操作放在 [ 实现 [ 其实是一个函数 x &lt;- 2:4 x[1] #&gt; [1] 2 `[`(x, 1) #&gt; [1] 2 7.6 命名 修改列名，另存一份生效 sub_mtcars_df &lt;- mtcars_df[, .(mean_mpg = mean(mpg)), by = .(cyl, gear)] setNames(sub_mtcars_df, c(&quot;cyl&quot;, &quot;gear&quot;, &quot;ave_mpg&quot;)) #&gt; cyl gear ave_mpg #&gt; 1: 6 4 19.750 #&gt; 2: 4 4 26.925 #&gt; 3: 6 3 19.750 #&gt; 4: 8 3 15.050 #&gt; 5: 4 3 21.500 #&gt; 6: 4 5 28.200 #&gt; 7: 8 5 15.400 #&gt; 8: 6 5 19.700 # 注意 sub_mtcars_df 并没有修改列名 sub_mtcars_df #&gt; cyl gear mean_mpg #&gt; 1: 6 4 19.750 #&gt; 2: 4 4 26.925 #&gt; 3: 6 3 19.750 #&gt; 4: 8 3 15.050 #&gt; 5: 4 3 21.500 #&gt; 6: 4 5 28.200 #&gt; 7: 8 5 15.400 #&gt; 8: 6 5 19.700 修改列名并直接起作用，在原来的数据集上生效 setnames(sub_mtcars_df, old = c(&quot;mean_mpg&quot;), new = c(&quot;ave_mpg&quot;)) # sub_mtcars_df 已经修改了列名 sub_mtcars_df #&gt; cyl gear ave_mpg #&gt; 1: 6 4 19.750 #&gt; 2: 4 4 26.925 #&gt; 3: 6 3 19.750 #&gt; 4: 8 3 15.050 #&gt; 5: 4 3 21.500 #&gt; 6: 4 5 28.200 #&gt; 7: 8 5 15.400 #&gt; 8: 6 5 19.700 修改列名最好使用 data.table 包的函数 setnames() 明确指出了要修改的列名， 7.7 排序 按照某（些）列从大到小或从小到大的顺序排列， 先按 cyl 升序，然后按 gear 降序 mtcars_df[, .(mpg, cyl, gear) ][cyl == 4 ][order(cyl, -gear)] #&gt; mpg cyl gear #&gt; 1: 26.0 4 5 #&gt; 2: 30.4 4 5 #&gt; 3: 22.8 4 4 #&gt; 4: 24.4 4 4 #&gt; 5: 22.8 4 4 #&gt; 6: 32.4 4 4 #&gt; 7: 30.4 4 4 #&gt; 8: 33.9 4 4 #&gt; 9: 27.3 4 4 #&gt; 10: 21.4 4 4 #&gt; 11: 21.5 4 3 mtcars %&gt;% dplyr::select(mpg, cyl, gear) %&gt;% dplyr::filter(cyl == 4) %&gt;% dplyr::arrange(cyl, desc(gear)) #&gt; mpg cyl gear #&gt; 1 26.0 4 5 #&gt; 2 30.4 4 5 #&gt; 3 22.8 4 4 #&gt; 4 24.4 4 4 #&gt; 5 22.8 4 4 #&gt; 6 32.4 4 4 #&gt; 7 30.4 4 4 #&gt; 8 33.9 4 4 #&gt; 9 27.3 4 4 #&gt; 10 21.4 4 4 #&gt; 11 21.5 4 3 7.8 变形 melt 宽的变长的 DT &lt;- data.table( i_1 = c(1:5, NA), i_2 = c(NA, 6, 7, 8, 9, 10), f_1 = factor(sample(c(letters[1:3], NA), 6, TRUE)), f_2 = factor(c(&quot;z&quot;, &quot;a&quot;, &quot;x&quot;, &quot;c&quot;, &quot;x&quot;, &quot;x&quot;), ordered = TRUE), c_1 = sample(c(letters[1:3], NA), 6, TRUE), d_1 = as.Date(c(1:3, NA, 4:5), origin = &quot;2013-09-01&quot;), d_2 = as.Date(6:1, origin = &quot;2012-01-01&quot;) ) DT[, .(i_1, i_2, f_1, f_2)] #&gt; i_1 i_2 f_1 f_2 #&gt; 1: 1 NA c z #&gt; 2: 2 6 c a #&gt; 3: 3 7 c x #&gt; 4: 4 8 &lt;NA&gt; c #&gt; 5: 5 9 a x #&gt; 6: NA 10 b x melt(DT, id = 1:2, measure = c(&quot;f_1&quot;, &quot;f_2&quot;)) #&gt; i_1 i_2 variable value #&gt; 1: 1 NA f_1 c #&gt; 2: 2 6 f_1 c #&gt; 3: 3 7 f_1 c #&gt; 4: 4 8 f_1 &lt;NA&gt; #&gt; 5: 5 9 f_1 a #&gt; 6: NA 10 f_1 b #&gt; 7: 1 NA f_2 z #&gt; 8: 2 6 f_2 a #&gt; 9: 3 7 f_2 x #&gt; 10: 4 8 f_2 c #&gt; 11: 5 9 f_2 x #&gt; 12: NA 10 f_2 x dcast 长的变宽的 sleep &lt;- as.data.table(sleep) dcast(sleep, group ~ ID, value.var = &quot;extra&quot;) #&gt; group 1 2 3 4 5 6 7 8 9 10 #&gt; 1: 1 0.7 -1.6 -0.2 -1.2 -0.1 3.4 3.7 0.8 0.0 2.0 #&gt; 2: 2 1.9 0.8 1.1 0.1 -0.1 4.4 5.5 1.6 4.6 3.4 # 如果有多个值 dcast(mtcars_df, cyl ~ gear, value.var = &quot;mpg&quot;) #&gt; Aggregate function missing, defaulting to &#39;length&#39; #&gt; cyl 3 4 5 #&gt; 1: 4 1 8 2 #&gt; 2: 6 2 4 1 #&gt; 3: 8 12 0 2 dcast(mtcars_df, cyl ~ gear, value.var = &quot;mpg&quot;, fun = mean) #&gt; cyl 3 4 5 #&gt; 1: 4 21.50 26.925 28.2 #&gt; 2: 6 19.75 19.750 19.7 #&gt; 3: 8 15.05 NaN 15.4 tidyr 包提供数据变形的函数 tidyr::pivot_longer() 和 tidyr::pivot_wider() 相比于 Base R 提供的 reshape() 和 data.table 提供的 melt() 和 dcast() 更加形象的命名 tidyr::pivot_wider(data = sleep, names_from = &quot;ID&quot;, values_from = &quot;extra&quot;) #&gt; # A tibble: 2 x 11 #&gt; group `1` `2` `3` `4` `5` `6` `7` `8` `9` `10` #&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 0.7 -1.6 -0.2 -1.2 -0.1 3.4 3.7 0.8 0 2 #&gt; 2 2 1.9 0.8 1.1 0.1 -0.1 4.4 5.5 1.6 4.6 3.4 reshape(data = sleep, v.names = &quot;extra&quot;, idvar = &quot;group&quot;, timevar = &quot;ID&quot;, direction = &quot;wide&quot;) #&gt; group extra.1 extra.2 extra.3 extra.4 extra.5 extra.6 extra.7 extra.8 #&gt; 1: 1 0.7 -1.6 -0.2 -1.2 -0.1 3.4 3.7 0.8 #&gt; 2: 2 1.9 0.8 1.1 0.1 -0.1 4.4 5.5 1.6 #&gt; extra.9 extra.10 #&gt; 1: 0.0 2.0 #&gt; 2: 4.6 3.4 idvar 分组变量 timevar 组内编号 v.names 个体观察值 sep 新的列名是由参数 v.names (extra) 和参数值 timevar (ID) 拼接起来的，默认 sep = \".\" 推荐使用下划线来做分割 sep = \"_\" ToothGrowth %&gt;% head #&gt; len supp dose #&gt; 1 4.2 VC 0.5 #&gt; 2 11.5 VC 0.5 #&gt; 3 7.3 VC 0.5 #&gt; 4 5.8 VC 0.5 #&gt; 5 6.4 VC 0.5 #&gt; 6 10.0 VC 0.5 ToothGrowth$time &lt;- rep(1:10, 6) reshape(ToothGrowth, v.names = &quot;len&quot;, idvar = c(&quot;supp&quot;, &quot;dose&quot;), timevar = &quot;time&quot;, direction = &quot;wide&quot;) #&gt; supp dose len.1 len.2 len.3 len.4 len.5 len.6 len.7 len.8 len.9 len.10 #&gt; 1 VC 0.5 4.2 11.5 7.3 5.8 6.4 10.0 11.2 11.2 5.2 7.0 #&gt; 11 VC 1.0 16.5 16.5 15.2 17.3 22.5 17.3 13.6 14.5 18.8 15.5 #&gt; 21 VC 2.0 23.6 18.5 33.9 25.5 26.4 32.5 26.7 21.5 23.3 29.5 #&gt; 31 OJ 0.5 15.2 21.5 17.6 9.7 14.5 10.0 8.2 9.4 16.5 9.7 #&gt; 41 OJ 1.0 19.7 23.3 23.6 26.4 20.0 25.2 25.8 21.2 14.5 27.3 #&gt; 51 OJ 2.0 25.5 26.4 22.4 24.5 24.8 30.9 26.4 27.3 29.4 23.0 以数据集 ToothGrowth 为例，变量 supp（大组），dose（小组） 和 time（组内个体编号） 一起决定唯一的一个数据 len，特别适合纵向数据的变形操作 7.9 分组 分组切片，取每组第一个和最后一个值 Loblolly %&gt;% dplyr::group_by(Seed) %&gt;% dplyr::arrange(height, age, Seed) %&gt;% dplyr::slice(1, dplyr::n()) #&gt; # A tibble: 28 x 3 #&gt; # Groups: Seed [14] #&gt; height age Seed #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;ord&gt; #&gt; 1 3.93 3 329 #&gt; 2 56.4 25 329 #&gt; 3 4.12 3 327 #&gt; 4 56.8 25 327 #&gt; 5 4.38 3 325 #&gt; 6 58.5 25 325 #&gt; # … with 22 more rows dplyr::slice() 和函数 slice.index() 有关系吗？ 7.10 合并 合并操作对应于数据库中的连接操作， dplyr 包的哲学就来源于对数据库操作的进一步抽象， data.table 包的 merge 函数就对应为 dplyr 包的 join 函数 data.table::merge 和 dplyr::join 给出一个表格，数据操作， data.table 实现， dplyr 实现 dt1 &lt;- data.table(A = letters[1:10], X = 1:10, key = &quot;A&quot;) dt2 &lt;- data.table(A = letters[5:14], Y = 1:10, key = &quot;A&quot;) merge(dt1, dt2) # 内连接 #&gt; A X Y #&gt; 1: e 5 1 #&gt; 2: f 6 2 #&gt; 3: g 7 3 #&gt; 4: h 8 4 #&gt; 5: i 9 5 #&gt; 6: j 10 6 参数 key 的作用相当于建立一个索引，通过它实现更快的数据操作速度 key = c(\"x\",\"y\",\"z\") 或者 key = \"x,y,z\" 其中 x,y,z 是列名 data(band_members, band_instruments, package = &quot;dplyr&quot;) band_members #&gt; # A tibble: 3 x 2 #&gt; name band #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Mick Stones #&gt; 2 John Beatles #&gt; 3 Paul Beatles band_instruments #&gt; # A tibble: 3 x 2 #&gt; name plays #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 John guitar #&gt; 2 Paul bass #&gt; 3 Keith guitar dplyr::inner_join(band_members, band_instruments) #&gt; Joining, by = &quot;name&quot; #&gt; # A tibble: 2 x 3 #&gt; name band plays #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 John Beatles guitar #&gt; 2 Paul Beatles bass list 列表里每个元素都是 data.frame 时，最适合用 data.table::rbindlist 合并 # 合并列表 https://recology.info/2018/10/limiting-dependencies/ function(x) { tibble::as_tibble((x &lt;- data.table::setDF( data.table::rbindlist(x, use.names = TRUE, fill = TRUE, idcol = &quot;id&quot;)) )) } #&gt; function(x) { #&gt; tibble::as_tibble((x &lt;- data.table::setDF( #&gt; data.table::rbindlist(x, use.names = TRUE, fill = TRUE, idcol = &quot;id&quot;)) #&gt; )) #&gt; } "],
["data-parallel.html", "第 8 章 并行化操作 8.1 apply 8.2 MapReduce 8.3 parallel 8.4 Rmpi 8.5 gpuR 8.6 本章运行环境", " 第 8 章 并行化操作 向量化运算、并行运算和分布式运算 future 在 R 语言中提供统一的并行和分布式处理框架 future.apply 可以替代 base R 提供的 apply 族函数 future.batchtools 使用 batchtools 实现并行和分布式处理 batchtools Map 函数的并行实现，用于高性能计算系统和分布式处理，可以单机多核并行也可以多机并行，还提供了一种抽象的机制去定义大规模计算机实验。 multidplyr 是 dplyr 的后端，多核环境下实现数据分块，提高并行处理性能 disk.frame 是基于磁盘的超出内存容量的快速并行数据操作框架 parallelMap R package to interface some popular parallelization back-ends with a unified interface big.data.table 基于 data.table 的分布式并行计算 8.1 apply apply 家族和 do.call 8.2 MapReduce 高阶函数，简单来说，就是参数为函数，返回值也是函数。Base R 提供了 Reduce 、Filter 、Find 、Map 、Negate 和 Position 等常用函数，此外还有 *apply 族，我们把它放在第??小节向量化计算中介绍。 与 purrr::map 比较 在 R 语言里玩转apply， Map() 和 Reduce()27，下面分别以提取合并多张 XLSX 表格28，分组计算29 和子集操作30 为例，从函数式编程到 MapReduce31，制作数据透视表32，用于数据处理的函数式编程和单元测试 Functional programming and unit testing for data munging with R 特别是第三章 https://b-rodrigues.github.io/fput/，然后是函数式编程与数据建模 Modeling data with functional programming in R33 add &lt;- function(x) Reduce(&quot;+&quot;, x) add(list(1, 2, 3)) #&gt; [1] 6 add_accuml &lt;- function(x) Reduce(&quot;+&quot;, x, accumulate = TRUE) add_accuml(list(1, 2, 3)) #&gt; [1] 1 3 6 8.3 parallel 并行计算小抄 将共享内存的 R 包整理在一起 library(parallel) 8.4 Rmpi Rmpi 由卡尔顿大学的 Hao Yu 开发和维护 首先安装 openmpi-devel 开发环境（以 Fedora 30 为例） yum install -y openmpi-devel echo &quot;export ORTED=/usr/lib64/openmpi/bin&quot; &gt;&gt; ~/.bashrc # 或者 echo &quot;PATH=/usr/lib64/openmpi/bin:$PATH; export PATH&quot; | tee -a ~/.bashrc source ~/.bashrc 然后进入 R 安装 R 包 Rmpi install.packages(&#39;Rmpi&#39;) 使用 Rmpi 包生成两组服从均匀分布的随机数 # 加载 R 包 library(Rmpi) # 检测可用的逻辑 CPU 核心数 parallel::detectCores() # 虚拟机分配四个逻辑CPU核 # 1个 master 2个 worker 主机 cloud mpi.spawn.Rslaves(nslaves=2) # 2 slaves are spawned successfully. 0 failed. # master (rank 0, comm 1) of size 3 is running on: cloud # slave1 (rank 1, comm 1) of size 3 is running on: cloud # slave2 (rank 2, comm 1) of size 3 is running on: cloud 调用 mpi.apply 函数 set.seed(1234) mpi.apply(c(10, 20), runif) [[1]] [1] 0.33684269 0.84638494 0.82776590 0.23707947 0.07593769 0.27981368 [7] 0.45307675 0.02878214 0.32807421 0.92854275 [[2]] [1] 0.63474442 0.04025071 0.01996498 0.01922093 0.41258827 0.84150414 [7] 0.74705002 0.07635368 0.32807392 0.94570363 0.89187667 0.67069020 [13] 0.92996997 0.22486589 0.22118236 0.15807970 0.65619450 0.16473730 [19] 0.85833484 0.11416449 用完要关闭 mpi.close.Rslaves() pbdMPI 包处于活跃维护状态，是 pbdR 项目 的核心组件，能够以分布式计算的方式轻松处理 TB 级数据34 Rhpc 包同样基于 MPI 方式，但是集 Rmpi 和 snow 两个包的优点于一身，在保持 apply 编程风格的同时，能够提供更好的高性能计算环境，支持长向量，能够处理一些大数据。 8.5 gpuR Charles Determan 开发的 gpuR (???) 基于 OpenCL 加速，目前处于活跃维护状态。而 Charles Determan 开发的另一个 gpuRcuda 包是基于 CUDA 加速 赵鹏 的博客 ParallelR 关注基于 CUDA 的 GPU 加速 此外还有 gputools library(gpuR) set.seed(2019) gpuA &lt;- gpuMatrix(rnorm(16), nrow = 4, ncol = 4) gpuA An object of class &quot;fgpuMatrix&quot; Slot &quot;address&quot;: &lt;pointer: 0x000000000fbe9760&gt; Slot &quot;.context_index&quot;: [1] 1 Slot &quot;.platform_index&quot;: [1] 1 Slot &quot;.platform&quot;: [1] &quot;Intel(R) OpenCL&quot; Slot &quot;.device_index&quot;: [1] 1 Slot &quot;.device&quot;: [1] &quot;Intel(R) HD Graphics 4600&quot; gpuB &lt;- gpuA %*% gpuA print(gpuB) Source: gpuR Matrix [4 x 4] [,1] [,2] [,3] [,4] [1,] 2.61787200 -1.274909 -2.150301 -2.0073860 [2,] -0.02231596 1.566433 0.986027 0.7339008 [3,] -0.12862393 1.848340 3.261899 1.6919358 [4,] -1.90084898 -1.863014 -1.312350 -0.2553876 8.6 本章运行环境 xfun::session_info() #&gt; R Under development (unstable) (2020-02-04 r77771) #&gt; Platform: x86_64-pc-linux-gnu (64-bit) #&gt; Running under: Ubuntu 16.04.6 LTS #&gt; #&gt; Locale: #&gt; LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C #&gt; LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 #&gt; LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 #&gt; LC_PAPER=en_US.UTF-8 LC_NAME=C #&gt; LC_ADDRESS=C LC_TELEPHONE=C #&gt; LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C #&gt; #&gt; Package version: #&gt; base64enc_0.1.3 bookdown_0.17 compiler_4.0.0 curl_4.3 #&gt; digest_0.6.23 evaluate_0.14 glue_1.3.1 graphics_4.0.0 #&gt; grDevices_4.0.0 highr_0.8 htmltools_0.4.0 jsonlite_1.6.1 #&gt; knitr_1.26 magrittr_1.5 markdown_1.1 methods_4.0.0 #&gt; mime_0.9 Rcpp_1.0.3 rlang_0.4.4 rmarkdown_2.1 #&gt; stats_4.0.0 stringi_1.4.5 stringr_1.4.0 tinytex_0.19 #&gt; tools_4.0.0 utils_4.0.0 xfun_0.12 yaml_2.2.1 https://stackoverflow.com/questions/3505701/grouping-functions-tapply-by-aggregate-and-the-apply-family↩︎ https://trinkerrstuff.wordpress.com/2018/02/14/easily-make-multi-tabbed-xlsx-files-with-openxlsx/↩︎ https://statcompute.wordpress.com/2018/09/03/playing-map-and-reduce-in-r-by-group-calculation/↩︎ https://statcompute.wordpress.com/2018/09/08/playing-map-and-reduce-in-r-subsetting/↩︎ https://cartesianfaith.com/2015/09/17/from-functional-programming-to-mapreduce-in-r/↩︎ https://digitheadslabnotebook.blogspot.com/2010/01/pivot-tables-in-r.html↩︎ https://cartesianfaith.files.wordpress.com/2015/12/rowe-modeling-data-with-functional-programming-in-r.pdf↩︎ 2016年国际 R 语言大会上的介绍https://github.com/snoweye/user2016.demo 和2018年 JSM 会 上的介绍 https://github.com/RBigData/R_JSM2018↩︎ "],
["dc-string-manipulation.html", "第 9 章 字符串操作 9.1 字符数统计 9.2 字符串翻译 9.3 字符串连接 9.4 字符串拆分 9.5 字符串匹配 9.6 字符串查询 9.7 字符串替换 9.8 字符串提取 9.9 命名捕捉 9.10 精确匹配 9.11 模糊匹配 9.12 高级的替换 9.13 高级的提取 9.14 其它操作 9.15 运行环境", " 第 9 章 字符串操作 字符和字符串类型的数据值得单独拿出来讲，不仅因为内容多，而且比较难，应用范围最广，特别是面对文本类型的数据时，几乎是避不开的！R 的前身是 S，S 的前身是一些 Fortran 和 C 子程序，最早在贝尔实验室是用于文本分析领域，因此在 R 基础包中提供了丰富的字符串处理函数，你可以在R控制台中执行如下一行命令查看 help.search(keyword = &quot;character&quot;, package = &quot;base&quot;) 本章主要介绍 R 内置的字符串操作函数 9.1 字符数统计 nchar 函数统计字符串向量中每个元素的字符个数，注意与函数length 的差别，它统计向量中元素的个数，即向量的长度。 nchar(c(&quot;Hello&quot;, &quot;world&quot;, &quot;!&quot;)) #&gt; [1] 5 5 1 R.version.string #&gt; [1] &quot;R Under development (unstable) (2020-02-04 r77771)&quot; nchar(R.version.string) #&gt; [1] 50 deparse(base::mean) #&gt; [1] &quot;function (x, ...) &quot; &quot;UseMethod(\\&quot;mean\\&quot;)&quot; nchar(deparse(base::mean)) #&gt; [1] 18 17 一些特殊的情况 nchar(&quot;&quot;) #&gt; [1] 0 nchar(NULL) #&gt; integer(0) nchar(0) #&gt; [1] 1 pi #&gt; [1] 3.141593 nchar(pi) #&gt; [1] 16 exp(1) #&gt; [1] 2.718282 nchar(exp(1)) #&gt; [1] 16 nchar(NA) #&gt; [1] NA 9.2 字符串翻译 tolower 将字符串或字符串向量中含有的大写字母全都转化为小写， toupper 函数正好与之相反. tolower(c(&quot;HELLO&quot;, &quot;Hello, R&quot;, &quot;hello&quot;)) #&gt; [1] &quot;hello&quot; &quot;hello, r&quot; &quot;hello&quot; toupper(c(&quot;HELLO&quot;, &quot;Hello, R&quot;, &quot;hello&quot;)) #&gt; [1] &quot;HELLO&quot; &quot;HELLO, R&quot; &quot;HELLO&quot; 9.3 字符串连接 paste 函数设置参数 sep 作为连接符，设置参数 collapse 可以将字符串拼接后连成一个字符串 paste(&quot;A&quot;, &quot;B&quot;, sep = &quot;&quot;) #&gt; [1] &quot;AB&quot; paste(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), 1:3, sep = &quot;-&quot;) #&gt; [1] &quot;A-1&quot; &quot;B-2&quot; &quot;C-3&quot; paste(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), 1:3, sep = &quot;-&quot;, collapse = &quot;;&quot;) #&gt; [1] &quot;A-1;B-2;C-3&quot; paste0 相当于 sep 设为空，没有连接符 paste0(&quot;A&quot;, &quot;B&quot;) #&gt; [1] &quot;AB&quot; paste0(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), 1:3) #&gt; [1] &quot;A1&quot; &quot;B2&quot; &quot;C3&quot; paste0(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), 1:3, collapse = &quot;;&quot;) #&gt; [1] &quot;A1;B2;C3&quot; 9.4 字符串拆分 strsplit(x, split, fixed = FALSE, perl = FALSE, useBytes = FALSE) strsplit 函数用于字符串拆分，参数 x 是被拆分的字符串向量，其每个元素都会被拆分，而参数 split 表示拆分的位置，可以用正则表达式来描述位置，拆分的结果是一个列表。 参数 fixed 默认设置 fixed = FALSE 表示正则表达式匹配，而 fixed = TRUE 表示正则表达式的精确匹配或者按文本字符的字面意思匹配，即按普通文本匹配。我们知道按普通文本匹配速度快。 当启用 perl = TRUE 时，由 PCRE_use_JIT 控制细节。perl 参数的设置与 Perl 软件版本有关，如果正则表达式很长，除了正确设置正则表达式，使用 perl = TRUE 可以提高运算速度 参数 useBytes 设置是否按照逐个字节地进行匹配，默认设置为 FALSE，即按照字符而不是字节进行匹配 x &lt;- c(as = &quot;asfef&quot;, qu = &quot;qwerty&quot;, &quot;yuiop[&quot;, &quot;b&quot;, &quot;stuff.blah.yech&quot;) # 按字母 e 拆分字符串向量 x strsplit(x, &quot;e&quot;) #&gt; $as #&gt; [1] &quot;asf&quot; &quot;f&quot; #&gt; #&gt; $qu #&gt; [1] &quot;qw&quot; &quot;rty&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;yuiop[&quot; #&gt; #&gt; [[4]] #&gt; [1] &quot;b&quot; #&gt; #&gt; [[5]] #&gt; [1] &quot;stuff.blah.y&quot; &quot;ch&quot; 参数 split 支持通过正则表达式的方式指明拆分位置 # 默认将点号 . 看作一个正则表达式，它是一个元字符，匹配任意字符 strsplit(&quot;a.b.c&quot;, &quot;.&quot;) #&gt; [[1]] #&gt; [1] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; # 这才是按点号拆分 strsplit(&quot;a.b.c&quot;, &quot;.&quot;, fixed = TRUE) #&gt; [[1]] #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; # 或者 strsplit(&quot;a.b.c&quot;, &quot;[.]&quot;) #&gt; [[1]] #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; # 或者转义点号，去掉元字符的特殊意义 strsplit(&quot;a.b.c&quot;, &quot;\\\\.&quot;) #&gt; [[1]] #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; 这里介绍一个将字符串逆序的函数 str_rev str_rev &lt;- function(x) sapply(lapply(strsplit(x, NULL), rev), paste, collapse = &quot;&quot;) str_rev(c(&quot;abc&quot;, &quot;Statistics&quot;)) #&gt; [1] &quot;cba&quot; &quot;scitsitatS&quot; 为了加深理解，再举几个例子 # 最后一个空字符没有产生 strsplit(paste(c(&quot;&quot;, &quot;a&quot;, &quot;&quot;), collapse=&quot;#&quot;), split=&quot;#&quot;) #&gt; [[1]] #&gt; [1] &quot;&quot; &quot;a&quot; # 空字符只有有定义的时候才会产生 strsplit(&quot;&quot;, &quot; &quot;) #&gt; [[1]] #&gt; character(0) strsplit(&quot; &quot;, &quot; &quot;) #&gt; [[1]] #&gt; [1] &quot;&quot; 9.5 字符串匹配 agrep 和 agrepl 函数做近似（模糊）匹配 (Approximate Matching or Fuzzy Matching) ，对于匹配，考虑到参数 pattern 在参数 x 中匹配时，允许参数值x存在最小可能的插入、删除和替换，这种修改叫做Levenshtein 编辑距离，max.distance 控制其细节 agrep(pattern, x, max.distance = 0.1, costs = NULL, ignore.case = FALSE, value = FALSE, fixed = TRUE, useBytes = FALSE) agrepl(pattern, x, max.distance = 0.1, costs = NULL, ignore.case = FALSE, fixed = TRUE, useBytes = FALSE) agrep 函数返回 pattern 在 x 中匹配到的一个位置向量，agrepl 返回一个逻辑向量，这一点类似 grep 和 grepl 这对函数，下面举例子说明 agrep(&quot;lasy&quot;, &quot;1 lazy 2&quot;) #&gt; [1] 1 # sub = 0 表示匹配时不考虑替换 agrep(&quot;lasy&quot;, c(&quot; 1 lazy 2&quot;, &quot;1 lasy 2&quot;), max = list(sub = 0)) #&gt; [1] 2 # 默认设置下，匹配时区分大小写 agrep(&quot;laysy&quot;, c(&quot;1 lazy&quot;, &quot;1&quot;, &quot;1 LAZY&quot;), max = 2) #&gt; [1] 1 # 返回匹配到值，而不是位置下标，类似 grep(..., value = TRUE) 的返回值 agrep(&quot;laysy&quot;, c(&quot;1 lazy&quot;, &quot;1&quot;, &quot;1 LAZY&quot;), max = 2, value = TRUE) #&gt; [1] &quot;1 lazy&quot; # 不区分大小写 agrep(&quot;laysy&quot;, c(&quot;1 lazy&quot;, &quot;1&quot;, &quot;1 LAZY&quot;), max = 2, ignore.case = TRUE) #&gt; [1] 1 3 startsWith(x, prefix) endsWith(x, suffix) startsWith 和 endsWith 函数用来匹配字符串的前缀和后缀，返回值是一个逻辑向量，参数 prefix 和 suffix 不要包含特殊的正则表达式字符，如点号.，举例子 # 字符串向量 search() #&gt; [1] &quot;.GlobalEnv&quot; &quot;package:stats&quot; &quot;package:graphics&quot; #&gt; [4] &quot;package:grDevices&quot; &quot;package:utils&quot; &quot;package:datasets&quot; #&gt; [7] &quot;package:methods&quot; &quot;Autoloads&quot; &quot;package:base&quot; # 匹配以 package: 开头的字符串 startsWith(search(), &quot;package:&quot;) #&gt; [1] FALSE TRUE TRUE TRUE TRUE TRUE TRUE FALSE TRUE # 或者 grepl(&quot;^package:&quot;, search()) #&gt; [1] FALSE TRUE TRUE TRUE TRUE TRUE TRUE FALSE TRUE 当前目录下，列出扩展名为 .Rmd 的文件 # list.files(path = &quot;.&quot;, pattern = &quot;\\\\.Rmd$&quot;) # 而不是 endsWith(list.files(), &quot;\\\\.Rmd&quot;) endsWith(list.files(), &quot;.Rmd&quot;) #&gt; [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE #&gt; [13] TRUE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE #&gt; [25] FALSE TRUE FALSE FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE FALSE #&gt; [37] TRUE FALSE FALSE FALSE TRUE FALSE FALSE TRUE FALSE TRUE TRUE FALSE #&gt; [49] FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE TRUE #&gt; [61] FALSE FALSE TRUE TRUE FALSE FALSE TRUE FALSE FALSE TRUE FALSE TRUE #&gt; [73] FALSE TRUE FALSE FALSE TRUE FALSE FALSE FALSE TRUE FALSE FALSE FALSE #&gt; [85] FALSE TRUE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE #&gt; [97] TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE #&gt; [109] FALSE # 或者 grepl(&quot;\\\\.Rmd$&quot;, list.files()) #&gt; [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE #&gt; [13] TRUE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE #&gt; [25] FALSE TRUE FALSE FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE FALSE #&gt; [37] TRUE FALSE FALSE FALSE TRUE FALSE FALSE TRUE FALSE TRUE TRUE FALSE #&gt; [49] FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE TRUE #&gt; [61] FALSE FALSE TRUE TRUE FALSE FALSE TRUE FALSE FALSE TRUE FALSE TRUE #&gt; [73] FALSE TRUE FALSE FALSE TRUE FALSE FALSE FALSE TRUE FALSE FALSE FALSE #&gt; [85] FALSE TRUE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE #&gt; [97] TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE #&gt; [109] FALSE 部分匹配(Partial String Matching) match(x, table, nomatch = NA_integer_, incomparables = NULL) x %in% table charmatch(x, table, nomatch = NA_integer_) pmatch(x, table, nomatch = NA_integer_, duplicates.ok = FALSE) 这几个 match 函数的返回值都是一个向量，每个元素是参数x在参数table中第一次匹配到的位置，charmatch 与 pmatch(x, table, nomatch = NA_integer_, duplicates.ok = TRUE) 类似，所以 pmatch 在默认 duplicates.ok = FALSE 的情况下，若x在第二个参数table中有多次匹配就会返回 NA，因此，实际上 pmatch 只允许在第二个参数中匹配一次 match(&quot;xx&quot;, c(&quot;abc&quot;, &quot;xx&quot;, &quot;xxx&quot;, &quot;xx&quot;)) #&gt; [1] 2 1:10 %in% c(1,3,5,9) #&gt; [1] TRUE FALSE TRUE FALSE TRUE FALSE FALSE FALSE TRUE FALSE # charmatch 就比较奇怪，规则太多 charmatch(&quot;&quot;, &quot;&quot;) # returns 1 #&gt; [1] 1 # 多个精确匹配到，或者多个部分匹配到，则返回 0 charmatch(&quot;m&quot;, c(&quot;mean&quot;, &quot;median&quot;, &quot;mode&quot;, &quot;quantile&quot;)) # returns 0 #&gt; [1] 0 # med 只在table参数值的第二个位置部分匹配到，所以返回2 charmatch(&quot;med&quot;, c(&quot;mean&quot;, &quot;median&quot;, &quot;mode&quot;, &quot;quantile&quot;)) # returns 2 #&gt; [1] 2 charmatch(&quot;xx&quot;, &quot;xx&quot;) #&gt; [1] 1 charmatch(&quot;xx&quot;, &quot;xxa&quot;) #&gt; [1] 1 charmatch(&quot;xx&quot;, &quot;axx&quot;) #&gt; [1] NA # 注意比较与 charmatch 的不同 pmatch(&quot;&quot;, &quot;&quot;) # returns NA #&gt; [1] NA pmatch(&quot;m&quot;, c(&quot;mean&quot;, &quot;median&quot;, &quot;mode&quot;)) # returns NA #&gt; [1] NA pmatch(&quot;med&quot;, c(&quot;mean&quot;, &quot;median&quot;, &quot;mode&quot;)) # returns 2 #&gt; [1] 2 9.6 字符串查询 grep(pattern, x, ignore.case = FALSE, perl = FALSE, value = FALSE, fixed = FALSE, useBytes = FALSE, invert = FALSE ) grepl(pattern, x, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE ) grep 和 grepl 是一对字符串查询函数，查看字符串向量 x 中是否包含正则表达式 pattern 描述的内容 ignore.case: TRUE 表示忽略大小写，FALSE 表示匹配的时候区分大小写 fixed = TRUE 表示启用 literal regular expression 字面正则表达式，默认情况下fixed = FALSE grep 函数返回匹配到的字符串向量x的元素的下标，如果 value=TRUE 则返回下标对应的值 grepl 函数返回一个逻辑向量，检查字符串向量x中的每个元素是否匹配到，匹配到返回 TRUE，没有匹配到返回 FALSE # 返回下标位置 grep(&quot;[a-z]&quot;, letters) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #&gt; [26] 26 # 返回查询到的值 grep(&quot;[a-z]&quot;, letters, value = TRUE) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; #&gt; [19] &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; 继续举例子 grep(x = c(&quot;apple&quot;, &quot;banana&quot;), pattern = &quot;a&quot;) #&gt; [1] 1 2 grep(x = c(&quot;apple&quot;, &quot;banana&quot;), pattern = &quot;b&quot;) #&gt; [1] 2 grep(x = c(&quot;apple&quot;, &quot;banana&quot;), pattern = &quot;a&quot;, value = TRUE) #&gt; [1] &quot;apple&quot; &quot;banana&quot; grep(x = c(&quot;apple&quot;, &quot;banana&quot;), pattern = &quot;b&quot;, value = TRUE) #&gt; [1] &quot;banana&quot; 关于 grepl 函数的使用例子 grepl(x = c(&quot;apple&quot;, &quot;banana&quot;), pattern = &quot;a&quot;) #&gt; [1] TRUE TRUE grepl(x = c(&quot;apple&quot;, &quot;banana&quot;), pattern = &quot;b&quot;) #&gt; [1] FALSE TRUE R 语言是用字符串来表示正则表达式的，但是正则表达式不是字符串，字符串的构造类似算术表达式 在 R 里面分别表示 a\\\\b 和 a\\b writeLines(c(&quot;a\\\\\\\\b&quot;, &quot;a\\\\b&quot;)) #&gt; a\\\\b #&gt; a\\b 下面在 R 里面分别匹配字符串 a\\\\b 和 a\\b 中的 \\\\ 和 \\ # 匹配字符串中的一个反斜杠 grep(x = c(&quot;a\\\\\\\\b&quot;, &quot;a\\\\b&quot;), pattern = &quot;\\\\&quot;, value = TRUE, fixed = TRUE) #&gt; [1] &quot;a\\\\\\\\b&quot; &quot;a\\\\b&quot; grep(x = c(&quot;a\\\\\\\\b&quot;, &quot;a\\\\b&quot;), pattern = &quot;\\\\\\\\&quot;, value = TRUE, fixed = FALSE) #&gt; [1] &quot;a\\\\\\\\b&quot; &quot;a\\\\b&quot; # 匹配字符串中的两个反斜杠 grep(x = c(&quot;a\\\\\\\\b&quot;, &quot;a\\\\b&quot;), pattern = &quot;\\\\\\\\&quot;, value = TRUE, fixed = TRUE) #&gt; [1] &quot;a\\\\\\\\b&quot; grep(x = c(&quot;a\\\\\\\\b&quot;, &quot;a\\\\b&quot;), pattern = &quot;\\\\\\\\\\\\\\\\&quot;, value = TRUE, fixed = FALSE) #&gt; [1] &quot;a\\\\\\\\b&quot; # 匹配字符串中的两个反斜杠 \\\\ grepl(x = &quot;a\\\\\\\\b&quot;, pattern = &quot;\\\\\\\\\\\\\\\\&quot;, fixed = FALSE) #&gt; [1] TRUE grepl(x = &quot;a\\\\\\\\b&quot;, pattern = &quot;\\\\\\\\\\\\\\\\&quot;, fixed = TRUE) #&gt; [1] FALSE grepl(x = &quot;a\\\\\\\\b&quot;, pattern = &quot;\\\\\\\\&quot;, fixed = TRUE) #&gt; [1] TRUE regexpr(pattern, text, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE ) gregexpr(pattern, text, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE ) regexec(pattern, text, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE ) 当启用 perl=TRUE 时， 函数 regexpr 和 gregexpr 支持 Python 环境下的命名捕获(named captures)，但是不支持长向量的输入。如果一个分组被命名了，如 (?&lt;first&gt;[A-Z][a-z]+) 那么匹配到的位置按命名返回。函数 sub 不支持命名反向引用 (Named backreferences) 函数 regmatches 用来提取函数regexpr, gregexpr 和 regexec 匹配到的子字符串 useBytes = FALSE 匹配位置和长度默认是按照字符级别来的，如果 useBytes = TRUE 则是按照逐个字节的匹配结果 如果使用到了 命名捕获 则会返回更多的属性 “capture.start”，“capture.length” 和 “capture.names”，分别表示捕获的起始位置、捕获的长度和捕获的命名。 regexpr 函数返回一个整型向量，第一次匹配的初始位置，-1 表示没有匹配到，返回的属性 match.length 表示匹配的字符数量，是一个整型向量，向量长度是匹配的文本的长度，-1 表示没有匹配到 text &lt;- c(&quot;Hellow, Adam!&quot;, &quot;Hi, Adam!&quot;, &quot;How are you, Adam.&quot;) regexpr(&quot;Adam&quot;, text) #&gt; [1] 9 5 14 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 4 4 4 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE txt &lt;- c( &quot;The&quot;, &quot;licenses&quot;, &quot;for&quot;, &quot;most&quot;, &quot;software&quot;, &quot;are&quot;, &quot;designed&quot;, &quot;to&quot;, &quot;take&quot;, &quot;away&quot;, &quot;your&quot;, &quot;freedom&quot;, &quot;to&quot;, &quot;share&quot;, &quot;and&quot;, &quot;change&quot;, &quot;it.&quot;, &quot;&quot;, &quot;By&quot;, &quot;contrast,&quot;, &quot;the&quot;, &quot;GNU&quot;, &quot;General&quot;, &quot;Public&quot;, &quot;License&quot;, &quot;is&quot;, &quot;intended&quot;, &quot;to&quot;, &quot;guarantee&quot;, &quot;your&quot;, &quot;freedom&quot;, &quot;to&quot;, &quot;share&quot;, &quot;and&quot;, &quot;change&quot;, &quot;free&quot;, &quot;software&quot;, &quot;--&quot;, &quot;to&quot;, &quot;make&quot;, &quot;sure&quot;, &quot;the&quot;, &quot;software&quot;, &quot;is&quot;, &quot;free&quot;, &quot;for&quot;, &quot;all&quot;, &quot;its&quot;, &quot;users&quot; ) # gregexpr(&quot;en&quot;, txt) regexpr(&quot;en&quot;, txt) #&gt; [1] -1 4 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 2 -1 4 #&gt; [26] -1 4 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] -1 2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 2 -1 2 #&gt; [26] -1 2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE gregexpr 函数返回一个列表，返回列表的长度与字符串向量的长度一样，列表中每个元素的形式与 regexpr 的返回值一样, except that the starting positions of every (disjoint) match are given. gregexpr(&quot;Adam&quot;, text) #&gt; [[1]] #&gt; [1] 9 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 4 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE #&gt; #&gt; [[2]] #&gt; [1] 5 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 4 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE #&gt; #&gt; [[3]] #&gt; [1] 14 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 4 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE regexec 函数返回一个列表，类似函数gregexpr的返回结果，长度与字符串向量的长度一样，如果没有匹配到就返回 -1，匹配到了就返回一个匹配的初值位置的整型序列，所有子字符串与括号分组的正则表达式的子表达式对应，属性 “match.length” 是一个表示匹配的长度的向量，如果是 -1 表示没有匹配到。位置、长度和属性的解释与 regexpr 一致 regexec(&quot;Adam&quot;, text) #&gt; [[1]] #&gt; [1] 9 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 4 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE #&gt; #&gt; [[2]] #&gt; [1] 5 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 4 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE #&gt; #&gt; [[3]] #&gt; [1] 14 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 4 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE 由于资源限制（特别是 PCRE）导致的匹配失败，会视为没有匹配，通常伴随一个警告 下面这个将链接分解的例子由 Luke Tierney 提供35 x &lt;- &quot;http://stat.umn.edu:80/xyz&quot; m &lt;- regexec(&quot;^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*)&quot;, x) m #&gt; [[1]] #&gt; [1] 1 1 1 8 20 21 23 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 26 7 4 12 3 2 4 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE 这里 x 是一个字符串，所以函数 regexec 返回的列表长度为1，正则表达式 ^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*) 括号分组匹配到了7次，第一次匹配整个字符串，所以起始位置是1，而匹配长度是26，即整个字符串的长度，读者可以调用函数 nchar(x) 算一下，如果你愿意手动数一下也可以哈！余下不一一介绍，可以根据返回结果和图9.1一起看，最后还可以调用regmatches函数抽取匹配到的结果 regmatches(x, m) #&gt; [[1]] #&gt; [1] &quot;http://stat.umn.edu:80/xyz&quot; &quot;http://&quot; #&gt; [3] &quot;http&quot; &quot;stat.umn.edu&quot; #&gt; [5] &quot;:80&quot; &quot;80&quot; #&gt; [7] &quot;/xyz&quot; 我们可以在 https://regex101.com/ 上测试表达式，如图9.1所示，表达式 ^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*) 包含7个组，每个组的匹配结果见图的右下角，这样我们不难理解，函数 regmatches 返回的第列表中，第3个位置是传输协议 protocol http ，第4个位置是主机 host stat.umn.edu， 第6个位置是端口 port 80 ，第7个位置是路径 path /xyz，所以函数 regmatches 的作用就是根据函数 regexec 匹配的结果抽取子字符串。 图 9.1: 正则表达式匹配结果 进一步，我们可以用 regmatches 函数抽取 URL 的部分内容，如前面提到的传输协议，主机等 URL_parts &lt;- function(x) { m &lt;- regexec(&quot;^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*)&quot;, x) parts &lt;- do.call( rbind, lapply(regmatches(x, m), `[`, c(3L, 4L, 6L, 7L)) # 3,4,6,7是索引位置 ) colnames(parts) &lt;- c(&quot;protocol&quot;, &quot;host&quot;, &quot;port&quot;, &quot;path&quot;) parts } URL_parts(x) #&gt; protocol host port path #&gt; [1,] &quot;http&quot; &quot;stat.umn.edu&quot; &quot;80&quot; &quot;/xyz&quot; 目前还没有 gregexec 函数，但是可以模拟一个，首先用 gregexpr 函数返回匹配的位置，regmatches 抽取相应的值，然后用 regexec 作用到每一个提取的值，做再一次匹配和值的抽取，实现了全部的匹配。另一个例子 ## There is no gregexec() yet, but one can emulate it by running ## regexec() on the regmatches obtained via gregexpr(). E.g.: pattern &lt;- &quot;([[:alpha:]]+)([[:digit:]]+)&quot; s &lt;- &quot;Test: A1 BC23 DEF456&quot; gregexpr(pattern, s) #&gt; [[1]] #&gt; [1] 7 10 15 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 2 4 6 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE regmatches(s, gregexpr(pattern, s)) #&gt; [[1]] #&gt; [1] &quot;A1&quot; &quot;BC23&quot; &quot;DEF456&quot; lapply( regmatches(s, gregexpr(pattern, s)), function(e) regmatches(e, regexec(pattern, e)) ) #&gt; [[1]] #&gt; [[1]][[1]] #&gt; [1] &quot;A1&quot; &quot;A&quot; &quot;1&quot; #&gt; #&gt; [[1]][[2]] #&gt; [1] &quot;BC23&quot; &quot;BC&quot; &quot;23&quot; #&gt; #&gt; [[1]][[3]] #&gt; [1] &quot;DEF456&quot; &quot;DEF&quot; &quot;456&quot; 9.7 字符串替换 chartr 支持正则表达式的替换，chartr 是对应字符的替换操作 x &lt;- &quot;MiXeD cAsE 123&quot; # 将字符 iXs 替换为 why chartr(&quot;iXs&quot;, &quot;why&quot;, x) #&gt; [1] &quot;MwheD cAyE 123&quot; # 将字符串 a-cX 中的字符挨个对应地替换为 D-Fw chartr(&quot;a-cX&quot;, &quot;D-Fw&quot;, x) #&gt; [1] &quot;MiweD FAsE 123&quot; 两个 *sub 函数的区别：sub 替换第一次匹配到的结果，gsub 替换所有匹配的结果 sub(&quot; .*&quot;, &quot;&quot;, extSoftVersion()[&quot;PCRE&quot;]) #&gt; PCRE #&gt; &quot;8.38&quot; 参数 replacement 的值是正则表达式，其包含反向引用的用法， \\\\1 即引用表达式 ([ab]) gsub(pattern = &quot;([ab])&quot;, replacement = &quot;\\\\1_\\\\1_&quot;, x = &quot;abc and ABC&quot;) #&gt; [1] &quot;a_a_b_b_c a_a_nd ABC&quot; 9.8 字符串提取 substr(x, start, stop) substring(text, first, last = 1000000L) substr 和 substring 函数通过位置进行字符串的拆分和提取，它们本身不使用正则表达式，结合其他正则表达式函数regexpr, gregexpr 和 regexec，可以很方便地从大量文本中提取所需的信息。作用类似之前提到的 regmatches 函数 参数设置基本相同 x/text 是要拆分的字符串向量 start/first 截取的起始位置向量 stop/last 截取的终止位置向量 返回值有差别 substr 返回的字串个数等于第一个参数 x 的长度 substring 返回字串个数等于三个参数中最长向量长度，短向量循环使用。 x &lt;- &quot;123456789&quot; substr(x, c(2, 4), c(4, 5, 8)) #&gt; [1] &quot;234&quot; substring(x, c(2, 4), c(4, 5, 8)) #&gt; [1] &quot;234&quot; &quot;45&quot; &quot;2345678&quot; substr(&quot;abcdef&quot;, 2, 4) #&gt; [1] &quot;bcd&quot; substring(&quot;abcdef&quot;, 1:6, 1:6) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; 因为 x 的向量长度为1，所以 substr 获得的结果只有1个字串，即第2和第3个参数向量只用了第一个组合：起始位置2，终止位置4。而 substring 的语句三个参数中最长的向量为 c(4,5,8)，执行时按短向量循环使用的规则第一个参数事实上就是c(x,x,x)，第二个参数就成了c(2,4,2)，最终截取的字串起始位置组合为：2-4, 4-5和2-8。 x &lt;- c(&quot;123456789&quot;, &quot;abcdefghijklmnopq&quot;) substr(x, c(2, 4), c(4, 5, 8)) #&gt; [1] &quot;234&quot; &quot;de&quot; substring(x, c(2, 4), c(4, 5, 8)) #&gt; [1] &quot;234&quot; &quot;de&quot; &quot;2345678&quot; 更加高级的字符串抽取 # 从字符串中抽取固定模式的文本，替代 stringr::str_extract # 只抽取一个匹配的 extract_str &lt;- function(text, pattern) regmatches(text, regexpr(pattern, text)) # 符合模式的全部抽取 gextract_str &lt;- function(text, pattern) regmatches(text, gregexpr(pattern, text)) 举例子，抽取连续的数字 # 两个例子 extract_str(text = &quot;abd123da345das&quot;, pattern = &quot;(\\\\d+){3}&quot;) #&gt; [1] &quot;123&quot; gextract_str(text = &quot;abd123da345das&quot;, pattern = &quot;(\\\\d+){3}&quot;) #&gt; [[1]] #&gt; [1] &quot;123&quot; &quot;345&quot; 例子来自于 https://recology.info/2018/10/limiting-dependencies/ 9.9 命名捕捉 函数 regexpr(..., perl = TRUE) 和 gregexpr(..., perl = TRUE) 支持命名捕捉 ## named capture notables &lt;- c(&quot; Ben Franklin and Jefferson Davis&quot;, &quot;\\tMillard Fillmore&quot;) # name groups &#39;first&#39; and &#39;last&#39; name.rex &lt;- &quot;(?&lt;first&gt;[[:upper:]][[:lower:]]+) (?&lt;last&gt;[[:upper:]][[:lower:]]+)&quot; (parsed &lt;- regexpr(name.rex, notables, perl = TRUE)) #&gt; [1] 3 2 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 12 16 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE #&gt; attr(,&quot;capture.start&quot;) #&gt; first last #&gt; [1,] 3 7 #&gt; [2,] 2 10 #&gt; attr(,&quot;capture.length&quot;) #&gt; first last #&gt; [1,] 3 8 #&gt; [2,] 7 8 #&gt; attr(,&quot;capture.names&quot;) #&gt; [1] &quot;first&quot; &quot;last&quot; attr(parsed, &#39;capture.names&#39;) #&gt; [1] &quot;first&quot; &quot;last&quot; regmatches(notables, parsed) #&gt; [1] &quot;Ben Franklin&quot; &quot;Millard Fillmore&quot; 希望返回一个 data.frame，列名是指定的 named group 名字 # 有多个结果 (idx &lt;- gregexpr(name.rex, notables, perl = TRUE)) #&gt; [[1]] #&gt; [1] 3 20 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 12 15 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE #&gt; attr(,&quot;capture.start&quot;) #&gt; first last #&gt; [1,] 3 7 #&gt; [2,] 20 30 #&gt; attr(,&quot;capture.length&quot;) #&gt; first last #&gt; [1,] 3 8 #&gt; [2,] 9 5 #&gt; attr(,&quot;capture.names&quot;) #&gt; [1] &quot;first&quot; &quot;last&quot; #&gt; #&gt; [[2]] #&gt; [1] 2 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 16 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE #&gt; attr(,&quot;capture.start&quot;) #&gt; first last #&gt; [1,] 2 10 #&gt; attr(,&quot;capture.length&quot;) #&gt; first last #&gt; [1,] 7 8 #&gt; attr(,&quot;capture.names&quot;) #&gt; [1] &quot;first&quot; &quot;last&quot; regmatches(notables, idx) #&gt; [[1]] #&gt; [1] &quot;Ben Franklin&quot; &quot;Jefferson Davis&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;Millard Fillmore&quot; attr(idx[[1]], &#39;capture.names&#39;) #&gt; [1] &quot;first&quot; &quot;last&quot; library(magrittr) data.frame(notable = notables) %&gt;% tidyr::extract( notable, c(&quot;first&quot;, &quot;last&quot;), name.rex, remove = FALSE ) #&gt; notable first last #&gt; 1 Ben Franklin and Jefferson Davis Ben Franklin #&gt; 2 \\tMillard Fillmore Millard Fillmore 9.10 精确匹配 fixed = TRUE 9.11 模糊匹配 近似字符串匹配 (Approximate String Matching) 也叫模糊匹配 (Fuzzy Matching) agrep() agrepl() aregexec() adist() agrep(pattern = &quot;lasy&quot;, x = &quot;1 lazy 2&quot;) #&gt; [1] 1 agrep(&quot;lasy&quot;, c(&quot; 1 lazy 2&quot;, &quot;1 lasy 2&quot;), max = list(sub = 0)) #&gt; [1] 2 agrep(&quot;laysy&quot;, c(&quot;1 lazy&quot;, &quot;1&quot;, &quot;1 LAZY&quot;), max = 2) #&gt; [1] 1 agrep(&quot;laysy&quot;, c(&quot;1 lazy&quot;, &quot;1&quot;, &quot;1 LAZY&quot;), max = 2, value = TRUE) #&gt; [1] &quot;1 lazy&quot; agrep(&quot;laysy&quot;, c(&quot;1 lazy&quot;, &quot;1&quot;, &quot;1 LAZY&quot;), max = 2, ignore.case = TRUE) #&gt; [1] 1 3 agrepl(pattern = &quot;lasy&quot;, x = &quot;1 lazy 2&quot;) #&gt; [1] TRUE ## Cf. the examples for agrep. x &lt;- c(&quot;1 lazy&quot;, &quot;1&quot;, &quot;1 LAZY&quot;) aregexec(&quot;laysy&quot;, x, max.distance = 2) #&gt; [[1]] #&gt; [1] 3 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 4 #&gt; #&gt; [[2]] #&gt; [1] -1 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] -1 #&gt; #&gt; [[3]] #&gt; [1] -1 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] -1 aregexec(&quot;(lay)(sy)&quot;, x, max.distance = 2) #&gt; [[1]] #&gt; [1] 3 3 5 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 4 2 2 #&gt; #&gt; [[2]] #&gt; [1] -1 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] -1 #&gt; #&gt; [[3]] #&gt; [1] -1 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] -1 aregexec(&quot;(lay)(sy)&quot;, x, max.distance = 2, ignore.case = TRUE) #&gt; [[1]] #&gt; [1] 3 3 6 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 4 3 1 #&gt; #&gt; [[2]] #&gt; [1] -1 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] -1 #&gt; #&gt; [[3]] #&gt; [1] 3 3 6 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 4 3 1 m &lt;- aregexec(&quot;(lay)(sy)&quot;, x, max.distance = 2) regmatches(x, m) #&gt; [[1]] #&gt; [1] &quot;lazy&quot; &quot;la&quot; &quot;zy&quot; #&gt; #&gt; [[2]] #&gt; character(0) #&gt; #&gt; [[3]] #&gt; character(0) ## Cf. https://en.wikipedia.org/wiki/Levenshtein_distance adist(&quot;kitten&quot;, &quot;sitting&quot;) #&gt; [,1] #&gt; [1,] 3 ## To see the transformation counts for the Levenshtein distance: drop(attr(adist(&quot;kitten&quot;, &quot;sitting&quot;, counts = TRUE), &quot;counts&quot;)) #&gt; ins del sub #&gt; 1 0 2 ## To see the transformation sequences: attr(adist(c(&quot;kitten&quot;, &quot;sitting&quot;), counts = TRUE), &quot;trafos&quot;) #&gt; [,1] [,2] #&gt; [1,] &quot;MMMMMM&quot; &quot;SMMMSMI&quot; #&gt; [2,] &quot;SMMMSMD&quot; &quot;MMMMMMM&quot; ## Cf. the examples for agrep: adist(&quot;lasy&quot;, &quot;1 lazy 2&quot;) #&gt; [,1] #&gt; [1,] 5 ## For a &quot;partial approximate match&quot; (as used for agrep): adist(&quot;lasy&quot;, &quot;1 lazy 2&quot;, partial = TRUE) #&gt; [,1] #&gt; [1,] 1 案例 help.search() 9.12 高级的替换 相比于 sprintf() 格式化输出字符串的方式替换，它的优势在于提示性，或者说代码的可读性 glue_data &lt;- function(param, text) { idx &lt;- gregexpr(&#39;\\\\{[^}]*\\\\}&#39;, text)[[1L]] keys &lt;- substring(text, idx, idx + attr(idx, &#39;match.length&#39;) - 1L) for (key in keys) { text &lt;- gsub(key, param[[gsub(&#39;[{}]&#39;, &#39;&#39;, key)]], text, fixed = TRUE) } text } cat(glue_data( param = list(table = &#39;flights&#39;, origin = &#39;JFK&#39;), text = &quot; select count(*) as n from {table} where origin = &#39;{origin}&#39; &quot; )) #&gt; #&gt; select count(*) as n #&gt; from flights #&gt; where origin = &#39;JFK&#39; #&gt; 9.13 高级的提取 从 text 中抽取给定模式 pattern 的字符串 str_extract &lt;- function(text, pattern, ...) regmatches(text, regexpr(pattern, text, ...)) 举个栗子，比如提取数字 shopping_list &lt;- c(&quot;apples x4&quot;, &quot;bag of flour&quot;, &quot;bag of sugar&quot;, &quot;milk x2&quot;) stringr::str_extract(shopping_list, &quot;\\\\d&quot;) #&gt; [1] &quot;4&quot; NA NA &quot;2&quot; # 注意二者的差别 str_extract(shopping_list, &quot;\\\\d&quot;) #&gt; [1] &quot;4&quot; &quot;2&quot; 提取所有符合匹配模式的字符串 str_extract_all &lt;- function(text, pattern, ...) regmatches(text, gregexpr(pattern, text, ...)) 举个栗子，提取其中的英文字母 str_extract_all(shopping_list, &quot;[a-z]+&quot;) #&gt; [[1]] #&gt; [1] &quot;apples&quot; &quot;x&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;bag&quot; &quot;of&quot; &quot;flour&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;bag&quot; &quot;of&quot; &quot;sugar&quot; #&gt; #&gt; [[4]] #&gt; [1] &quot;milk&quot; &quot;x&quot; stringr::str_extract_all(shopping_list, &quot;[a-z]+&quot;) #&gt; [[1]] #&gt; [1] &quot;apples&quot; &quot;x&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;bag&quot; &quot;of&quot; &quot;flour&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;bag&quot; &quot;of&quot; &quot;sugar&quot; #&gt; #&gt; [[4]] #&gt; [1] &quot;milk&quot; &quot;x&quot; 9.14 其它操作 9.14.1 strwrap strwrap(x, width = 0.9 * getOption(&quot;width&quot;), indent = 0, exdent = 0, prefix = &quot;&quot;, simplify = TRUE, initial = prefix) 该函数把一个字符串当成一个段落的文字（不管字符串中是否有换行符），按照段落的格式（缩进和长度）和断字方式进行分行，每一行是结果中的一个字符串。 # 读取一段文本 x &lt;- paste(readLines(file.path(R.home(&quot;doc&quot;), &quot;THANKS&quot;)), collapse = &quot;\\n&quot;) ## 将文本拆分为段落，且移除前三段 x &lt;- unlist(strsplit(x, &quot;\\n[ \\t\\n]*\\n&quot;))[-(1:3)] # 每一段换两行 x &lt;- paste(x, collapse = &quot;\\n\\n&quot;) # 每一行的宽度设定为60个字符 writeLines(strwrap(x, width = 60)) #&gt; J. D. Beasley, David J. Best, Richard Brent, Kevin Buhr, #&gt; Michael A. Covington, Bill Cleveland, Robert Cleveland,, G. #&gt; W. Cran, C. G. Ding, Ulrich Drepper, Paul Eggert, J. O. #&gt; Evans, David M. Gay, H. Frick, G. W. Hill, Richard H. #&gt; Jones, Eric Grosse, Shelby Haberman, Bruno Haible, John #&gt; Hartigan, Andrew Harvey, Trevor Hastie, Min Long Lam, #&gt; George Marsaglia, K. J. Martin, Gordon Matzigkeit, C. R. #&gt; Mckenzie, Jean McRae, Cyrus Mehta, Fionn Murtagh, John C. #&gt; Nash, Finbarr O&#39;Sullivan, R. E. Odeh, William Patefield, #&gt; Nitin Patel, Alan Richardson, D. E. Roberts, Patrick #&gt; Royston, Russell Lenth, Ming-Jen Shyu, Richard C. #&gt; Singleton, S. G. Springer, Supoj Sutanthavibul, Irma #&gt; Terpenning, G. E. Thomas, Rob Tibshirani, Wai Wan Tsang, #&gt; Berwin Turlach, Gary V. Vaughan, Michael Wichura, Jingbo #&gt; Wang, M. A. Wong, and the Free Software Foundation (for #&gt; autoconf code and utilities). See also files under #&gt; src/extras. #&gt; #&gt; Many more, too numerous to mention here, have contributed #&gt; by sending bug reports and suggesting various improvements. .... # 每一段的段首缩进5个字符 writeLines(strwrap(x, width = 60, indent = 5)) #&gt; J. D. Beasley, David J. Best, Richard Brent, Kevin #&gt; Buhr, Michael A. Covington, Bill Cleveland, Robert #&gt; Cleveland,, G. W. Cran, C. G. Ding, Ulrich Drepper, Paul #&gt; Eggert, J. O. Evans, David M. Gay, H. Frick, G. W. Hill, #&gt; Richard H. Jones, Eric Grosse, Shelby Haberman, Bruno #&gt; Haible, John Hartigan, Andrew Harvey, Trevor Hastie, Min #&gt; Long Lam, George Marsaglia, K. J. Martin, Gordon #&gt; Matzigkeit, C. R. Mckenzie, Jean McRae, Cyrus Mehta, Fionn #&gt; Murtagh, John C. Nash, Finbarr O&#39;Sullivan, R. E. Odeh, #&gt; William Patefield, Nitin Patel, Alan Richardson, D. E. #&gt; Roberts, Patrick Royston, Russell Lenth, Ming-Jen Shyu, #&gt; Richard C. Singleton, S. G. Springer, Supoj Sutanthavibul, #&gt; Irma Terpenning, G. E. Thomas, Rob Tibshirani, Wai Wan #&gt; Tsang, Berwin Turlach, Gary V. Vaughan, Michael Wichura, #&gt; Jingbo Wang, M. A. Wong, and the Free Software Foundation #&gt; (for autoconf code and utilities). See also files under #&gt; src/extras. #&gt; #&gt; Many more, too numerous to mention here, have #&gt; contributed by sending bug reports and suggesting various .... # 除了段首，每一段的余下诸行都缩进5个字符 writeLines(strwrap(x, width = 60, exdent = 5)) #&gt; J. D. Beasley, David J. Best, Richard Brent, Kevin Buhr, #&gt; Michael A. Covington, Bill Cleveland, Robert #&gt; Cleveland,, G. W. Cran, C. G. Ding, Ulrich Drepper, #&gt; Paul Eggert, J. O. Evans, David M. Gay, H. Frick, G. #&gt; W. Hill, Richard H. Jones, Eric Grosse, Shelby #&gt; Haberman, Bruno Haible, John Hartigan, Andrew Harvey, #&gt; Trevor Hastie, Min Long Lam, George Marsaglia, K. J. #&gt; Martin, Gordon Matzigkeit, C. R. Mckenzie, Jean McRae, #&gt; Cyrus Mehta, Fionn Murtagh, John C. Nash, Finbarr #&gt; O&#39;Sullivan, R. E. Odeh, William Patefield, Nitin #&gt; Patel, Alan Richardson, D. E. Roberts, Patrick #&gt; Royston, Russell Lenth, Ming-Jen Shyu, Richard C. #&gt; Singleton, S. G. Springer, Supoj Sutanthavibul, Irma #&gt; Terpenning, G. E. Thomas, Rob Tibshirani, Wai Wan #&gt; Tsang, Berwin Turlach, Gary V. Vaughan, Michael #&gt; Wichura, Jingbo Wang, M. A. Wong, and the Free #&gt; Software Foundation (for autoconf code and utilities). #&gt; See also files under src/extras. #&gt; #&gt; Many more, too numerous to mention here, have contributed .... # 在输出的每一行前面添加前缀 writeLines(strwrap(x, prefix = &quot;THANKS&gt; &quot;)) #&gt; THANKS&gt; J. D. Beasley, David J. Best, Richard Brent, Kevin Buhr, #&gt; THANKS&gt; Michael A. Covington, Bill Cleveland, Robert Cleveland,, G. W. #&gt; THANKS&gt; Cran, C. G. Ding, Ulrich Drepper, Paul Eggert, J. O. Evans, #&gt; THANKS&gt; David M. Gay, H. Frick, G. W. Hill, Richard H. Jones, Eric #&gt; THANKS&gt; Grosse, Shelby Haberman, Bruno Haible, John Hartigan, Andrew #&gt; THANKS&gt; Harvey, Trevor Hastie, Min Long Lam, George Marsaglia, K. J. #&gt; THANKS&gt; Martin, Gordon Matzigkeit, C. R. Mckenzie, Jean McRae, Cyrus #&gt; THANKS&gt; Mehta, Fionn Murtagh, John C. Nash, Finbarr O&#39;Sullivan, R. E. #&gt; THANKS&gt; Odeh, William Patefield, Nitin Patel, Alan Richardson, D. E. #&gt; THANKS&gt; Roberts, Patrick Royston, Russell Lenth, Ming-Jen Shyu, #&gt; THANKS&gt; Richard C. Singleton, S. G. Springer, Supoj Sutanthavibul, #&gt; THANKS&gt; Irma Terpenning, G. E. Thomas, Rob Tibshirani, Wai Wan Tsang, #&gt; THANKS&gt; Berwin Turlach, Gary V. Vaughan, Michael Wichura, Jingbo Wang, #&gt; THANKS&gt; M. A. Wong, and the Free Software Foundation (for autoconf #&gt; THANKS&gt; code and utilities). See also files under src/extras. #&gt; THANKS&gt; #&gt; THANKS&gt; Many more, too numerous to mention here, have contributed by #&gt; THANKS&gt; sending bug reports and suggesting various improvements. #&gt; THANKS&gt; #&gt; THANKS&gt; Simon Davies whilst at the University of Auckland wrote the .... 再举一个烧脑的例子 x &lt;- paste(sapply( sample(10, 100, replace = TRUE), # 从1-10个数字中有放回的随机抽取100个数 function(x) substring(&quot;aaaaaaaaaa&quot;, 1, x) ), collapse = &quot; &quot;) sapply( 10:40, function(m) c(target = m, actual = max(nchar(strwrap(x, m)))) ) #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] #&gt; target 10 11 12 13 14 15 16 17 18 19 20 21 22 #&gt; actual 10 10 11 12 13 14 15 16 17 18 19 20 21 #&gt; [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25] #&gt; target 23 24 25 26 27 28 29 30 31 32 33 34 #&gt; actual 22 23 24 25 26 27 28 29 30 31 32 33 #&gt; [,26] [,27] [,28] [,29] [,30] [,31] #&gt; target 35 36 37 38 39 40 #&gt; actual 34 35 36 36 38 39 9.14.2 strtrim strtrim(x, width) strtrim 函数将字符串x修剪到特定的显示宽度，返回的字符串向量的长度等于字符串向量 x 的长度，如果 width 的参数值（它是一个整型向量）的长度小于 x 的，就循环补齐。 strtrim(c(&quot;abcdef&quot;, &quot;abcdef&quot;, &quot;abcdef&quot;), c(1, 5, 10)) #&gt; [1] &quot;a&quot; &quot;abcde&quot; &quot;abcdef&quot; 9.14.3 strrep strrep(x, times) 以给定的次数重复字符串向量中每个元素的个数，并连接字符串的各个副本 strrep(&quot;ABC&quot;, 2) #&gt; [1] &quot;ABCABC&quot; strrep(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), 1 : 3) #&gt; [1] &quot;A&quot; &quot;BB&quot; &quot;CCC&quot; # 创建一个字符串向量，指定每个元素中空格的数量 strrep(&quot; &quot;, 1 : 5) #&gt; [1] &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; 9.14.4 trimws trimws(x, which = c(&quot;both&quot;, &quot;left&quot;, &quot;right&quot;), whitespace = &quot;[ \\t\\r\\n]&quot;) trimws 函数用于移除字符串中的空格，这种空格可以来自制表符、回车符和换行符，位置可以位于字符串的开头或者结尾，which 参数指定空格的大致位置。举例如下 x &lt;- &quot; Some text. &quot; x #&gt; [1] &quot; Some text. &quot; trimws(x) #&gt; [1] &quot;Some text.&quot; trimws(x, &quot;l&quot;) #&gt; [1] &quot;Some text. &quot; trimws(x, &quot;r&quot;) #&gt; [1] &quot; Some text.&quot; 9.15 运行环境 xfun::session_info() #&gt; R Under development (unstable) (2020-02-04 r77771) #&gt; Platform: x86_64-pc-linux-gnu (64-bit) #&gt; Running under: Ubuntu 16.04.6 LTS #&gt; #&gt; Locale: #&gt; LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C #&gt; LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 #&gt; LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 #&gt; LC_PAPER=en_US.UTF-8 LC_NAME=C #&gt; LC_ADDRESS=C LC_TELEPHONE=C #&gt; LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C #&gt; #&gt; Package version: #&gt; assertthat_0.2.1 base64enc_0.1.3 BH_1.72.0.3 bookdown_0.17 #&gt; cli_2.0.1 compiler_4.0.0 crayon_1.3.4 curl_4.3 #&gt; digest_0.6.23 dplyr_0.8.4 ellipsis_0.3.0 evaluate_0.14 #&gt; fansi_0.4.1 glue_1.3.1 graphics_4.0.0 grDevices_4.0.0 #&gt; highr_0.8 htmltools_0.4.0 jsonlite_1.6.1 knitr_1.26 #&gt; lifecycle_0.1.0 magrittr_1.5 markdown_1.1 methods_4.0.0 #&gt; mime_0.9 pillar_1.4.3 pkgconfig_2.0.3 plogr_0.2.0 #&gt; purrr_0.3.3 R6_2.4.1 Rcpp_1.0.3 rlang_0.4.4 #&gt; rmarkdown_2.1 stats_4.0.0 stringi_1.4.5 stringr_1.4.0 #&gt; tibble_2.1.3 tidyr_1.0.2 tidyselect_1.0.0 tinytex_0.19 #&gt; tools_4.0.0 utf8_1.1.4 utils_4.0.0 vctrs_0.2.2 #&gt; xfun_0.12 yaml_2.2.1 https://homepage.divms.uiowa.edu/~luke/R/regexp.html↩︎ "],
["dc-regular-expressions.html", "第 10 章 正则表达式 10.1 字符常量 10.2 软件环境 10.3 基本概念 10.4 字符串匹配 10.5 级联表达式 10.6 反向引用 10.7 命名捕捉 10.8 表达式注释", " 第 10 章 正则表达式 Douglas Bates: If you really want to be cautious you could use an octal representation like sep=\"\\\\007\" to get a character that is very unlikely to occur in a factor level. Ed L. Cashin: I definitely want to be cautious. Instead of the bell character I think I’ll use the field separator character, \"\\\\034\", just because this is the first time I’ve been able to use it for it’s intended purpose! ;) Douglas Bates: Yes, but with \"\\\\034\" you don’t get to make obscure James Bond references :-) — Douglas Bates and Ed L. Cashin R-help (April 2004) 维基百科关于 正则表达式的描述， 学习正则表达式 R 内置的三种匹配模式 fixed = TRUE: 字面意思匹配 exact matching. perl = TRUE: 使用 Perl 正则表达式. fixed = FALSE, perl = FALSE: 使用 POSIX 1003.2 extended 正则表达式 (默认设置). 不要拘泥于一种解决方案，比如清理数据中正则表达式有 Base R 提供的一套，stringr 又一套，提高效率的工具 RStudio 插件 regexplain 和辅助创建正则表达式 RVerbalExpressions 包 有几个名词需要单独拎出来解释的 literal character strings 字面字符串 metacharacters 元字符 extended regular expressions 在下文中约定翻译为默认正则表达式 character class 字符集 [abc] Perl-like regular expressions Perl 风格的正则表达式 以下所述，都不考虑函数中参数 perl=TRUE 的情况，R 语言中提供了扩展的（默认的）和 Perl 风格 的两套正则表达式。作为入门，我们这里只关注前者，启用 Perl 正则表达式只需在函数如 grep 中将选项 perl = TRUE 即可，并将后者统一命名为 Perl 正则表达式36。 正则表达式 (regular expression，简称 regexp)， 函数 regexpr 和 gregexpr 的名称就好理解了，在控制台输入 ?regex 查看 R 支持的正则表达式，这个文档看上百八十回也不过分。R 内支持正则表达式的函数有 grep、grepl、sub、gsub、regexpr、gregexpr 、 regexec 和 strsplit。函数 apropos，browseEnv，help.search，list.files 和 ls 是通过函数 grep 来使用正则表达式的，它们全都使用 extended regular expressions grep(pattern, x, ignore.case = FALSE, perl = FALSE, value = FALSE, fixed = FALSE, useBytes = FALSE, invert = FALSE) 匹配模式 pattern 的内容 可以用函数 cat 打印出来，注意反斜杠进入 R 字符串中时，需要用两个，反斜杠 \\ 本身是转义符，否则会报错。 cat(&quot;\\\\&quot;) # \\ 反斜杠是转义字符 #&gt; \\ cat(&quot;\\\\.&quot;) #&gt; \\. cat(&quot;\\\\\\n&quot;) # 注意 \\n 表示换行 #&gt; \\ 10.1 字符常量 单引号 ' 双引号 \" 和反引号 ` 三种类型的引用 (quotes) 是 R 语法的一部分37，此外反斜杠 \\ 用来转义下面的字符 表 10.1: 字符常量表 字符常量 含义 \\n 换行 newline \\r 回车 carriage return \\t 制表符 tab \\b 退格 backspace \\a 警报（铃）alert (bell) \\f 换页 form feed \\v 垂直制表符 vertical tab \\\\ 反斜杠 backslash \\ \\' 单引号 ASCII apostrophe ' \\\" 双引号 ASCII quotation mark \" \\` 反引号或沉音符 ASCII grave accent (backtick) ` \\nnn 八进制 character with given octal code (1, 2 or 3 digits) \\xnn 十六进制 character with given hex code (1 or 2 hex digits) \\unnnn Unicode character with given code (1–4 hex digits) \\Unnnnnnnn Unicode character with given code (1–8 hex digits) 10.2 软件环境 R 内置的正则表达式实现是基于 PCRE ICU TRE iconv 等第三方库，搞清楚自己使用的版本信息是重要的，一些字符集的解释与区域环境有关，如 [:alnum:] 和 [:alpha:]等，所以获取当前的区域设置也很重要 # find a suitable coding for the current locale localeToCharset(locale = Sys.getlocale(&quot;LC_CTYPE&quot;)) #&gt; [1] &quot;UTF-8&quot; &quot;ISO8859-1&quot; # 软件版本信息 extSoftVersion() #&gt; zlib #&gt; &quot;1.2.8&quot; #&gt; bzlib #&gt; &quot;1.0.6, 6-Sept-2010&quot; #&gt; xz #&gt; &quot;5.1.0alpha&quot; #&gt; PCRE #&gt; &quot;8.38 2015-11-23&quot; #&gt; ICU #&gt; &quot;55.1&quot; #&gt; TRE #&gt; &quot;TRE 0.8.0 R_fixes (BSD)&quot; #&gt; iconv #&gt; &quot;glibc 2.23&quot; #&gt; readline #&gt; &quot;6.3&quot; #&gt; BLAS #&gt; &quot;/home/travis/R-bin/lib/R/lib/libRblas.so&quot; # 区域及其编码信息 l10n_info() #&gt; $MBCS #&gt; [1] TRUE #&gt; #&gt; $`UTF-8` #&gt; [1] TRUE #&gt; #&gt; $`Latin-1` #&gt; [1] FALSE # 表示数字、货币的细节 Sys.localeconv() #&gt; decimal_point thousands_sep grouping int_curr_symbol #&gt; &quot;.&quot; &quot;&quot; &quot;&quot; &quot;USD &quot; #&gt; currency_symbol mon_decimal_point mon_thousands_sep mon_grouping #&gt; &quot;$&quot; &quot;.&quot; &quot;,&quot; &quot;\\003\\003&quot; #&gt; positive_sign negative_sign int_frac_digits frac_digits #&gt; &quot;&quot; &quot;-&quot; &quot;2&quot; &quot;2&quot; #&gt; p_cs_precedes p_sep_by_space n_cs_precedes n_sep_by_space #&gt; &quot;1&quot; &quot;0&quot; &quot;1&quot; &quot;0&quot; #&gt; p_sign_posn n_sign_posn #&gt; &quot;1&quot; &quot;1&quot; # PCRE 启用的配置选项 pcre_config() #&gt; UTF-8 Unicode properties JIT stack #&gt; TRUE TRUE FALSE TRUE # 比较全的字符信息 stringi::stri_info() #&gt; $Unicode.version #&gt; [1] &quot;7.0&quot; #&gt; #&gt; $ICU.version #&gt; [1] &quot;55.1&quot; #&gt; #&gt; $Locale #&gt; $Locale$Language #&gt; [1] &quot;en&quot; #&gt; #&gt; $Locale$Country #&gt; [1] &quot;US&quot; #&gt; #&gt; $Locale$Variant #&gt; [1] &quot;&quot; #&gt; #&gt; $Locale$Name #&gt; [1] &quot;en_US&quot; #&gt; #&gt; #&gt; $Charset.internal #&gt; [1] &quot;UTF-8&quot; &quot;UTF-16&quot; #&gt; #&gt; $Charset.native #&gt; $Charset.native$Name.friendly #&gt; [1] &quot;UTF-8&quot; #&gt; #&gt; $Charset.native$Name.ICU #&gt; [1] &quot;UTF-8&quot; #&gt; #&gt; $Charset.native$Name.UTR22 #&gt; [1] NA #&gt; #&gt; $Charset.native$Name.IBM #&gt; [1] &quot;ibm-1208&quot; #&gt; #&gt; $Charset.native$Name.WINDOWS #&gt; [1] &quot;windows-65001&quot; #&gt; #&gt; $Charset.native$Name.JAVA #&gt; [1] &quot;UTF-8&quot; #&gt; #&gt; $Charset.native$Name.IANA #&gt; [1] &quot;UTF-8&quot; #&gt; #&gt; $Charset.native$Name.MIME #&gt; [1] &quot;UTF-8&quot; #&gt; #&gt; $Charset.native$ASCII.subset #&gt; [1] TRUE #&gt; #&gt; $Charset.native$Unicode.1to1 #&gt; [1] NA #&gt; #&gt; $Charset.native$CharSize.8bit #&gt; [1] FALSE #&gt; #&gt; $Charset.native$CharSize.min #&gt; [1] 1 #&gt; #&gt; $Charset.native$CharSize.max #&gt; [1] 3 #&gt; #&gt; #&gt; $ICU.system #&gt; [1] TRUE #&gt; #&gt; $ICU.UTF8 #&gt; [1] FALSE 需要临时改变区域环境设置，配合特殊的画图和文本输出要求。 # 获取当前默认的区域设置 Sys.getlocale() foo &lt;- Sys.getlocale() # 恢复默认的区域设置 Sys.setlocale(&quot;LC_ALL&quot;, locale = foo) 10.3 基本概念 正则表达式的构造方式类似算术表达式，通过各种操作组合子（更小的）表达式，整个表达式匹配一个或多个字符38。大多数字符，包括所有的字母和数字，是匹配自身的正则表达式。元字符 . \\ | ( ) [ { ^ $ * + ? 需要转义才能表达其自身的含义，转义的方式是在元字符前面添加反斜杠，如要表达点号 . 需要使用 \\.。要注意，它们是否有特殊意义取决于所在的内容。 一个字符集 (character class) 是用一对中括号[]括起来的字符列表，用来匹配列表中的任意单个字符，除非列表中的第一个字符是 ^，它用来匹配不在这个列表中的字符。 [0123456789] 用来匹配任意单个数字，[^abc] 用来匹配除字符 a,b,c 以外的任意字符。字符范围 (character ranges) 可以通过第一个和最后一个字符指定， 中间用连字符 (hyphen) 连接， 由于这种解释依赖于区域和具体实现，所以指定字符范围的使用方式最好避免。唯一可移植（便携，通用）的方式是作为字符集，在列表中列出所有的 ASCII 字母， [ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz]. 预定义的一些字符类，它们的解释依赖于当前的语言区域，下面是 POSIX locale 环境下的解释 [:alnum:] 表示 [:alpha:] 和 [:digit:]，含义是 [0-9A-Za-z]，但是前者与区域和字符集无关，后者依赖于当前的区域设置和字符编码。要注意在这些字符集名 class names 中，中括号 [] 是符号名的一部分，是必须要包含的。在字符集中，大多数元字符失去它们特殊的意义。 [:alpha:] 表示 [:lower:] 和 [:upper:] [:blank:] 表示 空格 space 制表符 tab [:cntrl:] 表示控制符，在 ASCII 字符集里里，这些字符有八进制代码，从 000 到 037，和 177(DEL)。 [:digit:] 表示数字 0,1,2,3,4,5,6,7,8,9 [:graph:] 表示 [:alnum:] 和 [:punct:]. [:lower:] 表示当前区域下的小写字母 [:print:] 表示可打印的字符 [:alnum:], [:punct:] 和空格. [:punct:] 表示标点字符 ! &quot; # $ % &amp; &#39; ( ) * + , - . / : ; &lt; = &gt; ? @ [ \\ ] ^ _ ` { | } ~` [:space:] 表示空格字符： 水平制表符 tab， 换行符 newline，垂直制表符 vertical tab，换页符 form feed，回车符 carriage return，空格符 space [:xdigit:] 表示 16 进制数字 0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f. 要包含字面的 ] 就把它放在列表的开头，类似地，要包含字面 ^，除了开头可以放在任意位置。要包含字面 - 把它放在开头或者结尾。只有 ^ - \\ ] 在字符集内是有特殊的含义 点号 . 匹配任意单个字符，\\w 匹配一个词 word 字符(是[[:alnum:]_]的同义词，一个扩展) ，而 \\W 是 \\w 取反，意味着 [^[:alnum:]_]。 \\d, \\s, \\D 和 \\S 表示数字和空格类和它们的取反 脱字符 caret ^ 和美元符号 $ 是元字符，分别匹配一行的开头和结尾。符号 \\&lt; 和 \\&gt; 分别匹配一个词的开头和结尾的空字符串。\\b 匹配词边缘的空字符串，\\B 匹配不在词边缘的空字符串。 词 word 的解释依赖于区域和实现。 10.4 字符串匹配 默认的匹配方式是贪婪的，会使用尽可能多的匹配次数，这个可以变为最小的匹配次数，通过在其之后添加 ?，一个正则表达式可能跟着重复量词，下面的限定符都是限定在它前面的正则表达式 表 10.2: 贪婪匹配限定符 符号 描述 ? 匹配至多 1 次 * 匹配 0 次或多次 + 匹配至少 1 次 {n} 匹配 n 次 {n,} 匹配至少 n 次 {n,m} 匹配至少 n 次，至多 m 次 10.5 级联表达式 Regular expressions may be concatenated; the resulting regular expression matches any string formed by concatenating the substrings that match the concatenated subexpressions. 正则表达式可以是级联 concatenation 的，是不是在讲一个正则表达式里面嵌套一个正则表达式？ 两个正则表达式可以通过中缀符号 | 联合，用两个子表达式的任意一个去匹配字符串，例如 abba | cde 要么匹配字符串 abba 要么匹配字符串 cde，要注意在字符集内，即 abba|cde，二选一的匹配不凑效，因为中缀符 | 有它的字面意思。 重复匹配 Repetition 的优先级高于级联，级联高于 | 。 整个子表达式可以括号括起来覆盖这些优先级规则。 10.6 反向引用 反向引用 \\N 这里 N 可取 1,2,…,9 匹配被之前第 N 个括起来的子表达式匹配的子字符串，例子见 COS 论坛 https://d.cosx.org/d/420570/5 10.7 命名捕捉 模式 (?:...) 包住的字符就是括号分组，但是不做反向查找。模式 (?&lt;=...) 和 (?&lt;!...) 都是反向查找，它们不允许跟限制符，在 ... 也不允许出现 \\C。表 10.3 展示四个反向引用 表 10.3: 环顾四周查找 符号 描述 ?= 正向肯定查找 ?! 正向否定查找 ?&lt;= 反向肯定查找 ?&lt;! 反向否定查找 函数 regexpr 和 gregexpr 支持命名捕捉 (named capture). 如果一个组被命名了，如 (?&lt;first&gt;[A-Z][a-z]+) 那么，匹配的位置是按名字返回。 下面举个例子说明，从字符串向量 notables 中获得了三组匹配 name.rex 是一段正则表达式，描述的模式是人名 ## named capture notables &lt;- c(&quot; Ben Franklin and Jefferson Davis&quot;, &quot;\\tMillard Fillmore&quot;) # name groups &#39;first&#39; and &#39;last&#39; name.rex &lt;- &quot;(?&lt;first&gt;[[:upper:]][[:lower:]]+) (?&lt;last&gt;[[:upper:]][[:lower:]]+)&quot; parsed &lt;- regexpr(name.rex, notables, perl = TRUE) parsed #&gt; [1] 3 2 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 12 16 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE #&gt; attr(,&quot;capture.start&quot;) #&gt; first last #&gt; [1,] 3 7 #&gt; [2,] 2 10 #&gt; attr(,&quot;capture.length&quot;) #&gt; first last #&gt; [1,] 3 8 #&gt; [2,] 7 8 #&gt; attr(,&quot;capture.names&quot;) #&gt; [1] &quot;first&quot; &quot;last&quot; notables 是一个长度为2的字符串向量，所以获得两组匹配，捕捉到匹配开始的位置 capture.start 和匹配的长度 capture.length 都是两组，按列来看，字符 B 出现在字符串 Ben Franklin and Jefferson Davis 的第三个位置，匹配的长度 Ben 是三个字符，长度是 3，如图 10.1 所示，需要注意的是一定要设置 perl = TRUE 才能使用命名捕捉功能，函数 sub 不支持命名反向引用 Named backreferences 图 10.1: 命名捕捉 Atomic grouping 原子分组, possessive qualifiers 占有限定 and conditional 条件 and recursive 递归等模式超出介绍的范围，不在此处详述，感兴趣的读者可参考，此外，插播一条漫画 10.2 图 10.2: 正则表达式漫画 正则表达式的直观解释 https://github.com/gadenbuie/regexplain 10.8 表达式注释 The sequence (?# marks the start of a comment which continues up to the next closing parenthesis. Nested parentheses are not permitted. The characters that make up a comment play no part at all in the pattern matching. If the extended option is set, an unescaped # character outside a character class introduces a comment that continues up to the next newline character in the pattern. 推荐的学习正则表达式的路径可以见统计之都论坛 https://d.cosx.org/d/420410↩︎ https://stat.ethz.ch/R-manual/R-devel/library/base/html/Quotes.html↩︎ useBytes = TRUE 表示把字符看作字节。字符、字节和比特的关系是，一个字节 byte 八个比特 bit，一个英文字符 character 用一个字节表示，而一个中、日、韩文字符需要两个字节表示↩︎ "],
["dv-plot.html", "第 11 章 绘图素材库 11.1 基本要素 11.2 统计图形 11.3 运行环境", " 第 11 章 绘图素材库 作为知识介绍，本章所有数据都来源于基础 R 包，即安装 R 软件后自带的数据集，图库在以 base R 中的数据集介绍完后，以相应真实数据扩展为案列，结合统计意义和探索性数据分析介绍各种常见统计图形 数据可视化是一种重要的数据分析手段， R 提供了两套图形系统，分别是 graphics 包提供的基础绘图系统和 grid 包提供的栅格绘图系统，后者主要以两个 R 包为大家所熟知，一个是 lattice 包，另一个是 ggplot2 包。 Base 图形系统的扩展包 basetheme 可以设置主题，prettyB 和 gridGraphics 为了方便记忆函数 par 的各个参数，Paul Murrell 整理了一份 助记符，此外，LaTeX 宏包 geometry 对版面设置有很多专业的说明 11.1 基本要素 11.1.1 点线 点和线是最常见的画图元素，在 plot 函数中，分别用参数 pch 和 lty 来设定类型，点的大小、线的宽度分别用参数 cex 和 lwd 来指定，颜色由参数 col 设置。参数 type 不同的值设置如下，p 显示点，l 绘制线，b 同时绘制空心点，并用线连接，c 只有线，o 在线上绘制点，s 和 S 点线连接绘制阶梯图，h 绘制类似直方图一样的垂线，最后 n 表示什么也不画。 点 points 、线 grid 背景线 abline lines rug 刻度线（线段segments、箭头arrows）、 ## -------- Showing all the extra &amp; some char graphics symbols --------- pchShow &lt;- function(extras = c(&quot;*&quot;, &quot;.&quot;, &quot;o&quot;, &quot;O&quot;, &quot;0&quot;, &quot;+&quot;, &quot;-&quot;, &quot;|&quot;, &quot;%&quot;, &quot;#&quot;), cex = 2, ## good for both .Device==&quot;postscript&quot; and &quot;x11&quot; col = &quot;red3&quot;, bg = &quot;gold&quot;, coltext = &quot;brown&quot;, cextext = 1.2, main = paste( &quot;plot symbols : points (... pch = *, cex =&quot;, cex, &quot;)&quot; )) { nex &lt;- length(extras) np &lt;- 26 + nex ipch &lt;- 0:(np - 1) k &lt;- floor(sqrt(np)) dd &lt;- c(-1, 1) / 2 rx &lt;- dd + range(ix &lt;- ipch %/% k) ry &lt;- dd + range(iy &lt;- 3 + (k - 1) - ipch %% k) pch &lt;- as.list(ipch) # list with integers &amp; strings if (nex &gt; 0) pch[26 + 1:nex] &lt;- as.list(extras) plot(rx, ry, type = &quot;n&quot;, axes = FALSE, xlab = &quot;&quot;, ylab = &quot;&quot;, main = main) abline(v = ix, h = iy, col = &quot;lightgray&quot;, lty = &quot;dotted&quot;) for (i in 1:np) { pc &lt;- pch[[i]] ## &#39;col&#39; symbols with a &#39;bg&#39;-colored interior (where available) : points(ix[i], iy[i], pch = pc, col = col, bg = bg, cex = cex) if (cextext &gt; 0) { text(ix[i] - 0.3, iy[i], pc, col = coltext, cex = cextext) } } } pchShow() 图 11.1: 不同的 pch 参数值 ## ------------ test code for various pch specifications ------------- # Try this in various font families (including Hershey) # and locales. Use sign = -1 asserts we want Latin-1. # Standard cases in a MBCS locale will not plot the top half. TestChars &lt;- function(sign = 1, font = 1, ...) { MB &lt;- l10n_info()$MBCS r &lt;- if (font == 5) { sign &lt;- 1 c(32:126, 160:254) } else if (MB) 32:126 else 32:255 if (sign == -1) r &lt;- c(32:126, 160:255) par(pty = &quot;s&quot;) plot(c(-1, 16), c(-1, 16), type = &quot;n&quot;, xlab = &quot;&quot;, ylab = &quot;&quot;, xaxs = &quot;i&quot;, yaxs = &quot;i&quot;, main = sprintf(&quot;sign = %d, font = %d&quot;, sign, font) ) grid(17, 17, lty = 1) mtext(paste(&quot;MBCS:&quot;, MB)) for (i in r) try(points(i %% 16, i %/% 16, pch = sign * i, font = font, ...)) } TestChars() try(TestChars(sign = -1)) TestChars(font = 5) # Euro might be at 160 (0+10*16). # macOS has apple at 240 (0+15*16). try(TestChars(-1, font = 2)) # bold 图 11.2: pch 支持的字符 x &lt;- 0:12 y &lt;- sin(pi / 5 * x) par(mfrow = c(3, 3), mar = .1 + c(2, 2, 3, 1)) for (tp in c(&quot;p&quot;, &quot;l&quot;, &quot;b&quot;, &quot;c&quot;, &quot;o&quot;, &quot;h&quot;, &quot;s&quot;, &quot;S&quot;, &quot;n&quot;)) { plot(y ~ x, type = tp, main = paste0(&quot;plot(*, type = \\&quot;&quot;, tp, &quot;\\&quot;)&quot;)) if (tp == &quot;S&quot;) { lines(x, y, type = &quot;s&quot;, col = &quot;red&quot;, lty = 2) mtext(&quot;lines(*, type = \\&quot;s\\&quot;, ...)&quot;, col = &quot;red&quot;, cex = 0.8) } } 图 11.3: 不同的 type 参数值 颜色 col 连续型和离散型 线帽/端和字体的样式 # 合并为一个图 三条粗横线 横线上三种字形 plot(c(1, 20), c(1, 20), type = &quot;n&quot;, ann = FALSE) lines(x = c(5, 15), y = c(5, 5), lwd = 15, lend = &quot;round&quot;) text(10, 5, &quot;Hello, Helvetica&quot;, cex = 1.5, family = &quot;sans&quot;, pos = 1, offset = 1.5) text(5, 5, &quot;sans&quot;, cex = 1.5, family = &quot;sans&quot;, pos = 2, offset = .5) text(15, 5, &quot;lend = round&quot;, pos = 4, offset = .5) lines(x = c(5, 15), y = c(10, 10), lwd = 15, lend = &quot;butt&quot;) text(10, 10, &quot;Hello, Helvetica&quot;, cex = 1.5, family = &quot;mono&quot;, pos = 1, offset = 1.5) text(5, 10, &quot;mono&quot;, cex = 1.5, family = &quot;mono&quot;, pos = 2, offset = .5) text(15, 10, &quot;lend = butt&quot;, pos = 4, offset = .5) lines(x = c(5, 15), y = c(15, 15), lwd = 15, lend = &quot;square&quot;) text(10, 15, &quot;Hello, Helvetica&quot;, cex = 1.5, family = &quot;serif&quot;, pos = 1, offset = 1.5) text(5, 15, &quot;serif&quot;, cex = 1.5, family = &quot;serif&quot;, pos = 2, offset = .5) text(15, 15, &quot;lend = square&quot;, pos = 4, offset = .5) 图 11.4: 不同的线端样式 lend：线端的样式，可用一个整数或字符串指定： 0 或 “round” 圆形（默认） 1 或 “butt” 对接形 2 或 “square” 方形 11.1.2 区域 矩形，多边形，曲线交汇出来的区域 面（矩形rect，多边形polygon）、路径 polypath 面/多边形 rect 颜色填充 # From the manual ch.col &lt;- c( &quot;rainbow(n, start=.7, end=.1)&quot;, &quot;heat.colors(n)&quot;, &quot;terrain.colors(n)&quot;, &quot;topo.colors(n)&quot;, &quot;cm.colors(n)&quot; ) # 选择颜色 n &lt;- 16 nt &lt;- length(ch.col) i &lt;- 1:n j &lt;- n / nt d &lt;- j / 6 dy &lt;- 2 * d plot(i, i + d, type = &quot;n&quot;, yaxt = &quot;n&quot;, ylab = &quot;&quot;, xlab = &quot;&quot;, main = paste(&quot;color palettes; n=&quot;, n) ) for (k in 1:nt) { rect(i - .5, (k - 1) * j + dy, i + .4, k * j, col = eval(parse(text = ch.col[k])) ) # 咬人的函数/字符串解析为/转函数 text(2 * j, k * j + dy / 4, ch.col[k]) } 图 11.5: rect 函数画长方形 clip(x1, x2, y1, y2) 在用户坐标中设置剪切区域 x &lt;- rnorm(1000) hist(x, xlim = c(-4, 4)) usr &lt;- par(&quot;usr&quot;) clip(usr[1], -2, usr[3], usr[4]) hist(x, col = &quot;red&quot;, add = TRUE) clip(2, usr[2], usr[3], usr[4]) hist(x, col = &quot;blue&quot;, add = TRUE) do.call(&quot;clip&quot;, as.list(usr)) # reset to plot region my.col &lt;- function(f, g, xmin, xmax, col, N = 200, xlab = &quot;&quot;, ylab = &quot;&quot;, main = &quot;&quot;) { x &lt;- seq(xmin, xmax, length = N) fx &lt;- f(x) gx &lt;- g(x) plot(0, 0, type = &quot;n&quot;, xlim = c(xmin, xmax), ylim = c(min(fx, gx), max(fx, gx)), xlab = xlab, ylab = ylab, main = main ) polygon(c(x, rev(x)), c(fx, rev(gx)), col = &quot;#EA4335&quot;, border = 0 ) lines(x, fx, lwd = 3, col = &quot;#34A853&quot;) lines(x, gx, lwd = 3, col = &quot;#4285f4&quot;) } my.col(function(x) x^2, function(x) x^2 + 10 * sin(x), -6, 6, main = &quot;The \\&quot;polygon\\&quot; function&quot; ) 图 11.6: 区域重叠 polygon 函数 各种符号 11.7 plot(0, 0, xlim = c(1, 5), ylim = c(-.5, 4), axes = F, xlab = &quot;&quot;, ylab = &quot;&quot; ) for (i in 0:4) { for (j in 1:5) { n &lt;- 5 * i + j points(j, i, pch = n, cex = 3 ) text(j, i - .3, as.character(n)) } } 图 11.7: cex 支持的符号 点、线、多边形和圆聚集在图 11.8 中 # https://jeroen.github.io/uros2018/#23 plot.new() plot.window(xlim = c(0, 100), ylim = c(0, 100)) polygon(c(10, 40, 80), c(10, 80, 40), col = &quot;hotpink&quot;) text(40, 90, labels = &quot;My drawing&quot;, col = &quot;navyblue&quot;, cex = 3) symbols(c(70, 80, 90), c(20, 50, 80), circles = c(10, 20, 10), bg = c(&quot;#4285f4&quot;, &quot;#EA4335&quot;, &quot;red&quot;), add = TRUE, lty = &quot;dashed&quot; ) 图 11.8: 多边形和符号元素 在介绍各种统计图形之前，先介绍几个绘图函数 plot 和 text 还有 par 参数设置， 作为最简单的开始，尽量依次介绍其中的每个参数的含义并附上图形对比。 y &lt;- x &lt;- 1:4 plot(x, y, ann = F, col = &quot;blue&quot;, pch = 16) text(x, y, labels = c(&quot;1st&quot;, &quot;2nd&quot;, &quot;3rd&quot;, &quot;4th&quot;), col = &quot;red&quot;, pos = c(3, 4, 4, 1), offset = 0.6 ) ahat &lt;- &quot;sigma&quot; # title(substitute(hat(a) == ahat, list(ahat = ahat))) title(bquote(hat(a) == .(ahat))) 图 11.9: pos 位置参数 其中 labels， pos 都是向量化的参数 11.1.3 参考线 矩形网格线是用做背景参考线的，常常是淡灰色的细密虚线，plot 函数的 panel.first 参数和 grid 函数常用来画这种参考线 # modified from https://yihui.name/cn/2018/02/cohen-s-d/ n &lt;- 30 # 样本量（只是一个例子） x &lt;- seq(0, 12, 0.01) par(mar = c(4, 4, 0.2, 0.1)) plot(x / sqrt(n), 2 * (1 - pt(x, n - 1)), xlab = expression(d = x / sqrt(n)), type = &quot;l&quot;, panel.first = grid() ) abline(v = c(0.01, 0.2, 0.5, 0.8, 1.2, 2), lty = 2) 图 11.10: 添加背景参考线 11.1.4 坐标轴 图形控制参数默认设置下 par 通常的一幅图形，改变坐标轴标签是很简单的 x &lt;- 1:100 y &lt;- runif(100, -2, 2) plot(x, y) plot(x, y, xlab = &quot;Index&quot;, ylab = &quot;Uniform draws&quot;) 改变坐标轴标签和标题 op &lt;- par(no.readonly = TRUE) # 保存默认的 par 设置 par(cex.lab = 1.5, cex.axis = 1.3) plot(x, y, xlab = &quot;Index&quot;, ylab = &quot;Uniform draws&quot;) # 设置更大的坐标轴标签内容 par(mar = c(6, 6, 3, 3), cex.axis = 1.5, cex.lab = 2) plot(x, y, xlab = &quot;Index&quot;, ylab = &quot;Uniform draws&quot;) 使用 axis 函数可以更加精细地控制坐标轴 par(op) # 恢复默认的 par 设置 plot(x, y, xaxt = &quot;n&quot;) # 去掉 x 轴 axis(side = 1, at = c(5, 50, 100)) # 添加指定的刻度标签 指定刻度标签的内容 plot(x, y, yaxt = &quot;n&quot;) axis(side = 2, at = c(-2, 0, 2), labels = c(&quot;Small&quot;, &quot;Medium&quot;, &quot;Big&quot;)) 控制刻度线和轴线和刻度标签 plot(x, y) axis(side = 3, at = c(5, 25, 75), lwd = 4, lwd.ticks = 2, col.ticks = &quot;red&quot;) 还可以把 box 移除，绘图区域的边框去掉，只保留坐标轴 plot(x, y, bty = &quot;n&quot;, xaxt = &quot;n&quot;, yaxt = &quot;n&quot;) axis(side = 1, at = seq(0, 100, 20), lwd = 3) axis(side = 2, at = seq(-2, 2, 2), lwd = 3) # 双Y轴 N &lt;- 200 x &lt;- seq(-4, 4, length = N) y1 &lt;- sin(x) y2 &lt;- cos(x) op &lt;- par(mar = c(5, 4, 4, 4)) # Add some space in the right margin # The default is c(5,4,4,2) + .1 xlim &lt;- range(x) ylim &lt;- c(-1.1, 1.1) plot(x, y1, col = &quot;blue&quot;, type = &quot;l&quot;, xlim = xlim, ylim = ylim, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;, main = &quot;Title&quot; ) axis(1) axis(2, col = &quot;blue&quot;) par(new = TRUE) plot(x, y2, col = &quot;red&quot;, type = &quot;l&quot;, xlim = xlim, ylim = ylim, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;, main = &quot;&quot; ) axis(4, col = &quot;red&quot;) mtext(&quot;First Y axis&quot;, 2, line = 2, col = &quot;blue&quot;, cex = 1.2) mtext(&quot;Second Y axis&quot;, 4, line = 2, col = &quot;red&quot;, cex = 1.2) # 1,2,3,4 分别代表下左上右四个位置 图 11.11: 两个 Y 轴 调整坐标轴标签的距离 ## Changing default gap between labels: plot(c(0, 100), c(0, 50), type = &quot;n&quot;, axes = FALSE, ann = FALSE) title(quote(&quot;axis(1, .., gap.axis = f),&quot; ~ ~ f &gt;= 0)) axis(2, at = 5 * (0:10), las = 1, gap.axis = 1 / 4) gaps &lt;- c(4, 2, 1, 1 / 2, 1 / 4, 0.1, 0) chG &lt;- paste0( ifelse(gaps == 1, &quot;default: &quot;, &quot;&quot;), &quot;gap.axis=&quot;, formatC(gaps) ) jj &lt;- seq_along(gaps) linG &lt;- -2.5 * (jj - 1) for (j in jj) { isD &lt;- gaps[j] == 1 # is default axis(1, at = 5 * (0:20), gap.axis = gaps[j], padj = -1, line = linG[j], col.axis = if (isD) &quot;forest green&quot; else 1, font.axis = 1 + isD ) } mtext(chG, side = 1, padj = -1, line = linG - 1 / 2, cex = 3 / 4, col = ifelse(gaps == 1, &quot;forest green&quot;, &quot;blue3&quot;) ) ## now shrink the window (in x- and y-direction) and observe the axis labels drawn 图 11.12: gap.axis用法 旋转坐标轴标签 # Rotated axis labels in R plots # https://menugget.blogspot.com/2014/08/rotated-axis-labels-in-r-plots.html # Example data tmin &lt;- as.Date(&quot;2000-01-01&quot;) tmax &lt;- as.Date(&quot;2001-01-01&quot;) tlab &lt;- seq(tmin, tmax, by = &quot;month&quot;) lab &lt;- format(tlab, format = &quot;%Y-%b&quot;) set.seed(111) x &lt;- seq(tmin, tmax, length.out = 100) y &lt;- cumsum(rnorm(100)) # Plot # png(&quot;plot_w_rotated_axis_labels.png&quot;, height = 3, # width = 6, units = &quot;in&quot;, res = 300) op &lt;- par(mar = c(6, 4, 1, 1)) plot(x, y, t = &quot;l&quot;, xaxt = &quot;n&quot;, xlab = &quot;&quot;) axis(1, at = tlab, labels = FALSE) text( x = tlab, y = par()$usr[3] - 0.1 * (par()$usr[4] - par()$usr[3]), labels = lab, srt = 45, adj = 1, xpd = TRUE ) par(op) # dev.off() 旋转坐标抽标签的例子来自手册《R FAQ》的第7章第27个问题 (Hornik 2018)，在基础图形中，旋转坐标轴标签需要 text() 而不是 mtext()，因为后者不支持par(\"srt\") ## Increase bottom margin to make room for rotated labels par(mar = c(5, 4, .5, 2) + 0.1) ## Create plot with no x axis and no x axis label plot(1:8, xaxt = &quot;n&quot;, xlab = &quot;&quot;) ## Set up x axis with tick marks alone axis(1, labels = FALSE) ## Create some text labels labels &lt;- paste(&quot;Label&quot;, 1:8, sep = &quot; &quot;) ## Plot x axis labels at default tick marks text(1:8, par(&quot;usr&quot;)[3] - 0.5, srt = 45, adj = 1, labels = labels, xpd = TRUE ) ## Plot x axis label at line 6 (of 7) mtext(side = 1, text = &quot;X Axis Label&quot;, line = 4) 图 11.13: 旋转坐标轴标签 srt = 45 表示文本旋转角度， xpd = TRUE 允许文本越出绘图区域，adj = 1 to place the right end of text at the tick marks；You can adjust the value of the 0.5 offset as required to move the axis labels up or down relative to the x axis. 详细地参考 (Murrell 2003) 11.1.5 刻度线 通过 par 或 axis 函数实现刻度线的精细操作，tcl 控制刻度线的长度，正值让刻度画在绘图区域内，负值正好相反，画在外面，mgp 参数有三个值，第一个值控制绘图区域和坐标轴标题之间的行数，第二个是绘图区域与坐标轴标签的行数，第三个绘图区域与轴线的行数，行数表示间距 par(tcl = 0.4, mgp = c(1.5, 0, 0)) plot(x, y) # 又一个例子 par(op) plot(x, y, xaxt = &quot;n&quot;, yaxt = &quot;n&quot;, xlab = &quot;&quot;, ylab = &quot;&quot;) axis(side = 1, at = seq(5, 95, 30), tcl = 0.4, lwd.ticks = 3, mgp = c(0, 0.5, 0)) mtext(side = 1, text = &quot;X axis&quot;, line = 1.5) # mtext 设置坐标轴标签 axis(side = 2, at = seq(-2, 2, 2), tcl = 0.3, lwd.ticks = 3, col.ticks = &quot;orange&quot;, mgp = c(0, 0, 2)) mtext(side = 2, text = &quot;Numbers taken randomly&quot;, line = 2.2) 11.1.6 标题 添加多个标题 N &lt;- 200 x &lt;- runif(N, -4, 4) y &lt;- sin(x) + .5 * rnorm(N) plot(x, y, xlab = &quot;&quot;, ylab = &quot;&quot;, main = &quot;&quot;) mtext(&quot;Subtitle&quot;, 3, line = .8) mtext(&quot;Title&quot;, 3, line = 2, cex = 1.5) mtext(&quot;X axis&quot;, 1, line = 2.5, cex = 1.5) mtext(&quot;X axis subtitle&quot;, 1, line = 3.7) 图 11.14: 图标题/子标题 x轴标题/子标题 11.1.7 注释 数学符号注释，图11.15 自定义坐标轴 (Murrell and Ihaka 2000)。 # 自定义坐标轴 plot(c(1, 1e6), c(-pi, pi), type = &quot;n&quot;, axes = FALSE, ann = FALSE, log = &quot;x&quot; ) axis(1, at = c(1, 1e2, 1e4, 1e6), labels = expression(1, 10^2, 10^4, 10^6) ) axis(2, at = c(-pi, -pi / 2, 0, pi / 2, pi), labels = expression(-pi, -pi / 2, 0, pi / 2, pi) ) text(1e3, 0, expression(italic(&quot;Customized Axes&quot;))) box() 图 11.15: 创建自定义的坐标轴和刻度标签 在标题中添加数学公式 x &lt;- seq(-5, 5, length = 200) y &lt;- sqrt(1 + x^2) plot(y ~ x, type = &quot;l&quot;, ylab = expression(sqrt(1 + x^2)) ) title(main = expression( &quot;graph of the function f&quot;(x) == sqrt(1 + x^2) )) 图 11.16: 标题含有数学公式 修改参数使用 substitute 函数批量生成 x &lt;- seq(-5, 5, length = 200) for (i in 1:4) { # 画四个图 y &lt;- sqrt(i + x^2) plot(y ~ x, type = &quot;l&quot;, ylim = c(0, 6), ylab = substitute( expression(sqrt(i + x^2)), list(i = i) ) ) title(main = substitute( &quot;graph of the function f&quot;(x) == sqrt(i + x^2), list(i = i) )) } 图 11.17: 批量生成函数图形 基础绘图函数，如 plot 标签 xlab 支持 Unicode 代码表示的希腊字母，常用字母表备查，公式环境下，也可以用在绘图中 表 11.1: 希腊字母表 希腊字母 LaTeX 代码 Unicode 代码 希腊字母 LaTeX 代码 Unicode 代码 \\(\\alpha\\) \\alpha \\u03B1 \\(\\mu\\) \\mu \\u03BC \\(\\beta\\) \\beta \\u03B2 \\(\\nu\\) \\nu \\u03BD \\(\\gamma\\) \\gamma \\u03B3 \\(\\xi\\) \\xi \\u03BE \\(\\delta\\) \\delta \\u03B4 \\(\\varphi\\) \\varphi \\u03C6 \\(\\epsilon\\) \\epsilon \\u03B5 \\(\\pi\\) \\pi \\u03C0 \\(\\zeta\\) \\zeta \\u03B6 \\(\\rho\\) \\rho \\u03C1 \\(\\eta\\) \\eta \\u03B7 \\(\\upsilon\\) \\upsilon \\u03C5 \\(\\theta\\) \\theta \\u03B8 \\(\\phi\\) \\phi \\u03C6 \\(\\iota\\) \\iota \\u03B9 \\(\\chi\\) \\chi \\u03C7 \\(\\kappa\\) \\kappa \\u03BA \\(\\psi\\) \\psi \\u03C8 \\(\\lambda\\) \\lambda \\u03BB \\(\\omega\\) \\omega \\u03C9 \\(\\sigma\\) \\sigma \\u03C3 \\(\\tau\\) \\tau \\u03C4 表 11.2: 数字上下标 上标数字 LaTeX 代码 Unicode 代码 下标数字 LaTeX 代码 Unicode 代码 \\({}^0\\) {}^0 \\u2070 \\({}_0\\) {}_0 \\u2080 \\({}^1\\) {}^1 \\u00B9 \\({}_1\\) {}_1 \\u2081 \\({}^2\\) {}^2 \\u00B2 \\({}_2\\) {}_2 \\u2082 \\({}^3\\) {}^3 \\u00B2 \\({}_3\\) {}_3 \\u2083 \\({}^4\\) {}^4 \\u2074 \\({}_4\\) {}_4 \\u2084 \\({}^5\\) {}^5 \\u2075 \\({}_5\\) {}_5 \\u2085 \\({}^6\\) {}^6 \\u2076 \\({}_6\\) {}_6 \\u2086 \\({}^7\\) {}^7 \\u2077 \\({}_7\\) {}_7 \\u2087 \\({}^8\\) {}^8 \\u2078 \\({}_8\\) {}_8 \\u2088 \\({}^9\\) {}^9 \\u2079 \\({}_9\\) {}_9 \\u2089 \\({}^n\\) {}^n \\u207F \\({}_n\\) {}_n - 其它字母，请查看 Unicode 字母表 11.1.8 图例 x &lt;- seq(-6, 6, length = 200) y &lt;- sin(x) z &lt;- cos(x) plot(y ~ x, type = &quot;l&quot;, lwd = 3, ylab = &quot;&quot;, xlab = &quot;angle&quot;, main = &quot;Trigonometric functions&quot; ) abline(h = 0, lty = 3) abline(v = 0, lty = 3) lines(z ~ x, type = &quot;l&quot;, lwd = 3, col = &quot;red&quot;) legend(-6, -1, yjust = 0, c(&quot;Sine&quot;, &quot;Cosine&quot;), lwd = 3, lty = 1, col = c(par(&quot;fg&quot;), &quot;red&quot;) ) 图 11.18: 三角函数添加图例 xmin &lt;- par(&quot;usr&quot;)[1] xmax &lt;- par(&quot;usr&quot;)[2] ymin &lt;- par(&quot;usr&quot;)[3] ymax &lt;- par(&quot;usr&quot;)[4] plot(y ~ x, type = &quot;l&quot;, lwd = 3, ylab = &quot;&quot;, xlab = &quot;angle&quot;, main = &quot;Trigonometric functions&quot; ) abline(h = 0, lty = 3) abline(v = 0, lty = 3) lines(z ~ x, type = &quot;l&quot;, lwd = 3, col = &quot;red&quot;) legend(&quot;bottomleft&quot;, c(&quot;Sine&quot;, &quot;Cosine&quot;), lwd = 3, lty = 1, col = c(par(&quot;fg&quot;), &quot;red&quot;) ) 图 11.19: 设置图例的位置 plot(y ~ x, type = &quot;l&quot;, lwd = 3, ylab = &quot;&quot;, xlab = &quot;angle&quot;, main = &quot;Trigonometric functions&quot; ) abline(h = 0, lty = 3) abline(v = 0, lty = 3) lines(z ~ x, type = &quot;l&quot;, lwd = 3, col = &quot;red&quot;) legend(&quot;bottomleft&quot;, c(&quot;Sine&quot;, &quot;Cosine&quot;), inset = c(.03, .03), lwd = 3, lty = 1, col = c(par(&quot;fg&quot;), &quot;red&quot;) ) 图 11.20: insert 函数微调图例位置 op &lt;- par(no.readonly = TRUE) plot(y ~ x, type = &quot;l&quot;, lwd = 3, ylab = &quot;&quot;, xlab = &quot;angle&quot;, main = &quot;Trigonometric functions&quot; ) abline(h = 0, lty = 3) abline(v = 0, lty = 3) lines(z ~ x, type = &quot;l&quot;, lwd = 3, col = &quot;red&quot;) par(xpd = TRUE) # Do not clip to the drawing area 关键一行/允许出界 lambda &lt;- .025 legend(par(&quot;usr&quot;)[1], (1 + lambda) * par(&quot;usr&quot;)[4] - lambda * par(&quot;usr&quot;)[3], c(&quot;Sine&quot;, &quot;Cosine&quot;), xjust = 0, yjust = 0, lwd = 3, lty = 1, col = c(par(&quot;fg&quot;), &quot;red&quot;) ) par(op) 图 11.21: 将图例放在绘图区域外面 Hmisc 包的 labcurve 函数可以在曲线上放置名称，而不是遥远的图例上 11.1.9 边空 边空分为内边空和外边空 图 11.22: 边空 line 第一行 N &lt;- 200 x &lt;- runif(N, -4, 4) y &lt;- sin(x) + .5 * rnorm(N) plot(x, y, xlab = &quot;&quot;, ylab = &quot;&quot;, main = paste( &quot;The \\&quot;mtext\\&quot; function&quot;, paste(rep(&quot; &quot;, 60), collapse = &quot;&quot;) ) ) for (i in seq(from = 0, to = 1, by = 1)) { mtext(paste(&quot;Line&quot;, i), 3, line = i) } 图 11.23: 外边空在图的边缘添加文字 par # 多图排列/分屏 page 47 # 最常用的是 par mfrow mfcol分别按行/列放置图形 op &lt;- par( mfrow = c(2, 2), oma = c(0, 0, 4, 0) # Outer margins ) for (i in 1:4) { plot(runif(20), runif(20), main = paste(&quot;random plot (&quot;, i, &quot;)&quot;, sep = &quot;&quot;) ) } par(op) mtext(&quot;Four plots, without enough room for this title&quot;, side = 3, font = 2, cex = 1.5, col = &quot;red&quot; ) # 总/大标题放不下 图 11.24: 多图排列共享一个大标题 par 的 oma 用来设置外边空的大小，默认情形下没有外边空的 par()$oma #&gt; [1] 0 0 0 0 我们可以自己设置外边空 op &lt;- par( mfrow = c(2, 2), oma = c(0, 0, 3, 0) # Outer margins ) for (i in 1:4) { plot(runif(20), runif(20), main = paste(&quot;random plot (&quot;, i, &quot;)&quot;, sep = &quot;&quot;) ) } par(op) mtext(&quot;Four plots, with some room for this title&quot;, side = 3, line = 1.5, font = 1, cex = 1.5, col = &quot;red&quot; ) 图 11.25: 设置外边空放置大标题 除了内边空还有外边空，内外边空用来放注释说明 op &lt;- par(no.readonly = TRUE) par(oma = c(2, 2, 2, 2)) plot(1, 1, type = &quot;n&quot;, xlab = &quot;&quot;, ylab = &quot;&quot;, xaxt = &quot;n&quot;, yaxt = &quot;n&quot;) for (side in 1:4) { inner &lt;- round(par()$mar[side], 0) - 1 for (line in 0:inner) { mtext(text = paste0(&quot;Inner line &quot;, line), side = side, line = line) } outer &lt;- round(par()$oma[side], 0) - 1 for (line in 0:inner) { mtext(text = paste0(&quot;Outer line &quot;, line), side = side, line = line, outer = TRUE) } } 外边空可以用来放图例 set.seed(1234) x &lt;- runif(10) y &lt;- runif(10) cols &lt;- rep(hcl.colors(5), each = 2) op &lt;- par(oma = c(2, 2, 0, 4), mar = c(3, 3, 2, 0), mfrow = c(2, 2), pch = 16) for (i in 1:4) { plot(x, y, col = cols, ylab = &quot;&quot;, xlab = &quot;&quot;) } mtext(text = &quot;A common x-axis label&quot;, side = 1, line = 0, outer = TRUE) mtext(text = &quot;A common y-axis label&quot;, side = 2, line = 0, outer = TRUE) legend( x = 1, y = 1.2, legend = LETTERS[1:5], col = unique(cols), pch = 16, bty = &quot;n&quot;, xpd = NA ) par(op) 坐标轴标签 xlab 和 ylab 的内容很长的时候需要内边空 par(cex.lab = 1.7) plot(1, 1, ylab = &quot;A very very long axis title\\nthat need special care&quot;, xlab = &quot;&quot;, type = &quot;n&quot; ) # 增加内边空的大小 par(mar = c(5, 7, 4, 2)) plot(1, 1, ylab = &quot;A very very long axis title\\nthat need special care&quot;, xlab = &quot;&quot;, type = &quot;n&quot; ) 有时候，仅仅增加内边空还不够，坐标轴标签内容甚至可以出现在绘图区域外面，设置 outer = TRUE par(oma = c(0, 4, 0, 0)) plot(1, 1, ylab = &quot;&quot;, xlab = &quot;&quot;, type = &quot;n&quot;) mtext( text = &quot;A very very long axis title\\nthat need special care&quot;, side = 2, line = 0, outer = TRUE, cex = 1.7 ) op &lt;- par( mfrow = c(2, 2), oma = c(0, 0, 3, 0), mar = c(3, 3, 4, 1) + .1 # Margins ) for (i in 1:4) { plot(runif(20), runif(20), xlab = &quot;&quot;, ylab = &quot;&quot;, main = paste(&quot;random plot (&quot;, i, &quot;)&quot;, sep = &quot;&quot;) ) } par(op) mtext(&quot;Title&quot;, side = 3, line = 1.5, font = 2, cex = 2, col = &quot;red&quot; ) 图 11.26: 设置每个子图的边空 mar 11.1.10 图层 覆盖图形 add = T or par(new=TRUE) plot(runif(5), runif(5), xlim = c(0, 1), ylim = c(0, 1) ) points(runif(5), runif(5), col = &quot;#EA4335&quot;, pch = 16, cex = 3 ) lines(runif(5), runif(5), col = &quot;red&quot;) segments(runif(5), runif(5), runif(5), runif(5), col = &quot;blue&quot; ) title(main = &quot;Overlaying points, segments, lines...&quot;) 图 11.27: 添加图层 11.1.11 布局 layout 函数布局， 绘制复杂组合图形 op &lt;- par(oma = c(0, 0, 3, 0)) layout(matrix(c( 1, 1, 1, 2, 3, 4, 2, 3, 4 ), nr = 3, byrow = TRUE)) hist(rnorm(n), col = &quot;light blue&quot;) hist(rnorm(n), col = &quot;light blue&quot;) hist(rnorm(n), col = &quot;light blue&quot;) hist(rnorm(n), col = &quot;light blue&quot;) mtext(&quot;The \\&quot;layout\\&quot; function&quot;, side = 3, outer = TRUE, font = 2, cex = 1.2 ) 图 11.28: 更加复杂的组合图形 11.1.12 组合 par 之 fig 参数很神奇，使得多个图可以叠加在一起，它接受一个数值向量c(x1, x2, y1, y2) ，是图形设备显示区域中的绘图区域的(NDC, normalized device coordinates)坐标。 plot(1:12, type = &quot;b&quot;, main = &quot;&#39;fg&#39; : axes, ticks and box in gray&quot;, fg = gray(0.7), bty = &quot;7&quot;, sub = R.version.string ) par(fig = c(1, 6, 5, 10) / 10, new = T) plot(6:10, type = &quot;b&quot;, main = &quot;&quot;, fg = gray(0.7), bty = &quot;7&quot;, xlab = R.version.string ) 图 11.29: 多图叠加 fig 参数控制图形的位置，用来绘制组合图形 n &lt;- 1000 x &lt;- rt(n, df = 10) hist(x, col = &quot;light blue&quot;, probability = &quot;TRUE&quot;, main = &quot;&quot;, ylim = c(0, 1.2 * max(density(x)$y)) ) lines(density(x), col = &quot;red&quot;, lwd = 3 ) op &lt;- par( fig = c(.02, .4, .5, .98), new = TRUE ) qqnorm(x, xlab = &quot;&quot;, ylab = &quot;&quot;, main = &quot;&quot;, axes = FALSE ) qqline(x, col = &quot;red&quot;, lwd = 2) box(lwd = 2) par(op) 图 11.30: 组合图形 11.1.13 分屏 split.screen 分屏组合 random.plot &lt;- function() { N &lt;- 200 f &lt;- sample( list( rnorm, function(x) { rt(x, df = 2) }, rlnorm, runif ), 1 ) [[1]] x &lt;- f(N) hist(x, col = &quot;lightblue&quot;, main = &quot;&quot;, xlab = &quot;&quot;, ylab = &quot;&quot;, axes = F) axis(1) } op &lt;- par(bg = &quot;white&quot;, mar = c(2.5, 2, 1, 2)) split.screen(c(2, 1)) #&gt; [1] 1 2 split.screen(c(1, 3), screen = 2) #&gt; [1] 3 4 5 screen(1) random.plot() # screen(2); random.plot() # Screen 2 was split into three screens: 3, 4, 5 screen(3) random.plot() screen(4) random.plot() screen(5) random.plot() close.screen(all = TRUE) par(op) 图 11.31: 分屏 11.1.14 交互 辅助绘图 identify locator 11.2 统计图形 按图的类型划分，最后在小结部分给出各图适用的数据类型 根据数据类型划分： 对于一元数据，可用什么图来描述；多元数据呢，连续数据和离散数据（分类数据） 先找一个不重不漏的划分，指导原则是根据数据类型选择图，根据探索到的数据中的规律，选择图 其它 assocplot fourfoldplot sunflowerplot 11.2.1 条形图 条形图 简单条形图 data(diamonds, package = &quot;ggplot2&quot;) # 加载数据 par(mar = c(2, 5, 1, 1)) barCenters &lt;- barplot(table(diamonds$cut), col = &quot;lightblue&quot;, axes = FALSE, axisnames = FALSE, horiz = TRUE, border = &quot;white&quot; ) text( y = barCenters, x = par(&quot;usr&quot;)[3], adj = 1, labels = names(table(diamonds$cut)), xpd = TRUE ) axis(1, labels = seq(0, 25000, by = 5000), at = seq(0, 25000, by = 5000), las = 1, col = &quot;gray&quot; ) grid() 图 11.32: 条形图 简单柱形图 set.seed(123456) barPois &lt;- table(stats::rpois(1000, lambda = 5)) plot(barPois, col = &quot;lightblue&quot;, type = &quot;h&quot;, lwd = 10, main = &quot;&quot;) box(col = &quot;gray&quot;) 图 11.33: 柱形图 复合条形图 par(mar = c(4.1, 2.1, 0.5, 4.5)) barplot(VADeaths, border = &quot;white&quot;, horiz = FALSE, col = hcl.colors(5), legend.text = rownames(VADeaths), xpd = TRUE, beside = TRUE, cex.names = 0.9, args.legend = list( x = &quot;right&quot;, border = &quot;white&quot;, title = &quot;Age&quot;, box.col = NA, horiz = FALSE, inset = c(-.2, 0), xpd = TRUE ), panel.first = grid(nx = 0, ny = 7) ) 图 11.34: 复合条形图 堆积条形图 par(mar = c(4.1, 2.1, 0.5, 4.5)) barplot(VADeaths, border = &quot;white&quot;, horiz = FALSE, col = hcl.colors(5), legend.text = rownames(VADeaths), xpd = TRUE, beside = FALSE, cex.names = 0.9, args.legend = list( x = &quot;right&quot;, border = &quot;white&quot;, title = &quot;Age&quot;, box.col = NA, horiz = FALSE, inset = c(-.2, 0), xpd = TRUE ), panel.first = grid(nx = 0, ny = 4) ) 图 11.35: 堆积条形图 堆积条形图 spineplot 简单条形图 barplot( data = BOD, demand ~ Time, ylim = c(0, 20), border = &quot;white&quot;, horiz = FALSE, col = hcl.colors(1) ) pg_mean &lt;- aggregate(weight ~ group, data = PlantGrowth, mean) barplot( data = pg_mean, weight ~ group, border = &quot;white&quot;, horiz = FALSE, col = hcl.colors(3) ) Titanic 数据集是 table 数据类型 简单条形图 复合条形图 barplot(Freq ~ Class + Survived, data = Titanic, subset = Age == &quot;Adult&quot; &amp; Sex == &quot;Male&quot;, beside = TRUE, border = &quot;white&quot;, horiz = FALSE, col = hcl.colors(4), args.legend = list( border = &quot;white&quot;, title = &quot;Class&quot;, box.col = NA, horiz = FALSE, xpd = TRUE ), ylab = &quot;# {passengers}&quot;, legend = TRUE ) 堆积条形图 barplot(Freq ~ Class + Survived, data = Titanic, subset = Age == &quot;Adult&quot; &amp; Sex == &quot;Male&quot;, border = &quot;white&quot;, horiz = FALSE, col = hcl.colors(4), args.legend = list( border = &quot;white&quot;, title = &quot;Class&quot;, box.col = NA, horiz = FALSE, xpd = TRUE ), ylab = &quot;# {passengers}&quot;, legend = TRUE ) 11.2.2 直方图 set.seed(1234) n &lt;- 2^24 x &lt;- runif(n, 0, 1) delta &lt;- 0.01 len &lt;- diff(c(0, which(x &lt; delta), n + 1)) - 1 ylim &lt;- seq(0, 1800, by = 300) xlim &lt;- seq(0, 100, by = 20) p &lt;- hist(len[len &lt; 101], breaks = -1:100 + 0.5, plot = FALSE) plot(p, ann = FALSE, axes = FALSE, col = &quot;lightblue&quot;, border = &quot;white&quot;, main = &quot;&quot;) axis(1, labels = xlim, at = xlim, las = 1) # x 轴 axis(2, labels = ylim, at = ylim, las = 0) # y 轴 box(col = &quot;gray&quot;) 图 11.36: 直方图 with(faithful, plot(eruptions ~ waiting, pch = 16)) with(faithful, hist(waiting, main = &quot;Time between Old Faithful eruptions&quot;, xlab = &quot;Minutes&quot;, ylab = &quot;&quot;, cex.main = 1.5, cex.lab = 1.5, cex.axis = 1.4 )) with(data = faithful, { hist(eruptions, seq(1.6, 5.2, 0.2), prob = TRUE, main = &quot;&quot;, col = &quot;lightblue&quot;, border = &quot;white&quot; ) lines(density(eruptions, bw = 0.1), col = &quot;#EA4335&quot;) rug(eruptions, col = &quot;#EA4335&quot;) # 添加数据点 }) 图 11.37: 老忠实泉间歇性喷水的时间间隔分布 hist(longley$Unemployed, probability = TRUE, col = &quot;light blue&quot;, main = &quot;&quot; ) # 添加密度估计 lines(density(longley$Unemployed), col = &quot;red&quot;, lwd = 3 ) 图 11.38: 概率密度分布 直方图有很多花样的，添加阴影线，angle 控制倾斜的角度 # hist(longley$Unemployed, density = 1, angle = 45) # hist(longley$Unemployed, density = 3, angle = 15) # hist(longley$Unemployed, density = 1, angle = 15) hist(longley$Unemployed, density = 3, angle = 45, main = &quot;&quot;) 图 11.39: density 数值越大阴影线越密 11.2.3 密度图 data(galaxies, package = &quot;MASS&quot;) galaxies &lt;- galaxies / 1000 # Bandwidth Selection by Pilot Estimation of Derivatives c(MASS::width.SJ(galaxies, method = &quot;dpi&quot;), MASS::width.SJ(galaxies)) #&gt; [1] 3.256151 2.566423 plot( x = c(5, 40), y = c(0, 0.2), type = &quot;n&quot;, bty = &quot;l&quot;, xlab = &quot;velocity of galaxy (km/s)&quot;, ylab = &quot;density&quot; ) rug(galaxies) lines(density(galaxies, width = 3.25, n = 200), col = &quot;blue&quot;, lty = 1) lines(density(galaxies, width = 2.56, n = 200), col = &quot;red&quot;, lty = 3) x &lt;- seq(from = 110, to = 174, by = 0.5) y1 &lt;- dnorm(x, mean = 145, sd = 9) y2 &lt;- dnorm(x, mean = 138, sd = 8) plot(x, y1, type = &quot;l&quot;, lwd = 2, col = &quot;red&quot;, main = &quot;Systolic Blood Pressure Before and After Treatment&quot;, xlab = &quot;Systolic Blood Pressure (mmHg)&quot;, ylab = &quot;Frequency&quot;, yaxt = &quot;n&quot;, xlim = c(110, 175), ylim = c(0, 0.05) ) lines(x, y2) polygon(c(110, x, 175), c(0, y2, 0), col = &quot;firebrick3&quot;, border = &quot;white&quot; ) polygon(c(117, x, 175), c(0, y1, 0), col = &quot;dodgerblue4&quot;, border = &quot;white&quot; ) ylab &lt;- c(seq(from = 0, to = 175, by = 25)) y &lt;- c(seq(from = 0, to = 0.05, length.out = 8)) axis(2, at = y, labels = ylab, las = 1) text(x = 120, y = 0.045, &quot;- Pre-Treatment BP&quot;, col = &quot;dodgerblue4&quot;, cex = 0.9) text(x = 120, y = 0.04, &quot; - Post-Treatment BP&quot;, col = &quot;firebrick3&quot;, cex = 0.9) points(109, 0.0445, pch = 15, col = &quot;dodgerblue4&quot;) points(109, 0.0395, pch = 15, col = &quot;firebrick3&quot;) days &lt;- abs(rnorm(1000, 80, 125)) plot(density(days, from = 0), main = &quot;Density plot&quot;, xlab = &quot;Number of days since trial started&quot; ) plot(density(days, from = 0, to = 180, adjust = 0.2), main = &quot;Density plot - Up to 180 days (86% of data)&quot;, xlab = &quot;Number of days since trial started&quot; ) library(survival) surv.days &lt;- Surv(days) surv.fit &lt;- survfit(surv.days ~ 1) plot(surv.fit, main = &quot;Kaplan-Meier estimate with 95% confidence bounds (86% of data)&quot;, xlab = &quot;Days since trial started&quot;, xlim = c(0, 180), ylab = &quot;Survival function&quot; ) grid(20, 10, lwd = 2) 11.2.4 经验图 with(data = faithful, { long &lt;- eruptions[eruptions &gt; 3] plot(ecdf(long), do.points = FALSE, verticals = TRUE, main = &quot;&quot;) x &lt;- seq(3, 5.4, 0.01) lines(x, pnorm(x, mean = mean(long), sd = sqrt(var(long))), lty = 3) }) 图 11.40: 累积经验分布图 11.2.5 QQ 图 with(data = faithful, { long &lt;- eruptions[eruptions &gt; 3] par(pty = &quot;s&quot;) # arrange for a square figure region qqnorm(long, main = &quot;&quot;) qqline(long) }) 11.2.6 时序图 时序图最适合用来描述股价走势 matplot(time(EuStockMarkets), EuStockMarkets, main = &quot;&quot;, xlab = &quot;Date&quot;, ylab = &quot;closing prices&quot;, pch = 17, type = &quot;l&quot;, col = 1:4 ) legend(&quot;topleft&quot;, colnames(EuStockMarkets), pch = 17, lty = 1, col = 1:4) 图 11.41: 1991–1998年间主要欧洲股票市场日闭市价格指数图 德国 DAX (Ibis), Switzerland SMI, 法国 CAC 和 英国 FTSE 11.2.7 饼图 clockwise 参数 pie.sales &lt;- c(0.12, 0.3, 0.26, 0.16, 0.04, 0.12) names(pie.sales) &lt;- c( &quot;Blueberry&quot;, &quot;Cherry&quot;, &quot;Apple&quot;, &quot;Boston Cream&quot;, &quot;Other&quot;, &quot;Vanilla Cream&quot; ) pie(pie.sales, clockwise = TRUE, main = &quot;&quot;) segments(0, 0, 0, 1, col = &quot;red&quot;, lwd = 2) text(0, 1, &quot;init.angle = 90&quot;, col = &quot;red&quot;) 11.2.8 茎叶图 stem(longley$Unemployed) #&gt; #&gt; The decimal point is 2 digit(s) to the right of the | #&gt; #&gt; 1 | 99 #&gt; 2 | 134899 #&gt; 3 | 46789 #&gt; 4 | 078 11.2.9 散点图 在一维空间上，绘制散点图，其实是在看散点的疏密程度随坐标轴的变化 stripchart(longley$Unemployed, method = &quot;jitter&quot;, jitter = 0.1, pch = 16, col = &quot;lightblue&quot;) stripchart(longley$Unemployed, method = &quot;overplot&quot;, pch = 16, col = &quot;lightblue&quot;) 图 11.42: 一维散点图 气泡图是二维散点图的一种变体，气泡的大小可以用来描述第三个变量，下面以数据集 topo 为例展示气泡图 # 加载数据集 data(topo, package = &quot;MASS&quot;) # 查看数据集 str(topo) #&gt; &#39;data.frame&#39;: 52 obs. of 3 variables: #&gt; $ x: num 0.3 1.4 2.4 3.6 5.7 1.6 2.9 3.4 3.4 4.8 ... #&gt; $ y: num 6.1 6.2 6.1 6.2 6.2 5.2 5.1 5.3 5.7 5.6 ... #&gt; $ z: int 870 793 755 690 800 800 730 728 710 780 ... topo 是空间地形数据集，包含有52行3列，数据点是310平方英尺范围内的海拔高度数据，x 坐标每单位50英尺，y 坐标单位同 x 坐标，海拔高度 z 单位是英尺 plot(y ~ x, cex = (960 - z) / (960 - 690) * 3, data = topo, xlab = &quot;X Coordinates&quot;, ylab = &quot;Y coordinates&quot; ) 图 11.43: 地形图之海拔高度 散点图也适合分类数据的展示，在图中用不同颜色或符号标记数据点所属类别，即在普通散点图的基础上添加一分类变量的描述 plot(mpg ~ hp, data = subset(mtcars, am == 1), pch = 16, col = &quot;blue&quot;, xlim = c(50, 350), ylim = c(10, 35) ) points(mpg ~ hp, col = &quot;red&quot;, pch = 16, data = subset(mtcars, am == 0) ) legend(300, 35, c(&quot;1&quot;, &quot;0&quot;), title = &quot;am&quot;, col = c(&quot;blue&quot;, &quot;red&quot;), pch = c(16, 16) ) 图 11.44: 分类散点图 iris 数据 plot(Sepal.Length ~ Sepal.Width, data = iris, col = Species, pch = 16) legend(&quot;topright&quot;, legend = unique(iris$Species), box.col = &quot;gray&quot;, pch = 16, col = unique(iris$Species) ) box(col = &quot;gray&quot;) 图 11.45: 分类散点图 分组散点图和平滑 library(carData) library(car) scatterplot(Sepal.Length ~ Sepal.Width, col = c(&quot;black&quot;, &quot;red&quot;, &quot;blue&quot;), pch = c(16, 16, 16), smooth = TRUE, boxplots = &quot;xy&quot;, groups = iris$Species, xlab = &quot;Sepal.Width&quot;, ylab = &quot;Sepal.Length&quot;, data = iris ) 有时为了实现特定的目的，需要高亮其中某些点，按类别或者因子变量分组绘制散点图，这里继续采用 stripchart 函数绘制二维散点图11.46， 由左图可知，函数 stripchart 提供的参数 pch 不接受向量，实际只是取了前三个值 16 16 17 对应于 Species 的三类，关键是高亮的分界点是有区分意义的 data(&quot;iris&quot;) pch &lt;- rep(16, length(iris$Petal.Length)) pch[which(iris$Petal.Length &lt; 1.4)] &lt;- 17 stripchart(Petal.Length ~ Species, data = iris, vertical = TRUE, method = &quot;jitter&quot;, pch = pch ) # 对比一下 stripchart(Petal.Length ~ Species, data = iris, subset = Petal.Length &gt; 1.4, vertical = TRUE, method = &quot;jitter&quot;, ylim = c(1, 7), pch = 16 ) stripchart(Petal.Length ~ Species, data = iris, subset = Petal.Length &lt; 1.4, vertical = TRUE, method = &quot;jitter&quot;, add = TRUE, pch = 17, col = &quot;red&quot; ) 图 11.46: 高亮图中部分散点 如果存在大量散点 densCols(x, y = NULL, nbin = 128, bandwidth, colramp = colorRampPalette(blues9[-(1:3)]) ) densCols 函数根据点的局部密度生成颜色，密度估计采用核平滑法，由 KernSmooth 包的 bkde2D 函数实现。参数 colramp 传递一个函数，colorRampPalette 根据给定的几种颜色生成函数，参数 bandwidth 实际上是传给 bkde2D 函数 x1 &lt;- matrix(rnorm(1e3), ncol = 2) x2 &lt;- matrix(rnorm(1e3, mean = 3, sd = 1.5), ncol = 2) x &lt;- rbind(x1, x2) dcols &lt;- densCols(x) graphics::plot(x, col = dcols, pch = 20, panel.first = grid()) # title(main = &quot;n = 1000&quot;, xpd = TRUE) 图 11.47: 根据点的密度生成颜色 气泡图也是散点图的一种 plot(Volume ~ Height, data = trees, pch = 16, cex = Girth / 8, col = rev(terrain.colors(nrow(trees), alpha = .5)) ) box(col = &quot;gray&quot;) 图 11.48: 气泡图 气泡图 # 空白画布 plot(c(1, 5, 10), c(1, 5, 10), panel.first = grid(10, 10), type = &quot;n&quot;, axes = FALSE, ann = FALSE) # 添加坐标轴 axis(1, at = seq(10), labels = TRUE) axis(2, at = seq(10), labels = TRUE) par(new = TRUE) # 在当前图形上添加图形 # axes 坐标轴上的刻度 &quot;xaxt&quot; or &quot;yaxt&quot; ann 坐标轴和标题的标签 set.seed(1234) plot(rnorm(100, 5, 1), rnorm(100, 5, 1), cex = runif(100, 0, 2), col = hcl.colors(4)[rep(seq(4), 100)], bg = paste0(&quot;gray&quot;, replicate(100, sample(seq(100), 1, replace = TRUE))), axes = FALSE, ann = FALSE, pch = 21, lwd = 2 ) legend(&quot;top&quot;, legend = paste0(&quot;class&quot;, seq(4)), col = hcl.colors(4), pt.lwd = 2, pch = 21, box.col = &quot;gray&quot;, horiz = TRUE ) 除了par(new=TRUE)设置外，有些函数本身就具有 add 选项 set.seed(1234) plot(dist ~ speed, data = cars, pch = 17, col = &quot;red&quot;, cex = 1) with(cars, symbols(dist ~ speed, circles = runif(length(speed), 0, 1), pch = 16, inches = .5, add = TRUE )) z &lt;- lm(dist ~ speed, data = cars) abline(z, col = &quot;blue&quot;) curve(tan, from = 0, to = 8 * pi, n = 100, add = TRUE) lines(stats::lowess(cars)) points(10, 100, pch = 16, cex = 3, col = &quot;green&quot;) text(10, 80, &quot;text here&quot;, cex = 3) 11.2.10 抖动图 抖动散点图 mat &lt;- matrix(1:length(colors()), ncol = 9, byrow = TRUE) df &lt;- data.frame( col = colors(), x = as.integer(cut(1:length(colors()), 9)), y = rep(1:73, 9), stringsAsFactors = FALSE ) par(mar = c(4, 4, 1, 0.1)) plot(y ~ jitter(x), data = df, col = df$col, pch = 16, main = &quot;Visualizing colors() split in 9 groups&quot;, xlab = &quot;Group&quot;, ylab = &quot;Element of the group (min = 1, max = 73)&quot;, sub = &quot;x = 3, y = 1 means that it&#39;s the 2 * 73 + 1 = 147th color&quot; ) 图 11.49: 抖动散点图 11.2.11 箱线图 boxplotdbl: Double Box Plot for Two-Axes Correlation. Correlation chart of two set (x and y) of data. Using Quartiles with boxplot style. Visualize the effect of factor. 复合箱线图 A &lt;- c( 79.98, 80.04, 80.02, 80.04, 80.03, 80.03, 80.04, 79.97, 80.05, 80.03, 80.02, 80, 80.02 ) B &lt;- c(80.02, 79.94, 79.98, 79.97, 79.97, 80.03, 79.95, 79.97) boxplot(A, B) with(data = iris, { op &lt;- par(mfrow = c(2, 2), mar = c(4, 4, 2, .5)) plot(Sepal.Length ~ Species) plot(Sepal.Width ~ Species) plot(Petal.Length ~ Species) plot(Petal.Width ~ Species) par(op) mtext(&quot;Edgar Anderson&#39;s Iris Data&quot;, side = 3, line = 4) }) 图 11.50: 安德森的鸢尾花数据 箱线图的花样也很多 boxplot(longley$Unemployed) # 水平放置 boxplot(longley$Unemployed, horizontal = TRUE, col = &quot;pink&quot;, main = &quot;&quot; ) data(InsectSprays) boxplot(count ~ spray, data = InsectSprays, col = &quot;pink&quot;, xlab = &quot;Spray&quot;, ylab = &quot;Count&quot;, main = &quot;&quot; ) 水平放置 boxplot(count ~ spray, data = InsectSprays, col = &quot;pink&quot;, horizontal = TRUE, las = 1, # Horizontal labels xlab = &quot;Count&quot;, ylab = &quot;Spray&quot;, main = &quot;&quot; ) Notched Boxplots set.seed(1234) n &lt;- 8 g &lt;- gl(n, 100, n * 100) # n水平个数 100是重复次数 x &lt;- rnorm(n * 100) + sqrt(as.numeric(g)) boxplot(split(x, g), col = hcl.colors(n), notch = TRUE) title( main = &quot;Notched Boxplots&quot;, xlab = &quot;Group&quot;, font.main = 4, font.lab = 1 ) 真实的情况是这样的 cumcm2011A &lt;- readRDS(file = &quot;cumcm2011A.RDS&quot;) par(mfrow = c(2, 4), mar = c(4, 3, 1, 1)) with(cumcm2011A, boxplot(As, xlab = &quot;As&quot;)) abline(h = c(1.8, 3.6, 5.4), col = c(&quot;green&quot;, &quot;blue&quot;, &quot;red&quot;), lty = 2) with(cumcm2011A, boxplot(Cd, xlab = &quot;Cd&quot;)) abline(h = c(70, 130, 190), col = c(&quot;green&quot;, &quot;blue&quot;, &quot;red&quot;), lty = 2) with(cumcm2011A, boxplot(Cr, xlab = &quot;Cr&quot;)) abline(h = c(13, 31, 49), col = c(&quot;green&quot;, &quot;blue&quot;, &quot;red&quot;), lty = 2) with(cumcm2011A, boxplot(Cu, xlab = &quot;Cu&quot;)) abline(h = c(6.0, 13.2, 20.4), col = c(&quot;green&quot;, &quot;blue&quot;, &quot;red&quot;), lty = 2) with(cumcm2011A, boxplot(Hg, xlab = &quot;Hg&quot;)) abline(h = c(19, 35, 51), col = c(&quot;green&quot;, &quot;blue&quot;, &quot;red&quot;), lty = 2) with(cumcm2011A, boxplot(Ni, xlab = &quot;Ni&quot;)) abline(h = c(4.7, 12.3, 19.9), col = c(&quot;green&quot;, &quot;blue&quot;, &quot;red&quot;), lty = 2) with(cumcm2011A, boxplot(Pb, xlab = &quot;Pb&quot;)) abline(h = c(19, 31, 43), col = c(&quot;green&quot;, &quot;blue&quot;, &quot;red&quot;), lty = 2) with(cumcm2011A, boxplot(Zn, xlab = &quot;Zn&quot;)) abline(h = c(41, 69, 97), col = c(&quot;green&quot;, &quot;blue&quot;, &quot;red&quot;), lty = 2) boxplot(As ~ area, data = cumcm2011A, col = hcl.colors(5) ) abline( h = c(1.8, 3.6, 5.4), col = c(&quot;green&quot;, &quot;blue&quot;, &quot;red&quot;), lty = 2, lwd = 2 ) 11.2.12 残差图 iris 四个测量指标 vec_mean &lt;- colMeans(iris[, -5]) vec_sd &lt;- apply(iris[, -5], 2, sd) plot(seq(4), vec_mean, ylim = range(c(vec_mean - vec_sd, vec_mean + vec_sd)), xlab = &quot;Species&quot;, ylab = &quot;Mean +/- SD&quot;, lwd = 1, pch = 19, axes = FALSE ) axis(1, at = seq(4), labels = colnames(iris)[-5]) axis(2, at = seq(7), labels = seq(7)) arrows(seq(4), vec_mean - vec_sd, seq(4), vec_mean + vec_sd, length = 0.05, angle = 90, code = 3 ) box() 图 11.51: 带标准差的均值散点图 11.2.13 提琴图 Tom Kelly 维护的 vioplot 包 https://github.com/TomKellyGenetics/vioplot 11.2.14 轮廓图 topo 是地形数据 等高线图 11.2.15 折线图 函数曲线，样条曲线，核密度曲线，平行坐标图 折线图 点线图 plot(type=\"b\") 函数曲线图 curve matplot X 样条曲线 xspline 时序图 太阳黑子活动数据 sunspot.month Monthly Sunspot Data, from 1749 to “Present” sunspot.year Yearly Sunspot Data, 1700-1988 sunspots Monthly Sunspot Numbers, 1749-1983 plot(AirPassengers) box(col = &quot;gray&quot;) 图 11.52: 折线图 11.2.16 函数图 library(pracma) ## First zero on the critical line s = 0.5 + i t x &lt;- seq(0, 20, len = 1001) z &lt;- 0.5 + x * 1i fr &lt;- Re(zeta(z)) fi &lt;- Im(zeta(z)) fa &lt;- abs(zeta(z)) plot(x, fa, type = &quot;n&quot;, xlim = c(0, 20), ylim = c(-1.5, 2.5), xlab = &quot;Imaginary part (on critical line)&quot;, ylab = &quot;Function value&quot;, main = &quot;Riemann&#39;s Zeta Function along the critical line&quot; ) grid() lines(x, fr, col = &quot;blue&quot;) lines(x, fi, col = &quot;darkgreen&quot;) lines(x, fa, col = &quot;red&quot;, lwd = 2) points(14.1347, 0, col = &quot;darkred&quot;) legend(0, 2.4, c(&quot;real part&quot;, &quot;imaginary part&quot;, &quot;absolute value&quot;), lty = 1, lwd = c(1, 1, 2), col = c(&quot;blue&quot;, &quot;darkgreen&quot;, &quot;red&quot;) ) 还有 eta 函数和 gammaz 函数 11.2.17 马赛克图 马赛克图 mosaicplot plot(HairEyeColor, col = &quot;lightblue&quot;, border = &quot;white&quot;, main = &quot;&quot;) 图 11.53: 马赛克图 11.2.18 克利夫兰点图 dotchart 条件图 coplot 11.2.19 矩阵图 在对角线上添加平滑曲线、密度曲线 pairs(longley, gap = 0, diag.panel = function(x, ...) { par(new = TRUE) hist(x, col = &quot;light blue&quot;, probability = TRUE, axes = FALSE, main = &quot;&quot; ) lines(density(x), col = &quot;red&quot;, lwd = 3 ) rug(x) } ) 图 11.54: 变量关系 # 自带 layout plot(iris[, -5], col = iris$Species) 图 11.55: 矩阵图 11.2.20 雷达图 星图 stars 多元数据 11.2.21 玫瑰图 11.2.22 地形图 轮廓图 contour 等高线图 热图 image if (!&quot;spDataLarge&quot; %in% .packages(TRUE)) { install.packages(&quot;spDataLarge&quot;, repos = &quot;https://nowosad.github.io/drat/&quot;, type = &quot;source&quot; ) } raster 图形，Elevation raster data from SRTM of the Zion National Park area library(sp) library(raster) library(spDataLarge) plot(elevation, asp = NA) 图 11.56: raster 图形 注意与 image 函数区别 # A prettier display of the volcano x &lt;- 10 * (1:nrow(volcano)) y &lt;- 10 * (1:ncol(volcano)) image(x, y, volcano, col = terrain.colors(100), axes = FALSE) contour(x, y, volcano, levels = seq(90, 200, by = 5), add = TRUE, col = &quot;peru&quot; ) axis(1, at = seq(100, 800, by = 100)) axis(2, at = seq(100, 600, by = 100)) box() title(main = &quot;Maunga Whau Volcano&quot;, font.main = 4) 图 11.57: image 图形 11.3 运行环境 xfun::session_info() #&gt; R Under development (unstable) (2020-02-04 r77771) #&gt; Platform: x86_64-pc-linux-gnu (64-bit) #&gt; Running under: Ubuntu 16.04.6 LTS #&gt; #&gt; Locale: #&gt; LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C #&gt; LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 #&gt; LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 #&gt; LC_PAPER=en_US.UTF-8 LC_NAME=C #&gt; LC_ADDRESS=C LC_TELEPHONE=C #&gt; LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C #&gt; #&gt; Package version: #&gt; base64enc_0.1.3 bookdown_0.17 codetools_0.2-16 #&gt; compiler_4.0.0 curl_4.3 digest_0.6.23 #&gt; evaluate_0.14 glue_1.3.1 graphics_4.0.0 #&gt; grDevices_4.0.0 grid_4.0.0 highr_0.8 #&gt; htmltools_0.4.0 jsonlite_1.6.1 KernSmooth_2.23-16 #&gt; knitr_1.26 lattice_0.20-38 magrittr_1.5 #&gt; markdown_1.1 MASS_7.3-51.5 Matrix_1.2-18 #&gt; methods_4.0.0 mime_0.9 pracma_2.2.9 #&gt; raster_3.0-12 Rcpp_1.0.3 rgdal_1.4-8 #&gt; rlang_0.4.4 rmarkdown_2.1 sp_1.3-2 #&gt; spDataLarge_0.3.1 splines_4.0.0 stats_4.0.0 #&gt; stringi_1.4.5 stringr_1.4.0 survival_3.1-8 #&gt; tinytex_0.19 tools_4.0.0 utils_4.0.0 #&gt; xfun_0.12 yaml_2.2.1 参考文献 "],
["dv-ggplot2.html", "第 12 章 数据可视化 12.1 基础语法 12.2 统计图形 12.3 运行环境", " 第 12 章 数据可视化 3-D bar plots are an abomination. Just because Excel can do them doesn’t mean you should. (Dismount pulpit). — Berton Gunter39 grid graphics lattice 和 ggplot2 之间的历史发展关系脉络 gganimate 只是一个扩展，并不是新的东西，因为它是静态图形转化为帧，然后借助第三方工具合成 ggplot2 生态系统 12.1 表 12.1: ggplot2 生态系统 Package Title gg.gap Define Segments in y-Axis for ggplot2 ggallin Grab Bag of ggplot2 Functions ggalluvial Alluvial Plots in ggplot2 ggalt Extra Coordinate Systems, Geoms, Statistical Transformations, Scales and Fonts for ggplot2 ggamma Generalized Gamma Probability Distribution gganimate A Grammar of Animated Graphics ggasym Asymmetric Matrix Plotting in ggplot2 ggbeeswarm Categorical Scatter (Violin Point) Plots ggBubbles Mini Bubble Plots for Comparison of Discrete Data with ggplot2 ggbuildr Save Incremental Builds of Plots ggChernoff Chernoff Faces for ggplot2 ggconf Simpler Appearance Modification of ggplot2 ggcorrplot Visualization of a Correlation Matrix using ggplot2 ggdag Analyze and Create Elegant Directed Acyclic Graphs ggdark Dark Mode for ggplot2 Themes ggdemetra ggplot2 Extension for Seasonal and Trading Day Adjustment with RJDemetra ggdendro Create Dendrograms and Tree Diagrams Using ggplot2 ggdistribute A ggplot2 Extension for Plotting Unimodal Distributions ggdmc Cognitive Models gge Genotype Plus Genotype-by-Environment Biplots ggeasy Easy Access to ggplot2 Commands ggedit Interactive ggplot2 Layer and Theme Aesthetic Editor ggeffects Create Tidy Data Frames of Marginal Effects for ggplot from Model Outputs ggenealogy Visualization Tools for Genealogical Data ggetho Visualisation of High-Throughput Behavioural (i.e. Ethomics) Data ggExtra Add Marginal Histograms to ggplot2, and More ggplot2 Enhancements ggfan Summarise a Distribution Through Coloured Intervals ggfittext Fit Text Inside a Box in ggplot2 ggfocus Scales that Focus Specific Levels in your ggplot() ggforce Accelerating ggplot2 ggformula Formula Interface to the Grammar of Graphics ggfortify Data Visualization Tools for Statistical Analysis Results gggenes Draw Gene Arrow Maps in ggplot2 ggghost Capture the Spirit of Your ggplot2 Calls gggibbous Moon Charts, a Pie Chart Alternative ggguitar Utilities for Creating Guitar Tablature gghalfnorm Create a Half Normal Plot Using ggplot2 gghalves Compose Half-Half Plots Using Your Favourite Geoms gghighlight Highlight Lines and Points in ggplot2 ggimage Use Image in ggplot2 gginference Visualise the Results of Inferential Statistics using ggplot2 gginnards Explore the Innards of ggplot2 Objects ggiraph Make ggplot2 Graphics Interactive ggiraphExtra Make Interactive ggplot2. Extension to ggplot2 and ggiraph ggjoy Joyplots in ggplot2 gglasso Group Lasso Penalized Learning Using a Unified BMD Algorithm gglogo Geom for Logo Sequence Plots ggloop Create ggplot2 Plots in a Loop gglorenz Plotting Lorenz Curve with the Blessing of ggplot2 ggm Functions for graphical Markov models ggmap Spatial Visualization with ggplot2 ggmcmc Tools for Analyzing MCMC Simulations from Bayesian Inference ggmosaic Mosaic Plots in the ggplot2 Framework ggmr Generalized Gauss Markov Regression ggmsa Plot Multiple Sequence Alignment using ggplot2 ggmuller Create Muller Plots of Evolutionary Dynamics ggnetwork Geometries to Plot Networks with ggplot2 ggnewscale Multiple Fill and Color Scales in ggplot2 ggnormalviolin A ggplot2 Extension to Make Normal Violin Plots ggpage Creates Page Layout Visualizations ggparallel Variations of Parallel Coordinate Plots for Categorical Data ggparliament Parliament Plots ggparty ggplot Visualizations for the partykit Package ggperiodic Easy Plotting of Periodic Data with ggplot2 ggplot.multistats Multiple Summary Statistics for Binned Stats/Geometries ggplot2 Create Elegant Data Visualisations Using the Grammar of Graphics ggplot2movies Movies Data ggplotAssist RStudio Addin for Teaching and Learning ggplot2 ggplotgui Create Ggplots via a Graphical User Interface ggplotify Convert Plot to grob or ggplot Object ggplotlyExtra Extra Convenience Functions for Plotly ggpmisc Miscellaneous Extensions to ggplot2 ggPMX ggplot2 Based Tool to Facilitate Diagnostic Plots for NLME Models ggpointdensity A Cross Between a 2D Density Plot and a Scatter Plot ggpol Visualizing Social Science Data with ggplot2 ggpolypath Polygons with Holes for the Grammar of Graphics ggpubr ggplot2 Based Publication Ready Plots ggpval Annotate Statistical Tests for ggplot2 ggQC Quality Control Charts for ggplot ggQQunif Compare Big Datasets to the Uniform Distribution ggquickeda Quickly Explore Your Data Using ggplot2 and table1 Summary Tables ggquiver Quiver Plots for ggplot2 ggRandomForests Visually Exploring Random Forests ggraph An Implementation of Grammar of Graphics for Graphs and Networks ggraptR Allows Interactive Visualization of Data Through a Web Browser GUI ggrasp Gaussian-Based Genome Representative Selector with Prioritization ggrepel Automatically Position Non-Overlapping Text Labels with ggplot2 ggResidpanel Panels and Interactive Versions of Diagnostic Plots using ggplot2 ggridges Ridgeline Plots in ggplot2 ggROC package for roc curve plot with ggplot2 ggroups Pedigree and Genetic Groups ggsci Scientific Journal and Sci-Fi Themed Color Palettes for ggplot2 ggseas stats for Seasonal Adjustment on the Fly with ggplot2 ggseqlogo A ggplot2 Extension for Drawing Publication-Ready Sequence Logos ggsignif Significance Brackets for ggplot2 ggsn North Symbols and Scale Bars for Maps Created with ggplot2 or ggmap ggsoccer Plot Soccer Event Data ggsolvencyii A ggplot2-Plot of Composition of Solvency II SCR: SF and IM ggsom New Data Visualisations for SOMs Networks ggspatial Spatial Data Framework for ggplot2 ggspectra Extensions to ggplot2 for Radiation Spectra ggstance Horizontal ggplot2 Components ggstatsplot ggplot2 Based Plots with Statistical Details ggswissmaps Offers Various Swiss Maps as Data Frames and ggplot2 Objects ggtern An Extension to ggplot2, for the Creation of Ternary Diagrams ggThemeAssist Add-in to Customize ggplot2 Themes ggthemes Extra Themes, Scales and Geoms for ggplot2 ggTimeSeries Time Series Visualisations Using the Grammar of Graphics ggupset Combination Matrix Axis for ggplot2 to Create UpSet Plots ggVennDiagram A ggplot2 Implement of Venn Diagram ggversa Graficas Versatiles Con ggplot2 ggvis Interactive Grammar of Graphics ggvoronoi Voronoi Diagrams and Heatmaps with ggplot2 ggwordcloud A Word Cloud Geom for ggplot2 David Robinson 给出为何使用 ggplot240 当然也有 Jeff Leek 指出在某些重要场合不适合 ggplot241 并且给出强有力的 证据，其实不管怎么样，适合自己的才是好的。也不枉费 Garrick Aden-Buie 花费 160 页幻灯片逐步分解介绍 优雅的ggplot2，Malcolm Barrett 也介绍了 ggplot2 基础用法，还有 Selva Prabhakaran 精心总结给出了 50 个 ggplot2 数据可视化的 例子 以及 Victor Perrier 为小白用 ggplot2 操碎了心地开发 RStudio 插件 esquisse 包，Claus O. Wilke 教你一步步创建出版级的图形 https://github.com/clauswilke/practical_ggplot2。 GGplot2 是十分方便的统计作图工具，相比 Base R，为了一张出版级的图形，不需要去调整每个参数，实现快速出图。集成了很多其它统计计算的 R 包，支持丰富的统计分析和计算功能，如回归、平滑等，实现了作图和模型的无缝连接。比如图12.1，使用 loess 局部多项式平滑得到数据的趋势，不仅仅是散点图，代码量也非常少。 ggplot(mpg, aes(displ, hwy)) + geom_point(aes(color = class)) + geom_smooth(se = TRUE, method = &quot;loess&quot;) + labs( title = &quot;Fuel efficiency generally decreases with engine size&quot;, subtitle = &quot;Two seaters (sports cars) are an exception because of their light weight&quot;, caption = &quot;Data from fueleconomy.gov&quot; ) 图 12.1: 简洁美观 故事源于一幅图片，我不记得第一次见到这幅图是什么时候了，只因多次在多个场合中见过，所以留下了深刻的印象，后来才知道它出自于一篇博文 — Using R packages and education to scale Data Science at Airbnb，作者 Ricardo Bion 还在其 Github 上传了相关代码42。除此之外还有几篇重要的参考资料： Pablo Barberá 的 Data Visualization with R and ggplot2 Kieran Healy 的新书 Data Visualization: A Practical Introduction Matt Leonawicz 的新作 mapmate, 可以去其主页欣赏系列作品43 tidytuesday 可视化挑战官方项目 还有 tidytuesday ggstatsplot 可视化统计检验、模型的结果 ggpubr 制作出版级统计图形 12.1 基础语法 以数据集 airquality 为例介绍GGplot2 图层、主题、配色、坐标、尺度、注释和组合等 12.1.1 图层 ls(&quot;package:ggplot2&quot;, pattern = &quot;^geom_&quot;) #&gt; [1] &quot;geom_abline&quot; &quot;geom_area&quot; &quot;geom_bar&quot; &quot;geom_bin2d&quot; #&gt; [5] &quot;geom_blank&quot; &quot;geom_boxplot&quot; &quot;geom_col&quot; &quot;geom_contour&quot; #&gt; [9] &quot;geom_count&quot; &quot;geom_crossbar&quot; &quot;geom_curve&quot; &quot;geom_density&quot; #&gt; [13] &quot;geom_density_2d&quot; &quot;geom_density2d&quot; &quot;geom_dotplot&quot; &quot;geom_errorbar&quot; #&gt; [17] &quot;geom_errorbarh&quot; &quot;geom_freqpoly&quot; &quot;geom_hex&quot; &quot;geom_histogram&quot; #&gt; [21] &quot;geom_hline&quot; &quot;geom_jitter&quot; &quot;geom_label&quot; &quot;geom_line&quot; #&gt; [25] &quot;geom_linerange&quot; &quot;geom_map&quot; &quot;geom_path&quot; &quot;geom_point&quot; #&gt; [29] &quot;geom_pointrange&quot; &quot;geom_polygon&quot; &quot;geom_qq&quot; &quot;geom_qq_line&quot; #&gt; [33] &quot;geom_quantile&quot; &quot;geom_raster&quot; &quot;geom_rect&quot; &quot;geom_ribbon&quot; #&gt; [37] &quot;geom_rug&quot; &quot;geom_segment&quot; &quot;geom_sf&quot; &quot;geom_sf_label&quot; #&gt; [41] &quot;geom_sf_text&quot; &quot;geom_smooth&quot; &quot;geom_spoke&quot; &quot;geom_step&quot; #&gt; [45] &quot;geom_text&quot; &quot;geom_tile&quot; &quot;geom_violin&quot; &quot;geom_vline&quot; 生成一个散点图 ggplot(airquality, aes(x = Temp, y = Ozone)) + geom_point() #&gt; Warning: Removed 37 rows containing missing values (geom_point). 12.1.2 主题 ls(&quot;package:ggplot2&quot;, pattern = &quot;^theme_&quot;) #&gt; [1] &quot;theme_bw&quot; &quot;theme_classic&quot; &quot;theme_dark&quot; &quot;theme_get&quot; #&gt; [5] &quot;theme_gray&quot; &quot;theme_grey&quot; &quot;theme_light&quot; &quot;theme_linedraw&quot; #&gt; [9] &quot;theme_minimal&quot; &quot;theme_replace&quot; &quot;theme_set&quot; &quot;theme_test&quot; #&gt; [13] &quot;theme_update&quot; &quot;theme_void&quot; 这里只展示 theme_bw() theme_void() theme_minimal() 和 theme_void() 等四个常见主题，更多主题参考 ggsci、ggthemes 、ggtech、hrbrthemes 和 ggthemr 包 ggplot(airquality, aes(x = Temp, y = Ozone)) + geom_point() + theme_bw() #&gt; Warning: Removed 37 rows containing missing values (geom_point). ggplot(airquality, aes(x = Temp, y = Ozone)) + geom_point() + theme_void() #&gt; Warning: Removed 37 rows containing missing values (geom_point). ggplot(airquality, aes(x = Temp, y = Ozone)) + geom_point() + theme_minimal() #&gt; Warning: Removed 37 rows containing missing values (geom_point). ggplot(airquality, aes(x = Temp, y = Ozone)) + geom_point() + theme_void() #&gt; Warning: Removed 37 rows containing missing values (geom_point). 除主题之外，还有一类提供一整套统一的风格样式来绘制各种统计图形，如 ggpubr 和 bbplot 12.1.3 配色 ls(&quot;package:ggplot2&quot;, pattern = &quot;^scale_(color|fill)_&quot;) #&gt; [1] &quot;scale_color_brewer&quot; &quot;scale_color_continuous&quot; &quot;scale_color_discrete&quot; #&gt; [4] &quot;scale_color_distiller&quot; &quot;scale_color_gradient&quot; &quot;scale_color_gradient2&quot; #&gt; [7] &quot;scale_color_gradientn&quot; &quot;scale_color_grey&quot; &quot;scale_color_hue&quot; #&gt; [10] &quot;scale_color_identity&quot; &quot;scale_color_manual&quot; &quot;scale_color_viridis_c&quot; #&gt; [13] &quot;scale_color_viridis_d&quot; &quot;scale_fill_brewer&quot; &quot;scale_fill_continuous&quot; #&gt; [16] &quot;scale_fill_date&quot; &quot;scale_fill_datetime&quot; &quot;scale_fill_discrete&quot; #&gt; [19] &quot;scale_fill_distiller&quot; &quot;scale_fill_gradient&quot; &quot;scale_fill_gradient2&quot; #&gt; [22] &quot;scale_fill_gradientn&quot; &quot;scale_fill_grey&quot; &quot;scale_fill_hue&quot; #&gt; [25] &quot;scale_fill_identity&quot; &quot;scale_fill_manual&quot; &quot;scale_fill_ordinal&quot; #&gt; [28] &quot;scale_fill_viridis_c&quot; &quot;scale_fill_viridis_d&quot; ggplot(airquality, aes(x = Temp, y = Ozone, color = as.factor(Month))) + geom_point(na.rm = TRUE) ggplot(airquality, aes(x = Temp, y = Ozone, color = as.ordered(Month))) + geom_point(na.rm = TRUE) 12.1.4 刻度 ls(&quot;package:ggplot2&quot;, pattern = &quot;^scale_(x|y)_&quot;) #&gt; [1] &quot;scale_x_continuous&quot; &quot;scale_x_date&quot; &quot;scale_x_datetime&quot; #&gt; [4] &quot;scale_x_discrete&quot; &quot;scale_x_log10&quot; &quot;scale_x_reverse&quot; #&gt; [7] &quot;scale_x_sqrt&quot; &quot;scale_x_time&quot; &quot;scale_y_continuous&quot; #&gt; [10] &quot;scale_y_date&quot; &quot;scale_y_datetime&quot; &quot;scale_y_discrete&quot; #&gt; [13] &quot;scale_y_log10&quot; &quot;scale_y_reverse&quot; &quot;scale_y_sqrt&quot; #&gt; [16] &quot;scale_y_time&quot; range(airquality$Temp, na.rm = TRUE) #&gt; [1] 56 97 range(airquality$Ozone, na.rm = TRUE) #&gt; [1] 1 168 ggplot(airquality, aes(x = Temp, y = Ozone)) + geom_point(na.rm = TRUE) + scale_x_continuous(breaks = seq(50, 100, 5)) + scale_y_continuous(breaks = seq(0, 200, 20)) 12.1.5 注释 ls(&quot;package:ggplot2&quot;, pattern = &quot;^annotation_&quot;) #&gt; [1] &quot;annotation_custom&quot; &quot;annotation_logticks&quot; &quot;annotation_map&quot; #&gt; [4] &quot;annotation_raster&quot; ggplot(airquality, aes(x = Temp, y = Ozone)) + geom_point(na.rm = TRUE) ggplot(airquality, aes(x = Temp, y = Ozone)) + geom_point(na.rm = TRUE) + labs(title = substitute(paste(d * bolditalic(x)[italic(t)] == alpha * (theta - bolditalic(x)[italic(t)]) * d * italic(t) + lambda * d * italic(B)[italic(t)]), list(lambda = 4))) 12.1.6 图例 二维的图例 biscale 和 multiscales 和 ggnewscale 12.1.7 组合 ggplot(airquality) + geom_point(aes(x = Temp, y = Ozone), na.rm = TRUE) + facet_wrap(~ as.ordered(Month)) ggplot(airquality) + geom_point(aes(x = Temp, y = Ozone), na.rm = TRUE) + facet_wrap(~ as.ordered(Month), nrow = 1) cowplot 是以作者 Claus O. Wilke 命名的，用来组合 ggplot 对象画图，类似的组合图形的功能包还有 baptiste auguié 开发的 gridExtra 和 egg， Thomas Lin Pedersen 开发的 patchwork Dean Attali 开发的 ggExtra 可以在图的边界添加密度估计曲线，直方图等 12.1.8 坐标系 极坐标，直角坐标 ls(&quot;package:ggplot2&quot;, pattern = &quot;^coord_&quot;) #&gt; [1] &quot;coord_cartesian&quot; &quot;coord_equal&quot; &quot;coord_fixed&quot; &quot;coord_flip&quot; #&gt; [5] &quot;coord_map&quot; &quot;coord_munch&quot; &quot;coord_polar&quot; &quot;coord_quickmap&quot; #&gt; [9] &quot;coord_sf&quot; &quot;coord_trans&quot; 12.1.9 坐标轴 坐标轴标签位置、大小、字体 12.2 统计图形 12.2.1 散点图 下面以 diamonds 数据集为例展示 ggplot2 的绘图过程，首先加载 diamonds 数据集，查看数据集的内容 data(diamonds) str(diamonds) #&gt; Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 53940 obs. of 10 variables: #&gt; $ carat : num 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ... #&gt; $ cut : Ord.factor w/ 5 levels &quot;Fair&quot;&lt;&quot;Good&quot;&lt;..: 5 4 2 4 2 3 3 3 1 3 ... #&gt; $ color : Ord.factor w/ 7 levels &quot;D&quot;&lt;&quot;E&quot;&lt;&quot;F&quot;&lt;&quot;G&quot;&lt;..: 2 2 2 6 7 7 6 5 2 5 ... #&gt; $ clarity: Ord.factor w/ 8 levels &quot;I1&quot;&lt;&quot;SI2&quot;&lt;&quot;SI1&quot;&lt;..: 2 3 5 4 2 6 7 3 4 5 ... #&gt; $ depth : num 61.5 59.8 56.9 62.4 63.3 62.8 62.3 61.9 65.1 59.4 ... #&gt; $ table : num 55 61 65 58 58 57 57 55 61 61 ... #&gt; $ price : int 326 326 327 334 335 336 336 337 337 338 ... #&gt; $ x : num 3.95 3.89 4.05 4.2 4.34 3.94 3.95 4.07 3.87 4 ... #&gt; $ y : num 3.98 3.84 4.07 4.23 4.35 3.96 3.98 4.11 3.78 4.05 ... #&gt; $ z : num 2.43 2.31 2.31 2.63 2.75 2.48 2.47 2.53 2.49 2.39 ... 数值型变量 carat 作为 x 轴 ggplot(diamonds, aes(x = carat)) ggplot(diamonds, aes(x = carat, y = price)) ggplot(diamonds, aes(x = carat, color = cut)) ggplot(diamonds, aes(x = carat), color = &quot;steelblue&quot;) 图 12.2: 绘图过程 图 12.2 的基础上添加数据图层 sub_diamonds &lt;- diamonds[sample(1:nrow(diamonds), 1000), ] ggplot(sub_diamonds, aes(x = carat, y = price)) + geom_point() 图 12.3: 添加数据图层 给散点图12.3上色 ggplot(sub_diamonds, aes(x = carat, y = price)) + geom_point(color = &quot;steelblue&quot;) 图 12.4: 散点图配色 ggplot(sub_diamonds, aes(x = carat, y = price)) + geom_point(color = &quot;steelblue&quot;) + scale_y_continuous( labels = scales::unit_format(unit = &quot;k&quot;, scale = 1e-3), breaks = seq(0, 20000, 4000) ) 图 12.5: 格式化坐标轴刻度标签 让另一变量 cut 作为颜色分类指标 ggplot(sub_diamonds, aes(x = carat, y = price, color = cut)) + geom_point() 图 12.6: 分类散点图 当然还有一种类似的表示就是分组，默认情况下，ggplot2将所有观测点视为一组，以分类变量 cut 来分组 ggplot(sub_diamonds, aes(x = carat, y = price, group = cut)) + geom_point() 图 12.7: 分组 在图12.7 上没有体现出来分组的意思，下面以 cut 分组线性回归为例 ggplot(sub_diamonds, aes(x = carat, y = price)) + geom_point() + geom_smooth(method = &quot;lm&quot;) ggplot(sub_diamonds, aes(x = carat, y = price, group = cut)) + geom_point() + geom_smooth(method = &quot;lm&quot;) 图 12.8: 分组线性回归 我们当然可以选择更加合适的拟合方式，如局部多项式平滑 loess 但是该方法不太适用观测值比较多的情况，因为它会占用比较多的内存，建议使用广义可加模型作平滑拟合 ggplot(sub_diamonds, aes(x = carat, y = price, group = cut)) + geom_point() + geom_smooth(method = &quot;loess&quot;) 图 12.9: 局部多项式平滑 ggplot(sub_diamonds, aes(x = carat, y = price, group = cut)) + geom_point() + geom_smooth(method = &quot;gam&quot;, formula = y ~ s(x, bs = &quot;cs&quot;)) 图 12.10: 数据分组应用广义可加平滑 ggfortify 包支持更多的统计分析结果的可视化 为了更好地区分开组别，我们在图12.10的基础上分面或者配色 ggplot(sub_diamonds, aes(x = carat, y = price, group = cut)) + geom_point() + geom_smooth(method = &quot;gam&quot;, formula = y ~ s(x, bs = &quot;cs&quot;)) + facet_grid(~cut) ggplot(sub_diamonds, aes(x = carat, y = price, group = cut, color = cut)) + geom_point() + geom_smooth(method = &quot;gam&quot;, formula = y ~ s(x, bs = &quot;cs&quot;)) 图 12.11: 分组配色 在分类散点图的另一种表示方法就是分面图，以 cut 变量作为分面的依据 ggplot(sub_diamonds, aes(x = carat, y = price)) + geom_point() + facet_grid(~cut) 图 12.12: 分面散点图 给图 12.12 上色 ggplot(sub_diamonds, aes(x = carat, y = price)) + geom_point(color = &quot;steelblue&quot;) + facet_grid(~cut) 图 12.13: 给分面散点图上色 在图12.13的基础上，给不同的类上不同的颜色 ggplot(sub_diamonds, aes(x = carat, y = price, color = cut)) + geom_point() + facet_grid(~cut) 图 12.14: 给不同的类上不同的颜色 去掉图例，此时图例属于冗余信息了 ggplot(sub_diamonds, aes(x = carat, y = price, color = cut)) + geom_point(show.legend = FALSE) + facet_grid(~cut) 图 12.15: 去掉图例 四块土地，所施肥料不同，肥力大小顺序 4 &lt; 2 &lt; 3 &lt; 1 小麦产量随肥力的变化 data(Wheat2, package = &quot;nlme&quot;) # Wheat Yield Trials library(colorspace) ggplot(Wheat2, aes(longitude, latitude)) + geom_point(aes(size = yield, colour = Block)) + scale_color_discrete_sequential(palette = &quot;Viridis&quot;) + scale_x_continuous(breaks = seq(0, 30, 5)) + scale_y_continuous(breaks = seq(0, 50, 10)) 图 12.16: 多个图例 ggplot(mtcars, aes(x = hp, y = mpg, color = factor(am))) + geom_point() 图 12.17: 分类散点图 图层、分组、分面和散点图介绍完了，接下来就是其它统计图形，如箱线图，小提琴图和条形图 dat &lt;- as.data.frame(cbind(rep(1948 + seq(12), each = 12), rep(seq(12), 12), AirPassengers)) colnames(dat) &lt;- c(&quot;year&quot;, &quot;month&quot;, &quot;passengers&quot;) ggplot(data = dat, aes(x = as.factor(year), y = as.factor(month))) + stat_sum(aes(size = passengers), colour = &quot;lightblue&quot;) + scale_size(range = c(1, 10), breaks = seq(100, 650, 50)) + labs(x = &quot;Year&quot;, y = &quot;Month&quot;, colour = &quot;Passengers&quot;) + theme_minimal() 图 11.14: 1948年至1960年航班乘客人数变化 12.2.2 箱线图 以 PlantGrowth 数据集为例展示箱线图，在两组不同实验条件下，植物生长的情况，纵坐标是干燥植物的量，横坐标表示不同的实验条件。这是非常典型的适合用箱线图来表达数据的场合，Y 轴对应数值型变量，X 轴对应分类变量，在 R 语言中，分类变量的类型是 factor data(&quot;PlantGrowth&quot;) str(PlantGrowth) #&gt; &#39;data.frame&#39;: 30 obs. of 2 variables: #&gt; $ weight: num 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ... #&gt; $ group : Factor w/ 3 levels &quot;ctrl&quot;,&quot;trt1&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... ggplot(data = PlantGrowth, aes(x = group, y = weight)) + geom_boxplot() PlantGrowth 数据量比较小，此时比较适合采用抖动散点图，抖动是为了避免点之间相互重叠，为了增加不同类别之间的识别性，我们可以用不同的点的形状或者不同的颜色来表示类别 ggplot(data = PlantGrowth, aes(x = group, y = weight, shape = group)) + geom_jitter() ggplot(data = PlantGrowth, aes(x = group, y = weight, color = group)) + geom_jitter() boxplot(weight ~ group, data = PlantGrowth, ylab = &quot;Dried weight of plants&quot;, col = &quot;lightgray&quot;, notch = FALSE, varwidth = TRUE ) 以钻石切割质量 cut 为分面依据，以钻石颜色类别 color 为 x 轴，钻石价格为 y 轴，绘制箱线图12.18 ggplot(diamonds, aes(x = color, y = price, color = cut)) + geom_boxplot(show.legend = FALSE) + facet_grid(~cut) 图 12.18: 箱线图 我们当然还可以添加钻石的纯净度 clarity 作为分面依据，那么箱线图可以为图 12.19 ggplot(diamonds, aes(x = color, y = price, color = cut)) + geom_boxplot(show.legend = FALSE) + facet_grid(clarity ~ cut) 图 12.19: 复合分面箱线图 经过观察，我们发现水平分类过多，考虑用切割质量 cut 替换钻石颜色 color 绘图，但是由于分类过细，图信息展示不简练，反而不好，如图 12.20 ggplot(diamonds, aes(x = cut, y = price, color = cut)) + geom_boxplot(show.legend = FALSE) + facet_grid(clarity ~ color) ggplot(diamonds, aes(x = cut, y = price, color = color)) + geom_boxplot(show.legend = FALSE) + facet_grid(clarity ~ color) 图 12.20: 钻石颜色配色 12.2.3 条形图 条形图特别适合分类变量的展示，我们这里展示钻石切割质量 cut 不同等级的数量，当然我们可以直接展示各类的数目，在图层 geom_bar 中指定 stat=\"identity\" # 需要映射数据框的两个变量，相当于自己先计算了每类的数量 with(diamonds, table(cut)) #&gt; cut #&gt; Fair Good Very Good Premium Ideal #&gt; 1610 4906 12082 13791 21551 cut_df &lt;- as.data.frame(table(diamonds$cut)) ggplot(cut_df, aes(x = Var1, y = Freq)) + geom_bar(stat = &quot;identity&quot;) ggplot(diamonds, aes(x = cut)) + geom_bar() 图 12.21: 频数条形图 还有另外三种表示方法 ggplot(diamonds, aes(x = cut)) + geom_bar(stat = &quot;count&quot;) ggplot(diamonds, aes(x = cut, y = ..count..)) + geom_bar() ggplot(diamonds, aes(x = cut, y = stat(count))) + geom_bar() 我们还可以在图 12.21 的基础上再添加一个分类变量钻石的纯净度 clarity，形成堆积条形图 ggplot(diamonds, aes(x = cut, fill = clarity)) + geom_bar() 图 12.22: 堆积条形图 再添加一个分类变量钻石颜色 color 比较好的做法是分面 ggplot(diamonds, aes(x = color, fill = clarity)) + geom_bar() + facet_grid(~cut) 图 12.23: 分面堆积条形图 实际上，绘制图12.23包含了对分类变量的分组计数过程，如下 with(diamonds, table(cut, color)) #&gt; color #&gt; cut D E F G H I J #&gt; Fair 163 224 312 314 303 175 119 #&gt; Good 662 933 909 871 702 522 307 #&gt; Very Good 1513 2400 2164 2299 1824 1204 678 #&gt; Premium 1603 2337 2331 2924 2360 1428 808 #&gt; Ideal 2834 3903 3826 4884 3115 2093 896 还有一种堆积的方法是按比例，而不是按数量，如图12.24 ggplot(diamonds, aes(x = color, fill = clarity)) + geom_bar(position = &quot;fill&quot;) + facet_grid(~cut) 图 12.24: 比例堆积条形图 接下来就是复合条形图 ggplot(diamonds, aes(x = color, fill = clarity)) + geom_bar(position = &quot;dodge&quot;) 图 12.25: 复合条形图 再添加一个分类变量，就是需要分面大法了，图 12.25 展示了三个分类变量，其实我们还可以再添加一个分类变量用作分面的列依据 ggplot(diamonds, aes(x = color, fill = clarity)) + geom_bar(position = &quot;dodge&quot;) + facet_grid(rows = vars(cut)) 图 12.26: 分面复合条形图 图 12.26 展示的数据如下 with(diamonds, table(color, clarity, cut)) #&gt; , , cut = Fair #&gt; #&gt; clarity #&gt; color I1 SI2 SI1 VS2 VS1 VVS2 VVS1 IF #&gt; D 4 56 58 25 5 9 3 3 #&gt; E 9 78 65 42 14 13 3 0 #&gt; F 35 89 83 53 33 10 5 4 #&gt; G 53 80 69 45 45 17 3 2 #&gt; H 52 91 75 41 32 11 1 0 #&gt; I 34 45 30 32 25 8 1 0 #&gt; J 23 27 28 23 16 1 1 0 #&gt; #&gt; , , cut = Good #&gt; #&gt; clarity #&gt; color I1 SI2 SI1 VS2 VS1 VVS2 VVS1 IF #&gt; D 8 223 237 104 43 25 13 9 #&gt; E 23 202 355 160 89 52 43 9 #&gt; F 19 201 273 184 132 50 35 15 #&gt; G 19 163 207 192 152 75 41 22 #&gt; H 14 158 235 138 77 45 31 4 #&gt; I 9 81 165 110 103 26 22 6 #&gt; J 4 53 88 90 52 13 1 6 #&gt; #&gt; , , cut = Very Good #&gt; #&gt; clarity #&gt; color I1 SI2 SI1 VS2 VS1 VVS2 VVS1 IF #&gt; D 5 314 494 309 175 141 52 23 #&gt; E 22 445 626 503 293 298 170 43 #&gt; F 13 343 559 466 293 249 174 67 #&gt; G 16 327 474 479 432 302 190 79 #&gt; H 12 343 547 376 257 145 115 29 #&gt; I 8 200 358 274 205 71 69 19 #&gt; J 8 128 182 184 120 29 19 8 #&gt; #&gt; , , cut = Premium #&gt; #&gt; clarity #&gt; color I1 SI2 SI1 VS2 VS1 VVS2 VVS1 IF #&gt; D 12 421 556 339 131 94 40 10 #&gt; E 30 519 614 629 292 121 105 27 #&gt; F 34 523 608 619 290 146 80 31 #&gt; G 46 492 566 721 566 275 171 87 #&gt; H 46 521 655 532 336 118 112 40 #&gt; I 24 312 367 315 221 82 84 23 #&gt; J 13 161 209 202 153 34 24 12 #&gt; #&gt; , , cut = Ideal #&gt; #&gt; clarity #&gt; color I1 SI2 SI1 VS2 VS1 VVS2 VVS1 IF #&gt; D 13 356 738 920 351 284 144 28 #&gt; E 18 469 766 1136 593 507 335 79 #&gt; F 42 453 608 879 616 520 440 268 #&gt; G 16 486 660 910 953 774 594 491 #&gt; H 38 450 763 556 467 289 326 226 #&gt; I 17 274 504 438 408 178 179 95 #&gt; J 2 110 243 232 201 54 29 25 12.2.4 折线图 时间序列数据的展示，时序图 ggplot(economics, aes(date, unemploy)) + geom_line() 图 11.23: 时序图 12.2.5 直方图 直方图用来查看连续变量的分布 ggplot(diamonds, aes(price)) + geom_histogram(bins = 30) 图 11.24: 钻石价格的分布 堆积直方图 ggplot(diamonds, aes(x = price, fill = cut)) + geom_histogram(bins = 30) 图 12.27: 钻石价格随切割质量的分布 基础 R 包与 Ggplot2 包绘制的直方图的对比，Base R 绘图速度快，代码更加稳定，Ggplot2 代码简洁，更美观 par(mar = c(2.1, 2.1, 1.5, 0.5)) plot(c(50, 350), c(0, 10), type = &quot;n&quot;, font.main = 1, xlab = &quot;&quot;, ylab = &quot;&quot;, frame.plot = FALSE, axes = FALSE, # xlab = &quot;hp&quot;, ylab = &quot;Frequency&quot;, main = paste(&quot;Histogram with Base R&quot;, paste(rep(&quot; &quot;, 60), collapse = &quot;&quot;)) ) axis( side = 1, at = seq(50, 350, 50), labels = seq(50, 350, 50), tick = FALSE, las = 1, padj = 0, mgp = c(3, 0.1, 0) ) axis( side = 2, at = seq(0, 10, 2), labels = seq(0, 10, 2), # col = &quot;white&quot;, 坐标轴的颜色 # col.ticks 刻度线的颜色 tick = FALSE, # 取消刻度线 las = 1, # 水平方向 hadj = 1, # 右侧对齐 mgp = c(3, 0.1, 0) # 纵轴边距线设置为 0.1 ) abline(h = seq(0, 10, 2), v = seq(50, 350, 50), col = &quot;gray90&quot;, lty = &quot;solid&quot;) abline(h = seq(1, 9, 2), v = seq(75, 325, 50), col = &quot;gray95&quot;, lty = &quot;solid&quot;) hist(mtcars$hp, col = &quot;#56B4E9&quot;, border = &quot;white&quot;, freq = TRUE, add = TRUE # labels = TRUE, axes = TRUE, ylim = c(0, 10.5), # xlab = &quot;hp&quot;,main = &quot;Histogram with Base R&quot; ) mtext(&quot;hp&quot;, 1, line = 1.0) mtext(&quot;Frequency&quot;, 2, line = 1.0) ggplot(mtcars) + geom_histogram(aes(x = hp), fill = &quot;#56B4E9&quot;, color = &quot;white&quot;, breaks = seq(50, 350, 50)) + scale_x_continuous(breaks = seq(50, 350, 50)) + scale_y_continuous(breaks = seq(0, 12, 2)) + labs(x = &quot;hp&quot;, y = &quot;Frequency&quot;, title = &quot;Histogram with Ggplot2&quot;) + theme_minimal(base_size = 12) 图 11.25: 直方图 12.2.6 提琴图 提琴图 ggplot(diamonds, aes(x = cut, y = price)) + geom_boxplot() ggplot(diamonds, aes(x = cut, y = price)) + geom_violin() 图 12.28: 小提琴图 ggplot(mpg, aes(class, cty)) + geom_violin() + labs( title = &quot;Violin plot&quot;, subtitle = &quot;City Mileage vs Class of vehicle&quot;, caption = &quot;Source: mpg&quot;, x = &quot;Class of Vehicle&quot;, y = &quot;City Mileage&quot; ) 图 12.29: 城市里程与车辆类别 蜂群图 ggbeeswarm 是分类散点图加箱线图的合体 ggplot(mpg, aes(x = class, y = hwy, color = class)) + ggbeeswarm::geom_quasirandom() 12.2.7 抖动图 抖动图适合数据量比较小的情况 ggplot(mpg, aes(x = class, y = hwy, color = class)) + geom_jitter() 抖不抖，还是抖一下 ggplot(iris, aes(x = Species, y = Sepal.Length)) + geom_point(aes(fill = Species), size = 5, shape = 21, colour = &quot;grey20&quot;) + # geom_boxplot(outlier.colour = NA, fill = NA, colour = &quot;grey20&quot;) + labs(title = &quot;Not Jittered&quot;) ggplot(iris, aes(x = Species, y = Sepal.Length)) + geom_point(aes(fill = Species), size = 5, shape = 21, colour = &quot;grey20&quot;, position = position_jitter(width = 0.2, height = 0.1) ) + # geom_boxplot(outlier.colour = NA, fill = NA, colour = &quot;grey20&quot;) + labs(title = &quot;Jittered&quot;) 在数据量比较大的时候，可以用箱线图、密度图、提琴图 ggplot(sub_diamonds, aes(x = cut, y = price)) + geom_jitter() 图 12.30: 抖动图的反例 上色和分面都不好使的抖动图，因为区分度变小 ggplot(sub_diamonds, aes(x = color, y = price, color = color)) + geom_jitter() + facet_grid(clarity ~ cut) 图 11.26: 根据钻石颜色上色 箱线图此时不宜分的过细 ggplot(diamonds, aes(x = color, y = price, color = color)) + geom_boxplot() + facet_grid(cut ~ clarity) 图 12.31: 箱线图 所以这样更好，先按纯净度分面，再对比不同的颜色，钻石价格的差异 ggplot(diamonds, aes(x = color, y = price, color = color)) + geom_boxplot() + facet_grid(~clarity) 图 12.32: 钻石按纯净度分面 最好只比较一个维度，不同颜色钻石的价格对比 ggplot(diamonds, aes(x = color, y = price, color = color)) + geom_boxplot() 图 12.33: 不同颜色钻石的价格比较 12.2.8 密度图 ggplot(mpg, aes(cty)) + geom_density(aes(fill = factor(cyl)), alpha = 0.8) + labs( title = &quot;Density plot&quot;, subtitle = &quot;City Mileage Grouped by Number of cylinders&quot;, caption = &quot;Source: mpg&quot;, x = &quot;City Mileage&quot;, fill = &quot;# Cylinders&quot; ) 图 12.34: 按汽缸数分组的城市里程 添加透明度，解决遮挡 ggplot(diamonds, aes(x = price, fill = cut)) + geom_density() ggplot(diamonds, aes(x = price, fill = cut)) + geom_density(alpha = 0.5) 图 12.35: 添加透明度的密度图 堆积密度图 ggplot(diamonds, aes(x = price, fill = cut)) + geom_density(position = &quot;stack&quot;) 图 12.36: 堆积密度图 条件密度估计 # You can use position=&quot;fill&quot; to produce a conditional density estimate ggplot(diamonds, aes(carat, stat(count), fill = cut)) + geom_density(position = &quot;fill&quot;) 图 11.27: 条件密度估计图 岭线图是密度图的一种变体，可以防止密度曲线重叠在一起 ggplot(diamonds) + ggridges::geom_density_ridges(aes(x = price, y = color, fill = color)) #&gt; Picking joint bandwidth of 535 二维的密度图又是一种延伸 ggplot(diamonds, aes(x = carat, y = price)) + geom_density_2d(aes(color = cut)) + facet_grid(~cut) stat 函数，特别是 nlevel 参数，在密度曲线之间填充我们又可以得到热力图 ggplot(diamonds, aes(x = carat, y = price)) + stat_density_2d(aes(fill = stat(nlevel)), geom = &quot;polygon&quot;) + facet_grid(. ~ cut) gemo_hex 也是二维密度图的一种变体，特别适合数据量比较大的情形 ggplot(diamonds, aes(x = carat, y = price)) + geom_hex() + scale_fill_viridis_c() 12.2.9 玫瑰图 南丁格尔风玫瑰图44 可以作为堆积条形图，分组条形图 ggplot(diamonds, aes(x = color, fill = clarity)) + geom_bar() ggplot(diamonds, aes(x = color, fill = clarity)) + geom_bar() + coord_polar() 图 12.37: 堆积条形图转风玫瑰图 # 风玫瑰图 http://blog.csdn.net/Bone_ACE/article/details/47624987 set.seed(2018) # 随机生成100次风向，并汇集到16个区间内 direction &lt;- cut_interval(runif(100, 0, 360), n = 16) # 随机生成100次风速，并划分成4种强度 mag &lt;- cut_interval(rgamma(100, 15), 4) dat &lt;- data.frame(direction = direction, mag = mag) # 将风向映射到X轴，频数映射到Y轴，风速大小映射到填充色，生成条形图后再转为极坐标形式即可 p &lt;- ggplot(dat, aes(x = direction, y = ..count.., fill = mag)) p + geom_bar(colour = &quot;white&quot;) + coord_polar() + theme(axis.ticks = element_blank(), axis.text.y = element_blank()) + labs(x = &quot;&quot;, y = &quot;&quot;, fill = &quot;Magnitude&quot;) 图 12.38: 风玫瑰图 p + geom_bar(position = &quot;fill&quot;) + coord_polar() + theme(axis.ticks = element_blank(), axis.text.y = element_blank()) + labs(x = &quot;&quot;, y = &quot;&quot;, fill = &quot;Magnitude&quot;) 12.2.10 词云图 词云 ggwordcloud 12.2.11 日历图 这是 heatmap 的变种 # 这个图和 Github 的打码图一样的 # 展示每日变化情况 library(ggplot2) library(ggthemes) library(data.table) week.abb &lt;- c(&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot;) month.abb &lt;- c( &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot; ) rides &lt;- data.frame(date = seq.Date( from = as.Date(&quot;2016-04-04&quot;), to = as.Date(&quot;2019-11-09&quot;), by = &quot;day&quot; )) rides$year &lt;- year(rides$date) rides$week &lt;- week(rides$date) rides$weekdays &lt;- factor(wday(rides$date), labels = week.abb) rides$N &lt;- sample(1:40, dim(rides)[1], replace = TRUE) ggplot(rides, aes(x = week, y = weekdays, fill = N)) + scale_fill_viridis_c(name = &quot;Divvy Rides&quot;, option = &quot;C&quot;, limits = c(0, max(rides$N))) + geom_tile(color = &quot;white&quot;, size = 0.4) + facet_wrap(&quot;year&quot;, ncol = 1) + scale_x_continuous(expand = c(0, 0), breaks = seq(1, 52, length = 12), labels = month.abb) + theme_tufte() 12.3 运行环境 xfun::session_info( packages = c( &quot;ggplot2&quot;, &quot;magrittr&quot;, &quot;colorspace&quot;, &quot;nlme&quot;, &quot;mgcv&quot;, &quot;ggbeeswarm&quot;, &quot;ggridges&quot;, &quot;hexbin&quot; ) ) #&gt; R Under development (unstable) (2020-02-04 r77771) #&gt; Platform: x86_64-pc-linux-gnu (64-bit) #&gt; Running under: Ubuntu 16.04.6 LTS #&gt; #&gt; Locale: #&gt; LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C #&gt; LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 #&gt; LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 #&gt; LC_PAPER=en_US.UTF-8 LC_NAME=C #&gt; LC_ADDRESS=C LC_TELEPHONE=C #&gt; LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C #&gt; #&gt; Package version: #&gt; assertthat_0.2.1 beeswarm_0.2.3 cli_2.0.1 #&gt; colorspace_1.4-1 crayon_1.3.4 digest_0.6.23 #&gt; ellipsis_0.3.0 fansi_0.4.1 farver_2.0.3 #&gt; ggbeeswarm_0.6.0 ggplot2_3.2.1 ggridges_0.5.2 #&gt; glue_1.3.1 graphics_4.0.0 grDevices_4.0.0 #&gt; grid_4.0.0 gtable_0.3.0 hexbin_1.28.1 #&gt; labeling_0.3 lattice_0.20.38 lazyeval_0.2.2 #&gt; lifecycle_0.1.0 magrittr_1.5 MASS_7.3.51.5 #&gt; Matrix_1.2.18 methods_4.0.0 mgcv_1.8-31 #&gt; munsell_0.5.0 nlme_3.1-143 pillar_1.4.3 #&gt; pkgconfig_2.0.3 plyr_1.8.5 R6_2.4.1 #&gt; RColorBrewer_1.1.2 Rcpp_1.0.3 reshape2_1.4.3 #&gt; rlang_0.4.4 scales_1.1.0 splines_4.0.0 #&gt; stats_4.0.0 stringi_1.4.5 stringr_1.4.0 #&gt; tibble_2.1.3 tools_4.0.0 utf8_1.1.4 #&gt; utils_4.0.0 vctrs_0.2.2 vipor_0.4.5 #&gt; viridisLite_0.3.0 withr_2.1.2 https://stat.ethz.ch/pipermail/r-help/2007-October/142420.html↩︎ http://varianceexplained.org/r/why-I-use-ggplot2/↩︎ https://simplystatistics.org/2016/02/11/why-i-dont-use-ggplot2/↩︎ https://github.com/ricardo-bion/medium_visualization↩︎ https://leonawicz.github.io/↩︎ https://mbostock.github.io/protovis/ex/crimea-rose-full.html↩︎ "],
["dv-plotly.html", "第 13 章 交互式图形 13.1 plotly 13.2 饼图", " 第 13 章 交互式图形 13.1 plotly library(plotly, warn.conflicts = FALSE, quietly = TRUE) p1 &lt;- plot_ly(diamonds, x = ~price) %&gt;% add_histogram(name = &quot;plotly.js&quot;) price_hist &lt;- function(method = &quot;FD&quot;) { h &lt;- hist(diamonds$price, breaks = method, plot = FALSE) plot_ly(x = h$mids, y = h$counts) %&gt;% add_bars(name = method) } subplot( p1, price_hist(), price_hist(&quot;Sturges&quot;), price_hist(&quot;Scott&quot;), nrows = 4, shareX = TRUE ) Orca (Open-source Report Creator App) 软件针对 plotly.js 库渲染的图形具有很强的导出功能，安装 Orca 后，plotly::orca 函数可以将基于 htmlwidget 的 plotly 图形对象导出为高质量静态图片，支持导出 png、pdf 和 svg 等格式。 图 13.1: 直方图 13.2 饼图 library(ggplot2) library(plotly) #&gt; #&gt; Attaching package: &#39;plotly&#39; #&gt; The following object is masked from &#39;package:ggplot2&#39;: #&gt; #&gt; last_plot #&gt; The following object is masked from &#39;package:stats&#39;: #&gt; #&gt; filter #&gt; The following object is masked from &#39;package:graphics&#39;: #&gt; #&gt; layout USPersonalExpenditure &lt;- data.frame(&quot;Categorie&quot; = rownames(USPersonalExpenditure), USPersonalExpenditure) data &lt;- USPersonalExpenditure[, c(&quot;Categorie&quot;, &quot;X1960&quot;)] colors &lt;- c(&quot;rgb(211,94,96)&quot;, &quot;rgb(128,133,133)&quot;, &quot;rgb(144,103,167)&quot;, &quot;rgb(171,104,87)&quot;, &quot;rgb(114,147,203)&quot;) p &lt;- plot_ly(data, labels = ~Categorie, values = ~X1960, type = &quot;pie&quot;, textposition = &quot;inside&quot;, textinfo = &quot;label+percent&quot;, insidetextfont = list(color = &quot;#FFFFFF&quot;), hoverinfo = &quot;text&quot;, text = ~ paste(&quot;$&quot;, X1960, &quot; billions&quot;), marker = list( colors = colors, line = list(color = &quot;#FFFFFF&quot;, width = 1) ), # The &#39;pull&#39; attribute can also be used to create space between the sectors showlegend = FALSE ) %&gt;% layout( title = &quot;United States Personal Expenditures by Categories in 1960&quot;, xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE), yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE) ) p "],
["dv-plot3d.html", "第 14 章 三维可视化 14.1 饼图 14.2 柱形图 14.3 散点图 14.4 函数图 14.5 透视图 14.6 TikZ 绘图 14.7 图形导出 14.8 软件信息", " 第 14 章 三维可视化 画图 graphics 使用基础 R 包和基于基础包的扩展包绘图 plotrix (???)， plotrix 饼图 pie3D scatterplot3d 三维图形 plot3D 三维图形 barsurf 三维条形图、曲面图 library(barsurf) library(plotrix) library(scatterplot3d) library(plot3D) library(MBA) 14.1 饼图 14.2 柱形图 14.3 散点图 14.4 函数图 14.5 透视图 x &lt;- seq(-10, 10, length = 30) y &lt;- x f &lt;- function(x, y) { r &lt;- sqrt(x^2 + y^2) 10 * sin(r) / r } z &lt;- outer(x, y, f) z[is.na(z)] &lt;- 1 op &lt;- par(bg = &quot;white&quot;) nrz &lt;- nrow(z) ncz &lt;- ncol(z) jet.colors &lt;- colorRampPalette(c(&quot;gray80&quot;, &quot;gray10&quot;)) nbcol &lt;- 100 color &lt;- jet.colors(nbcol) zfacet &lt;- z[-1, -1] + z[-1, -ncz] + z[-nrz, -1] + z[-nrz, -ncz] facetcol &lt;- cut(zfacet, nbcol) persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = color[facetcol] ) persp(x, y, z, xaxs = &quot;i&quot;, expand = 0.5, phi = 20, theta = 60, col = color[facetcol]) persp(x, y, z, theta = 45, phi = 20, expand = 0.5, col = color[facetcol], r = 180, ltheta = 120, shade = 0.75, # ticktype = &quot;detailed&quot;, # 坐标轴上刻度数字 # box=FALSE, # 长方体框线 # nticks=6, # 刻度间隔数目 xlab = &quot;X&quot;, ylab = &quot;Y&quot;, zlab = &quot;Sinc( r )&quot; # border=30 ) theta参数给出了主要方向，控制三维图的左右，phi给出纬度，expand 控制三维图的立体性 安装 rsm 包，添加拟合曲线，响应面曲线 x &lt;- seq(-3, 3, by = 0.25) y &lt;- seq(-3, 3, by = 0.25) d &lt;- expand.grid(x = x, y = y) z &lt;- c(data = NA, 1089) b0 &lt;- 5.628 b1 &lt;- 0 b2 &lt;- 0 b3 &lt;- -.1 b4 &lt;- .1 b5 &lt;- -.1 k &lt;- 1 for (i in 1:25) { for (j in 1:25) { z[k] &lt;- b0 + b1 * x[i] + b2 * y[j] + b3 * x[i] * x[i] + b4 * x[i] * y[j] + b5 * y[j] * y[j] k &lt;- k + 1 } } library(rsm) data.lm &lt;- lm(z ~ poly(x, y, degree = 2), data = d) persp(data.lm, x ~ y, zlim = c(0, max(z)), contour = list(z = &quot;bottom&quot;, col = &quot;colors&quot;), theta = -55, phi = 25 ) res1 &lt;- persp(data.lm, x ~ y, zlim = c(0, max(z)), contour = list(z = &quot;bottom&quot;, col = &quot;colors&quot;), theta = -55, phi = 25 ) xy &lt;- matrix(c((-3 - 8) / 5, -3, (3 - 8) / 5, 3), ncol = 2, byrow = T) lines(trans3d(xy[, 2], xy[, 1], 0, pmat = res1$`y ~ x`$transf), col = 3) 单个总体的最大似然估计，生成总体服从指数分布的随机数 set.seed(1234) n &lt;- 20 # 随机数的个数 x &lt;- rexp(n, rate = 5) m &lt;- 40 # 网格数 mv &lt;- seq(mean(x) - 1.5 * sd(x) / sqrt(n), mean(x) + 1.5 * sd(x) / sqrt(n), length.out = m ) # mu 均值范围 sv &lt;- seq(0.8 * sd(x), 1.5 * sd(x), length.out = m) # 标准差的范围 z &lt;- matrix(NA, m, m) loglikelihood &lt;- function(b) { -sum(dnorm(x, b[1], b[2], log = TRUE)) } for (i in 1:m) { for (j in 1:m) { z[i, j] &lt;- -loglikelihood(c(mv[i], sv[j])) } } nbcol &lt;- 100 color &lt;- hcl.colors(nbcol) zfacet &lt;- z[-1, -1] + z[-1, -m] + z[-m, -1] + z[-m, -m] facetcol &lt;- cut(zfacet, nbcol) # &quot;\\n&quot; adds one line before the label persp(mv, sv, z, xlab = &quot;\\n mu&quot;, ylab = &quot;\\n sigma&quot;, zlab = &quot;\\n log-likelihood&quot;, phi = 35, theta = -30, col = color[facetcol] ) 第一个例子来自 Eric Lecoutre 的图库45，这是我见过的图形中含有巨量公式，并且用 R 实现的例子。在他的基础上我修改了颜色，设置图片尺寸，基于 persp 实现的透视图，唯一不足的是 persp 不支持表达式形式的坐标轴标签。 library(latex2exp) # 代码来自 http://www.ejwagenmakers.com/misc/Plotting_3d_in_R.pdf mu1 &lt;- 0 # setting the expected value of x1 mu2 &lt;- 0 # setting the expected value of x2 s11 &lt;- 10 # setting the variance of x1 s12 &lt;- 15 # setting the covariance between x1 and x2 s22 &lt;- 10 # setting the variance of x2 rho &lt;- 0.5 # setting the correlation coefficient between x1 and x2 x1 &lt;- seq(-10, 10, length = 41) # generating the vector series x1 x2 &lt;- x1 # copying x1 to x2 # setting up the function of the multivariate normal density f &lt;- function(x1, x2) { term1 &lt;- 1 / (2 * pi * sqrt(s11 * s22 * (1 - rho^2))) term2 &lt;- -1 / (2 * (1 - rho^2)) term3 &lt;- (x1 - mu1)^2 / s11 term4 &lt;- (x2 - mu2)^2 / s22 term5 &lt;- -2 * rho * ((x1 - mu1) * (x2 - mu2)) / (sqrt(s11) * sqrt(s22)) term1 * exp(term2 * (term3 + term4 - term5)) } z &lt;- outer(x1, x2, f) # calculating the density values nrz &lt;- nrow(z) ncz &lt;- ncol(z) nbcol &lt;- 100 color &lt;- hcl.colors(100) # Compute the z-value at the facet centres zfacet &lt;- z[-1, -1] + z[-1, -ncz] + z[-nrz, -1] + z[-nrz, -ncz] # Recode facet z-values into color indices facetcol &lt;- cut(zfacet, nbcol) par(mar = c(4.1, 4.1, 4.5, 1.5), ps = 10) persp(x1, x2, z, xlab = &quot;\\n x1&quot;, ylab = &quot;\\n x2&quot;, zlab = &quot;\\n\\n f(x1,x2)&quot;, # xlab = TeX(&#39;$x_{1}$&#39;), # latex2exp 其实是使用 LaTeX 语法将 LaTeX 公式翻译为 R 能接受的表达式形式 # ylab = TeX(&#39;$x_{2}$&#39;), # zlab = TeX(&#39;$f(x_{1},x_{2})$&#39;), main = &quot;Two dimensional Normal Distribution&quot;, col = color[facetcol], border = NA, theta = 30, phi = 20, r = 50, d = 0.1, expand = 0.5, ltheta = 90, lphi = 180, shade = 0.1, ticktype = &quot;detailed&quot;, nticks = 5, box = TRUE ) mtext(expression(list( mu[1] == 0, mu[2] == 0, sigma[11] == 10, sigma[22] == 10, sigma[12] == 15, rho == 0.5 )), side = 3 ) mtext(expression(italic(f) ~ group(&quot;(&quot;, list(x[1], x[2]), &quot;)&quot;) == frac(1, 2 ~ pi ~ sqrt(sigma[11] ~ sigma[22] ~ (1 - rho^2))) ~ exp ~ bgroup( &quot;{&quot;, paste( -frac(1, 2(1 - rho^2)) * phantom(0), bgroup( &quot;[&quot;, frac((x[1] ~ -~ mu[1])^2, sigma[11]) ~ -~2 ~ rho ~ frac(x[1] ~ -~ mu[1], sqrt(sigma[11])) ~ frac(x[2] ~ -~ mu[2], sqrt(sigma[22])) ~ +~ frac((x[2] ~ -~ mu[2])^2, sigma[22]), &quot;]&quot; ) ), &quot;}&quot; )), side = 1, line = 3) 图 14.1: 二元正态概率密度函数 早在 2006 年的时候，Paul Murrell 就提出来一种解决方法46，可是比较复杂，后来谢大大接手了 tikzDevice 包的开发，算是比较好的解决了这个问题，目前该 R 包由 Ralf Stubner 接手维护。 # 代码来自 http://www.ejwagenmakers.com/misc/Plotting_3d_in_R.pdf mu1 &lt;- 0 # setting the expected value of x1 mu2 &lt;- 0 # setting the expected value of x2 s11 &lt;- 10 # setting the variance of x1 s12 &lt;- 15 # setting the covariance between x1 and x2 s22 &lt;- 10 # setting the variance of x2 rho &lt;- 0.5 # setting the correlation coefficient between x1 and x2 x1 &lt;- seq(-10, 10, length = 41) # generating the vector series x1 x2 &lt;- x1 # copying x1 to x2 f &lt;- function(x1, x2) { term1 &lt;- 1 / (2 * pi * sqrt(s11 * s22 * (1 - rho^2))) term2 &lt;- -1 / (2 * (1 - rho^2)) term3 &lt;- (x1 - mu1)^2 / s11 term4 &lt;- (x2 - mu2)^2 / s22 term5 &lt;- -2 * rho * ((x1 - mu1) * (x2 - mu2)) / (sqrt(s11) * sqrt(s22)) term1 * exp(term2 * (term3 + term4 - term5)) } # setting up the function of the multivariate normal density z &lt;- outer(x1, x2, f) # calculating the density values nrz &lt;- nrow(z) ncz &lt;- ncol(z) nbcol &lt;- 100 color &lt;- hcl.colors(100) # Compute the z-value at the facet centres zfacet &lt;- z[-1, -1] + z[-1, -ncz] + z[-nrz, -1] + z[-nrz, -ncz] # Recode facet z-values into color indices facetcol &lt;- cut(zfacet, nbcol) par(mar = c(4.1, 4.1, 4.5, 1.5)) persp(x1, x2, z, xlab = &quot;$x_{1}$&quot;, ylab = &quot;$x_{2}$&quot;, zlab = &quot;$f(x_{1},x_{2})$&quot;, main = &quot;Two dimensional Normal Distribution&quot;, col = color[facetcol], border = NA, theta = 30, phi = 20, r = 50, d = 0.1, expand = 0.5, ltheta = 90, lphi = 180, shade = 0.1, ticktype = &quot;detailed&quot;, nticks = 5, box = TRUE ) mtext(&quot;$\\\\mu_1 = 0,\\\\mu_2 = 0,\\\\sigma_{11} = 10,\\\\sigma_{22} = 10,\\\\sigma_{12} = 15, \\\\rho = 0.5$&quot;, side = 3) mtext(&quot;$f(x_{1},x_{2}) = \\\\frac{1}{2\\\\pi\\\\sqrt{\\\\sigma_{11}\\\\sigma_{22}(1-\\\\rho^2)}}\\\\exp\\\\big\\\\{-\\\\frac{1}{2(1-\\\\rho^2)}[\\\\frac{(x_1 - \\\\mu_1)^2}{\\\\sigma_{11}} - 2\\\\rho\\\\frac{(x_1 - \\\\mu_1)(x_2 - \\\\mu_2)}{\\\\sqrt{\\\\sigma_{11}}\\\\sqrt{\\\\sigma_{22}}} + \\\\frac{(x_2 - \\\\mu_2)^2}{\\\\sigma_{22}}]\\\\big\\\\}$&quot;, side = 1, line = 2, cex = 1.5 ) 图 14.2: 二元正态密度函数 library(lattice) wireframe(z ~ x1 + x2, data = data.frame(x1 = x1, x2 = rep(x2, each = length(x1)), z = z), xlab = expression(x[1]), ylab = expression(x[2]), zlab = expression(italic(f) ~ group(&quot;(&quot;, list(x[1], x[2]), &quot;)&quot;)), colorkey = TRUE, drape = TRUE ) 图 14.3: 表达式二元密度函数 ## volcano ## 87 x 61 matrix wireframe(volcano, shade = TRUE, aspect = c(61 / 87, 0.4), light.source = c(10, 0, 10) ) 希腊字母用 unicode 字符代替，不要使用 pdf 不然数学符号 \\(\\sigma\\) 不能正确渲染，推荐选择 cairo_pdf # https://stackoverflow.com/questions/41190525/adjust-margins-in-persp-persp3d-in-r # https://stackoverflow.com/questions/37571376/how-to-customize-nticks-in-persp-r # https://stackoverflow.com/questions/43507680/are-xlab-ylab-and-zlab-in-persp-incompatible-with-bquote x &lt;- seq(-10, 10, len = 30) y &lt;- seq(0, 5, len = 30) f &lt;- function(x, y) { dnorm(2, x, y) } z &lt;- outer(x, y, f) persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = &quot;lightblue&quot;, xlab = &quot;\\u03bc&quot;, ylab = &quot;\\u03c3\\u207F&quot;, zlab = paste(&quot;Likelihood &quot;, &quot;(\\u03bc,\\u03c3\\u207F)&quot;, sep = &quot;&quot;) ) 图 14.4: unicode 字符代替希腊字母 透视图案例，插值 LIDAR 数据集包含 10123 组观测值，每组观测包含经度、维度和海拔三个分量, mba.surf 使用多水平 B-样条近似曲面 library(MBA) data(LIDAR) # 一小部分光探测和测距雷达数据，美国威斯康辛州森林景观 mba.int &lt;- mba.surf(LIDAR, 300, 300, extend = TRUE)$xyz.est image(mba.int, xaxs = &quot;r&quot;, yaxs = &quot;r&quot;) # 透视图 persp(mba.int, theta = 90, phi = 20, col = &quot;green3&quot;, scale = FALSE, ltheta = -120, shade = 0.75, expand = 10, border = NA, box = FALSE ) z &lt;- mba.int$z nrz &lt;- nrow(z) ncz &lt;- ncol(z) nbcol &lt;- 100 color &lt;- hcl.colors(nbcol) # Compute the z-value at the facet centres zfacet &lt;- z[-1, -1] + z[-1, -ncz] + z[-nrz, -1] + z[-nrz, -ncz] # z 分量用颜色表示 facetcol &lt;- cut(zfacet, nbcol) # png(file=&quot;mba.png&quot;,res=300,width = 680,height = 680) par(mar = rep(0, 4)) ## 透视图 persp(mba.int, theta = 90, phi = 20, col = color[facetcol], scale = FALSE, ltheta = -120, shade = 0.75, expand = 20, border = NA, box = FALSE ) # 热图 image(mba.int, xaxs = &quot;r&quot;, yaxs = &quot;r&quot;, col = gray(seq(1, 0, l = 101))) library(barsurf) x &lt;- y &lt;- 1:4 f &lt;- function(x, y) x^2 + y^2 z &lt;- outer(x, y, f) plot3d.bar(, , z) plot3d.bar(, , volcano) plot3d.surf(, , volcano) 14.6 TikZ 绘图 用 Base R 绘制带有复杂数学公式的图形，tikzDevice 包结合 R Markdown 的使用，引入 LaTeX 绘图引擎 TikZ 主要是借助 LaTeX 对数学符号的强大支持，让R 语言绘制的图形上出现优美的复杂的数学符号表达式 以 tikzDevice 绘图， out.width='35%' 设置一幅子图占页面的宽度，在 _common.R 设置页面宽度为 out.width='70%'，即全宽图占页面 70% 的宽度。 fig.asp=1 设置子图的长宽比例为 1:1，即正方形。设置图片的宽度，默认是 fig.width = 6 相应地，图片的高度是 fig.height = fig.width * fig.asp = 6 * 0.618 = 3.708 但是这个比例使得图片上的字很小，所以设置fig.width=2.5。设置图形设备 dev='tikz'，此时会自动调用 tikzDevice 包处理图上的数学公式，tikzDevice 包将 LaTeX 中的 TikZ 绘图引擎引入到基础 R 绘图中，由于该引擎将R代码块转化为 .tex 文件，接着调用 LaTeX 编译，默认生成 PDF 格式图片，因此设置 tikz2png='-density 300' 调用 ImageMgick 的 convert 命令将 PDF 格式图片转化为 PNG 格式图片，转化前需要用 Ghostscript 读取该 PDF 文件，转化成功后，需要将该 PNG 格式文件路径返回，以插入到文档中。bessel-function 是给该图片的命名，这段代码生成两张图片，两个图片就分别叫做 bessel-function-1.pdf 和 bessel-function-2.pdf。在 LaTeX 里并排插入两个图片，需要在导言区加载 subfig 宏包。 knitr 提供 Tikz 图形的模版， system.file('misc', 'tikz2pdf.tex', package = 'knitr')，tikzDevice 包可以方便的把 R 代码转化为 tikz 代码，然后使用 LaTeX 引擎编译成 PDF 文档，特别地，它很好地支持了图里的数学公式 library(tikzDevice) tf &lt;- file.path(getwd(), &quot;demo-tikzDevice.tex&quot;) tikz(tf, width = 6, height = 4, pointsize = 30, standAlone = TRUE) # 绘图的代码，仅支持 Base R Graphics System source(file = &quot;code/chapter_03/matern.R&quot;) dev.off() tools::texi2dvi(tf, pdf = T) system(&quot;rm demo-tikzDevice.tex *.log *.aux *.dvi&quot;) system(&quot;convert -density 300 -trim demo-tikzDevice.pdf -quality 100 demo-tikzDevice.png&quot;) system(&quot;mv demo-tikzDevice.* figures/&quot;) # convert test.svg test.png 两个利用 tikzDevice 包的例子 # 带有图标题 x &lt;- rnorm(10) y &lt;- x + rnorm(5, sd = 0.25) model &lt;- lm(y ~ x) rsq &lt;- summary(model)$r.squared rsq &lt;- signif(rsq, 4) plot(x, y, main = &quot;Hello \\\\LaTeX!&quot;, xlab = &quot;$x$&quot;, ylab = &quot;$y$&quot;) abline(model, col = &quot;red&quot;) mtext(paste(&quot;Linear model: $R^{2}=&quot;, rsq, &quot;$&quot;), line = 0.5) legend(&quot;bottomright&quot;, legend = paste(&quot;$y = &quot;, round(coef(model)[2], 3), &quot;x +&quot;, round(coef(model)[1], 3), &quot;$&quot;, sep = &quot;&quot; ), bty = &quot;n&quot;) plot(x, y, main = &quot;Hello \\\\LaTeX!&quot;, xlab = &quot;$x$&quot;, ylab = &quot;$y$&quot;) abline(model, col = &quot;red&quot;) mtext(paste(&quot;Linear model: $R^{2}=&quot;, rsq, &quot;$&quot;), line = 0.5) legend(&quot;bottomright&quot;, legend = paste(&quot;$y = &quot;, round(coef(model)[2], 3), &quot;x +&quot;, round(coef(model)[1], 3), &quot;$&quot;, sep = &quot;&quot; ), bty = &quot;n&quot;) 图 14.5: 线性回归模型 x0 &lt;- 2^(-20:10) nus &lt;- c(0:5, 10, 20) x &lt;- seq(0, 4, length.out = 501) plot(x0, x0^-8, frame.plot = TRUE, # 添加绘图框 log = &quot;xy&quot;, # x 和 y 轴都取对数尺度 axes = FALSE, # 去掉坐标轴 xlab = &quot;$u$&quot;, ylab = &quot;$\\\\mathcal{K}_{\\\\kappa}(u)$&quot;, # 设置坐标轴标签 type = &quot;n&quot;, # 清除绘图区域的内容 ann = TRUE, # 添加标题 x和y轴标签 panel.first = grid() # 添加背景参考线 ) axis(1, at = 10^seq(from = -8, to = 2, by = 2), labels = paste0(&quot;$\\\\mathsf{10^{&quot;, seq(from = -8, to = 2, by = 2), &quot;}}$&quot;) ) axis(2, at = 10^seq(from = -8, to = 56, by = 16), labels = paste0(&quot;$\\\\mathsf{10^{&quot;, seq(from = -8, to = 56, by = 16), &quot;}}$&quot;), las = 1 ) for (i in seq(length(nus))) { lines(x0, besselK(x0, nu = nus[i]), col = hcl.colors(9)[i], lwd = 2) } legend(&quot;topright&quot;, legend = paste0(&quot;$\\\\kappa=&quot;, rev(nus), &quot;$&quot;), col = hcl.colors(9, rev = T), lwd = 2, cex = 1 ) x &lt;- seq(0, 4, length.out = 501) x &lt;- x[x &gt; 0] plot(x, x, frame.plot = TRUE, ylim = c(1e+0, 1e+20), log = &quot;y&quot;, xlab = &quot;$u$&quot;, type = &quot;n&quot;, yaxt = &quot;n&quot;, ylab = &quot;$\\\\mathcal{K}_{\\\\kappa}(u)$&quot;, ann = TRUE, panel.first = grid() ) axis(2, at = c(1e+0, 1e+05, 1e+10, 1e+15, 1e+20), labels = paste0(&quot;$\\\\mathsf{10^{&quot;, seq(from = 0, to = 20, by = 5), &quot;}}$&quot;), las = 1 ) for (i in seq(length(nus))) { lines(x, besselK(x, nu = nus[i]), col = hcl.colors(9)[i], lwd = 2) } legend(&quot;topright&quot;, legend = paste0(&quot;$\\\\kappa=&quot;, rev(nus), &quot;$&quot;), col = hcl.colors(9, rev = T), lwd = 2, cex = 1 ) 图 14.6: 贝塞尔函数 \\usetikzlibrary{arrows} \\begin{tikzpicture}[node distance=2cm, auto,&gt;=latex&#39;, thick, scale = 0.5] \\node (P) {$P$}; \\node (B) [right of=P] {$B$}; \\node (A) [below of=P] {$A$}; \\node (C) [below of=B] {$C$}; \\node (P1) [node distance=1.4cm, left of=P, above of=P] {$\\hat{P}$}; \\draw[-&gt;] (P) to node {$f$} (B); \\draw[-&gt;] (P) to node [swap] {$g$} (A); \\draw[-&gt;] (A) to node [swap] {$f$} (C); \\draw[-&gt;] (B) to node {$g$} (C); \\draw[-&gt;, bend right] (P1) to node [swap] {$\\hat{g}$} (A); \\draw[-&gt;, bend left] (P1) to node {$\\hat{f}$} (B); \\draw[-&gt;, dashed] (P1) to node {$k$} (P); \\end{tikzpicture} \\begin{tikzpicture} \\begin{scope}[blend group = soft light] \\fill[red!30!white] ( 90:1.2) circle (2); \\fill[green!30!white] (210:1.2) circle (2); \\fill[blue!30!white] (330:1.2) circle (2); \\end{scope} \\node at ( 90:2) {Typography}; \\node at ( 210:2) {Design}; \\node at ( 330:2) {Coding}; \\node [font=\\Large] {\\LaTeX}; \\end{tikzpicture} 图 14.7: Venn 图 14.7 图形导出 图形导出的格式主要看面向的呈现方式，如插入 HTML 网页中，可选 png， svg， rgl 和 gif 格式，插入 LaTeX 文档中，可选 eps，ps，pdf 和 png 等格式 保存绘制的图形，R 使用的图形渲染库的版本 grSoftVersion() #&gt; cairo libpng jpeg #&gt; &quot;1.14.6&quot; &quot;1.2.54&quot; &quot;8.0&quot; #&gt; libtiff #&gt; &quot;LIBTIFF, Version 4.0.6&quot; 当前 R 环境中支持的图形设备 capabilities() #&gt; jpeg png tiff tcltk X11 aqua #&gt; TRUE TRUE TRUE TRUE TRUE FALSE #&gt; http/ftp sockets libxml fifo cledit iconv #&gt; TRUE TRUE TRUE TRUE FALSE TRUE #&gt; NLS profmem cairo ICU long.double libcurl #&gt; TRUE TRUE TRUE TRUE TRUE TRUE 表 14.1: 图形设备列表 设备 函数 windows cairo_pdf, cairo_ps pdf svg postscript png xfig jpeg bitmap bmp pictex tiff 图形设备控制函数 apropos(&quot;dev.&quot;) #&gt; [1] &quot;.Device&quot; &quot;.Devices&quot; &quot;dev.capabilities&quot; #&gt; [4] &quot;dev.capture&quot; &quot;dev.control&quot; &quot;dev.copy&quot; #&gt; [7] &quot;dev.copy2eps&quot; &quot;dev.copy2pdf&quot; &quot;dev.cur&quot; #&gt; [10] &quot;dev.flush&quot; &quot;dev.hold&quot; &quot;dev.interactive&quot; #&gt; [13] &quot;dev.list&quot; &quot;dev.new&quot; &quot;dev.next&quot; #&gt; [16] &quot;dev.off&quot; &quot;dev.prev&quot; &quot;dev.print&quot; #&gt; [19] &quot;dev.set&quot; &quot;dev.size&quot; &quot;dev2bitmap&quot; #&gt; [22] &quot;devAskNewPage&quot; &quot;deviance&quot; &quot;deviceIsInteractive&quot; #&gt; [25] &quot;trellis.device&quot; 导入导出 SVG 格式矢量图形 The Butterfly Affectation: A case study in embedding an external image in an R plot Improved Importing of Vector Graphics in R 14.8 软件信息 sessionInfo() #&gt; R Under development (unstable) (2020-02-04 r77771) #&gt; Platform: x86_64-pc-linux-gnu (64-bit) #&gt; Running under: Ubuntu 16.04.6 LTS #&gt; #&gt; Matrix products: default #&gt; BLAS: /home/travis/R-bin/lib/R/lib/libRblas.so #&gt; LAPACK: /home/travis/R-bin/lib/R/lib/libRlapack.so #&gt; #&gt; locale: #&gt; [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C #&gt; [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 #&gt; [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 #&gt; [7] LC_PAPER=en_US.UTF-8 LC_NAME=C #&gt; [9] LC_ADDRESS=C LC_TELEPHONE=C #&gt; [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C #&gt; #&gt; attached base packages: #&gt; [1] stats graphics grDevices utils datasets methods base #&gt; #&gt; other attached packages: #&gt; [1] lattice_0.20-38 latex2exp_0.4.0 rsm_2.10 #&gt; [4] MBA_0.0-9 plot3D_1.3 scatterplot3d_0.3-41 #&gt; [7] plotrix_3.7-7 barsurf_0.3.1 #&gt; #&gt; loaded via a namespace (and not attached): #&gt; [1] Rcpp_1.0.3 knitr_1.26 magrittr_1.5 misc3d_0.8-4 #&gt; [5] colorspace_1.4-1 rlang_0.4.4 filehash_2.4-2 stringr_1.4.0 #&gt; [9] highr_0.8 pdftools_2.3 tools_4.0.0 grid_4.0.0 #&gt; [13] tikzDevice_0.12.3 xfun_0.12 tinytex_0.19 askpass_1.1 #&gt; [17] htmltools_0.4.0 yaml_2.2.1 digest_0.6.23 qpdf_1.1 #&gt; [21] bookdown_0.17 curl_4.3 evaluate_0.14 rmarkdown_2.1 #&gt; [25] stringi_1.4.5 compiler_4.0.0 magick_2.3 http://www.ejwagenmakers.com/misc/Plotting_3d_in_R.pdf↩︎ https://www.stat.auckland.ac.nz/~paul/Talks/fonts.pdf↩︎ "],
["dv-colors-fonts.html", "第 15 章 色彩与字体 15.1 颜色 15.2 配色 15.3 字体", " 第 15 章 色彩与字体 15.1 颜色 在 R 语言中，如何表示颜色， 使用内置的颜色名称，如 red 表示红色，green 表示绿色，而 blue 表示蓝色，完整的颜色名称列表，见 colors() 或者 colours()，有人整理了一张 R 内置的颜色名称和对应颜色图 https://stat.columbia.edu/~tzheng/files/Rcolor.pdf，可供参考 用十六进制的字符串表示颜色，如 #000000 表示黑色，#FF0000 表示红色，#00FF00 表示绿色 如何构造颜色 rgb 函数是最常用的 红(red)、绿(green)、蓝(blue)是三原色，由他们的不同配比可以构成大千世界里五光十色 rgb(red, green, blue, alpha, names = NULL, maxColorValue = 1) 函数参数说明： red, blue, green 取值范围\\([0,M]\\)，\\(M\\) 是 maxColorValue 默认情况下参数 maxColorValue 为 1 names 字符向量，给这组颜色值取名 maxColorValue 红，绿，蓝三色范围的最大值 alpha 是颜色的透明度 rgb 产生一种颜色，如 rgb(255, 0, 0, maxColorValue = 255) 的颜色是 \"#FF0000\" ，这是一串16进制数，每两个一组，那么一组有 \\(16^2 = 256\\) 种组合，整个一串有 \\(256^3 = 16777216\\) 种组合，这就是RGB表达的所有颜色，一个标准的 RGB 颜色空间，即 sRGB (IEC standard 61966)。用色条示意，如图 15.2 # 黑色 红色 绿色 黄色 蓝色 紫色 青色 白色 rgb(expand.grid(r = c(0, 1), g = c(0, 1), b = c(0, 1))) #&gt; [1] &quot;#000000&quot; &quot;#FF0000&quot; &quot;#00FF00&quot; &quot;#FFFF00&quot; &quot;#0000FF&quot; &quot;#FF00FF&quot; &quot;#00FFFF&quot; #&gt; [8] &quot;#FFFFFF&quot; palette(\"default\") 默认的调色板将灰色替换上述白色 barplot(seq(8), col = palette(&quot;default&quot;), border = &quot;white&quot;) 图 15.1: 默认的调色板 barplot(rep(1, times = 100), col = rainbow(100), border = FALSE, axes = FALSE) 图 15.2: 内置的彩虹系调色板 15.2 配色 调色板合集 paletteer，其收录了很多 R 包制作的调色板，其中包括 r-color-palettes 和 wesanderson，根据电影 Harry Potter 制作的调色板 harrypotter，根据网站 CARTO 设计的 rcartocolor 包 colorblindr 模拟色盲环境下的配色方案 不同的颜色模式，从 RGB 到 HCL 的基本操作 https://stat545.com/block018_colors.html # https://github.com/hadley/ggplot2-book library(tidyverse) hcl &lt;- expand.grid(x = seq(-1, 1, length = 100), y = seq(-1, 1, length=100)) %&gt;% tbl_df() %&gt;% filter(x^2 + y^2 &lt; 1) %&gt;% mutate( r = sqrt(x^2 + y^2), c = 100 * r, h = 180 / pi * atan2(y, x), l = 65, colour = hcl(h, c, l) ) # sin(h) = y / (c / 100) # y = sin(h) * c / 100 cols &lt;- scales::hue_pal()(5) selected &lt;- colorspace::RGB(t(col2rgb(cols)) / 255) %&gt;% as(&quot;polarLUV&quot;) %&gt;% colorspace::coords() %&gt;% as.data.frame() %&gt;% mutate( x = cos(H / 180 * pi) * C / 100, y = sin(H / 180 * pi) * C / 100, colour = cols ) ggplot(hcl, aes(x, y)) + geom_raster(aes(fill = colour)) + scale_fill_identity() + scale_colour_identity() + coord_equal() + scale_x_continuous(&quot;&quot;, breaks = NULL) + scale_y_continuous(&quot;&quot;, breaks = NULL) + geom_point(data = selected, size = 10, color = &quot;white&quot;) + geom_point(data = selected, size = 5, aes(colour = colour)) 图 11.3: HCL调色 R 内置了 502 种不同颜色的名称，下面随机地选取 20 种颜色 sample(colors(TRUE), 20) #&gt; [1] &quot;azure4&quot; &quot;gray48&quot; &quot;palevioletred4&quot; &quot;gray4&quot; #&gt; [5] &quot;orangered2&quot; &quot;lightblue1&quot; &quot;mediumvioletred&quot; &quot;mediumorchid2&quot; #&gt; [9] &quot;orange4&quot; &quot;mediumorchid1&quot; &quot;brown4&quot; &quot;orangered&quot; #&gt; [13] &quot;rosybrown3&quot; &quot;darkorchid3&quot; &quot;darkred&quot; &quot;mediumpurple3&quot; #&gt; [17] &quot;pink2&quot; &quot;green&quot; &quot;bisque3&quot; &quot;gray14&quot; R 包 grDevices 提供 hcl 调色板47 调制两个色板 # Colors from https://github.com/johannesbjork/LaCroixColoR color_pal &lt;- c(&quot;#FF3200&quot;, &quot;#E9A17C&quot;, &quot;#E9E4A6&quot;, &quot;#1BB6AF&quot;, &quot;#0076BB&quot;, &quot;#172869&quot;) n &lt;- 16 more_colors &lt;- (grDevices::colorRampPalette(color_pal))(n) scales::show_col(colours = more_colors) 图 15.3: 桃色至梨色的渐变 # colors in colortools from http://www.gastonsanchez.com/ fish_pal &lt;- c( &quot;#69D2E7&quot;, &quot;#6993E7&quot;, &quot;#7E69E7&quot;, &quot;#BD69E7&quot;, &quot;#E769D2&quot;, &quot;#E76993&quot;, &quot;#E77E69&quot;, &quot;#E7BD69&quot;, &quot;#D2E769&quot;, &quot;#93E769&quot;, &quot;#69E77E&quot;, &quot;#69E7BD&quot; ) more_colors &lt;- (grDevices::colorRampPalette(fish_pal))(n) scales::show_col(colours = more_colors) 图 15.4: Hue-Saturation-Value (HSV) color model rgb(red = 86, green = 180, blue = 233, maxColorValue = 255) # &quot;#56B4E9&quot; #&gt; [1] &quot;#56B4E9&quot; rgb(red = 0, green = 158, blue = 115, maxColorValue = 255) # &quot;#009E73&quot; #&gt; [1] &quot;#009E73&quot; rgb(red = 240, green = 228, blue = 66, maxColorValue = 255) # &quot;#F0E442&quot; #&gt; [1] &quot;#F0E442&quot; rgb(red = 0, green = 114, blue = 178, maxColorValue = 255) # &quot;#0072B2&quot; #&gt; [1] &quot;#0072B2&quot; 举例子，直方图配色与不配色 # library(pander) # evalsOptions(&#39;graph.unify&#39;, TRUE) # panderOptions(&#39;graph.colors&#39;) 获取调色板 # https://www.fontke.com/tool/rgbschemes/ 在线配色 cols &lt;- c( &quot;#56B4E9&quot;, &quot;#009E73&quot;, &quot;#F0E442&quot;, &quot;#0072B2&quot;, &quot;#D55E00&quot;, &quot;#CC79A7&quot;, &quot;#999999&quot;, &quot;#E69F00&quot; ) hist(mtcars$hp, col = &quot;#56B4E9&quot;, border = &quot;white&quot;, grid = grid()) 图 15.5: 直方图 ggplot(mtcars) + geom_histogram(aes(x = hp, fill = as.factor(..count..)), color = &quot;white&quot;, bins = 6 ) + scale_fill_manual(values = rep(&quot;#56B4E9&quot;, 10)) + ggtitle(&quot;Histogram with ggplot2&quot;) + theme_minimal() + theme(legend.position = &quot;none&quot;) 图 11.6: 直方图 15.2.1 colourlovers colourlovers 包借助 XML, jsonlite 和 httr 包可以在线获取网站 COLOURlovers 的调色板 library(colourlovers) palette1 &lt;- clpalette(&#39;113451&#39;) palette2 &lt;- clpalette(&#39;92095&#39;) palette3 &lt;- clpalette(&#39;629637&#39;) palette4 &lt;- clpalette(&#39;694737&#39;) 使用调色板 layout(matrix(1:4, nrow = 2)) par(mar = c(2, 2, 2, 2)) barplot(VADeaths, col = swatch(palette1)[[1]], border = NA) barplot(VADeaths, col = swatch(palette2)[[1]], border = NA) barplot(VADeaths, col = swatch(palette3)[[1]], border = NA) barplot(VADeaths, col = swatch(palette4)[[1]], border = NA) 调色板的描述信息 palette1 #&gt; Palette ID: 113451 #&gt; Title: Anaconda #&gt; Created by user: kunteper #&gt; Date created: 2007-08-05 14:14:15 #&gt; Views: 687 #&gt; Votes: 2 #&gt; Comments: 2 #&gt; Hearts: 0 #&gt; Rank: 0 #&gt; URL: http://www.colourlovers.com/palette/113451/Anaconda #&gt; Image URL: #&gt; Colors: #2B2D42, #7A7D7F, #B1BBCF, #6E0B21, #9B4D73 获取调色板中的颜色向量 swatch(palette1)[[1]] #&gt; [1] &quot;#2B2D42&quot; &quot;#7A7D7F&quot; &quot;#B1BBCF&quot; &quot;#6E0B21&quot; &quot;#9B4D73&quot; 15.3 字体 firatheme 包提供基于 fira sans 字体的 GGplot2 主题，类似的字体主题包还有 trekfont 、 fontHind， fontquiver 包与 fontBitstreamVera（Bitstream Vera 字体）、 fontLiberation（Liberation 字体）包和 fontDejaVu （DejaVu 字体）包一道提供了一些可允许使用的字体文件，这样，我们可以不依赖系统制作可重复的图形。 Thomas Lin Pedersen 开发的 systemfonts 可直接使用系统自带的字体 library(firatheme) ggplot(mtcars, aes(x = mpg * 0.43, y = wt * 0.4535924, colour = factor(cyl))) + geom_point(size = 2) + geom_smooth(se = FALSE) + labs( title = &quot;Car weight vs efficiency&quot;, x = &quot;Efficiency (km/l)&quot;, y = &quot;Weight (1000 kg)&quot;, colour = &quot;Cylinders&quot; ) + theme_fira() + scale_colour_fira() #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 以常用的新罗马字体为例，在 R 绘图代码中全局设置字体 par(family=\"Times\") 或者 par(family=\"serif\")，数据集 cars 的含义，散点图 15.6 表达的统计意义 # plot(speed ~ dist, data = cars) # # plot(speed ~ dist, data = cars, panel.first = grid(8, 8), # pch = 0, cex = 1.2, col = &quot;blue&quot;, xlab = &quot;speed&quot;, ylab = &quot;dist&quot; # ) # # plot(speed ~ dist, data = cars, # panel.first = lines(stats::lowess(cars$speed, cars$dist), lty = &quot;dashed&quot;), # pch = 0, cex = 1.2, col = &quot;blue&quot;, xlab = &quot;speed&quot;, ylab = &quot;dist&quot; # ) plot(Ozone ~ Wind, data = airquality, pch = as.character(Month), subset = Month != 7) 图 15.6: 数学字体 pdf 设备使用 sans 字体 ArialMT + SymbolMT 字体显示，默认字体，添加代码块设置 dev.args=list(family = \"sans\") 图15.7 par(mar = c(4, 4, 2, 1)) x &lt;- seq(-4, 4, len = 101) y &lt;- cbind(sin(x), cos(x)) matplot(x, y, type = &quot;l&quot;, xaxt = &quot;n&quot;, main = expression(paste( plain(sin) * phi, &quot; and &quot;, plain(cos) * phi )), ylab = expression(&quot;sin&quot; * phi, &quot;cos&quot; * phi), # only 1st is taken xlab = expression(paste(&quot;Phase Angle &quot;, phi)), col.main = &quot;blue&quot; ) axis(1, at = c(-pi, -pi / 2, 0, pi / 2, pi), labels = expression(-pi, -pi / 2, 0, pi / 2, pi) ) 图 15.7: 默认 sans 字体 CM &lt;- Type1Font( &quot;CM&quot;, c(file.path( system.file(&quot;fonts&quot;, &quot;metrics&quot;, package = &quot;fontcm&quot;), c( &quot;fcmr8a.afm&quot;, &quot;fcmb8a.afm&quot;, &quot;fcmri8a.afm&quot;, &quot;fcmbi8a.afm&quot;, &quot;cmsyase.afm&quot; ) )) ) pdfFonts(CM = CM) family 指定字体，默认字体 Helvetica pdf(&quot;cm.pdf&quot;, family = &quot;CM&quot;, width = 4, height = 4) par(mar = c(4.1, 4.1, 0.5, 0.5)) x &lt;- seq(-4, 4, len = 101) y &lt;- cbind(sin(x), cos(x)) matplot(x, y, type = &quot;l&quot;, xaxt = &quot;n&quot;, main = expression(paste( plain(sin) * phi, &quot; and &quot;, plain(cos) * phi )), ylab = expression(&quot;sin&quot; * phi, &quot;cos&quot; * phi), # only 1st is taken xlab = expression(paste(&quot;Phase Angle &quot;, phi)), col.main = &quot;blue&quot; ) axis(1, at = c(-pi, -pi / 2, 0, pi / 2, pi), labels = expression(-pi, -pi / 2, 0, pi / 2, pi) ) dev.off() Sys.setenv(R_GSCMD = &quot;C:/Program Files/gs/gs9.26/bin/gswin64c.exe&quot;) # embedFonts(file = &quot;cm.pdf&quot;, outfile = &quot;cm-embed.pdf&quot;) # GS 默认搜索路径不对 embedFonts( file = &quot;cm.pdf&quot;, outfile = &quot;cm-embed.pdf&quot;, fontpaths = system.file(&quot;fonts&quot;, package = &quot;fontcm&quot;) # 指定字体搜索路径 ) fontcm 包 (???) 实现在 Base R 图形中嵌入数学字体48，图形中嵌入重音字符49 调用系统字体，安装使用网络字体 library(showtext, quietly = TRUE) showtext_auto() pdf(&quot;google-fonts.pdf&quot;) font_add_google(&quot;Alegreya Sans&quot;, &quot;aleg&quot;) par(family = &quot;serif&quot;) plot(0:5, 0:5, type = &quot;n&quot;) text(1:4, 1:4, &quot;Serif&quot;, font = 1:4, cex = 2) par(family = &quot;fira-sans&quot;) plot(0:5, 0:5, type = &quot;n&quot;) text(1:4, 1:4, &quot;Sans&quot;, font = 1:4, cex = 2) dev.off() knitr 支持的引擎有： names(knitr::knit_engines$get()) #&gt; [1] &quot;awk&quot; &quot;bash&quot; &quot;coffee&quot; &quot;gawk&quot; &quot;groovy&quot; #&gt; [6] &quot;haskell&quot; &quot;lein&quot; &quot;mysql&quot; &quot;node&quot; &quot;octave&quot; #&gt; [11] &quot;perl&quot; &quot;psql&quot; &quot;Rscript&quot; &quot;ruby&quot; &quot;sas&quot; #&gt; [16] &quot;scala&quot; &quot;sed&quot; &quot;sh&quot; &quot;stata&quot; &quot;zsh&quot; #&gt; [21] &quot;highlight&quot; &quot;Rcpp&quot; &quot;tikz&quot; &quot;dot&quot; &quot;c&quot; #&gt; [26] &quot;fortran&quot; &quot;fortran95&quot; &quot;asy&quot; &quot;cat&quot; &quot;asis&quot; #&gt; [31] &quot;stan&quot; &quot;block&quot; &quot;block2&quot; &quot;js&quot; &quot;css&quot; #&gt; [36] &quot;sql&quot; &quot;go&quot; &quot;python&quot; &quot;julia&quot; &quot;sass&quot; #&gt; [41] &quot;scss&quot; &quot;theorem&quot; &quot;lemma&quot; &quot;corollary&quot; &quot;proposition&quot; #&gt; [46] &quot;conjecture&quot; &quot;definition&quot; &quot;example&quot; &quot;exercise&quot; &quot;proof&quot; #&gt; [51] &quot;remark&quot; &quot;solution&quot; 导入系统TTF类型字体到 R 环境中，这样绘图可以使用更多的字体 install.packages(&quot;extrafont&quot;) library(extrafont) font_import() # 查看可用的字体 # Vector of font family names fonts() # Show entire table fonttable() # 加载字体 # Only necessary in session where you ran font_import() loadfonts() # For PostScript output, use loadfonts(device=&quot;postscript&quot;) # Suppress output with loadfonts(quiet=TRUE) 测试字体是否被正确调用 pdf(&quot;font_Impact.pdf&quot;, family = &quot;Impact&quot;, width = 4, height = 4) par(mar = c(4.1, 4.1, 2.1, 0.5)) plot(mtcars$mpg, mtcars$wt, main = &quot;Fuel Efficiency of 32 Cars&quot;, xlab = &quot;Weight (x1000 lb)&quot;, ylab = &quot;Miles per Gallon&quot; ) dev.off() PDF 格式图片转 PNG 格式 convert -quality 100 -density 300x300 font_Impact.pdf font_Impact.png 图 15.8: Impact 字体 https://developer.r-project.org/Blog/public/2019/04/01/hcl-based-color-palettes-in-grdevices/index.html↩︎ https://www.stat.auckland.ac.nz/~paul/R/CM/CMR.html↩︎ https://www.stat.auckland.ac.nz/~paul/Reports/maori/maori.html↩︎ "],
["dv-highcharter.html", "第 16 章 highcharter 图形 16.1 折线图 16.2 散点图 16.3 条形图 16.4 箱线图 16.5 密度图 16.6 直方图 16.7 生存图 16.8 等高图 16.9 相关图 16.10 矩阵图", " 第 16 章 highcharter 图形 The combination of some data and an aching desire for an answer does not ensure that a reasonable answer can be extracted from a given body of data. — John W. Tukey (???) 这才是真的动态图形，底层设计的图形语法已经与 ggplot2 大不相同，和用户交互是核心的部分 rgl 只是一种展现形式，它是基于 OpenGL，不拘泥于显示设备， plotly 包 (???) 和 highcharter 是基于网页的 表 16.1: JavaScript 生态系统 Package Title apexcharter Create Interactive Chart with the JavaScript ApexCharts Library billboarder Create Interactive Chart with the JavaScript Billboard Library BioCircos Interactive Circular Visualization of Genomic Data using htmlwidgets and BioCircos.js c3 C3.js Chart Library chromoMap Interactive Visualization and Mapping of Chromosomes collapsibleTree Interactive Collapsible Tree Diagrams using D3.js cubeview View 3D Raster Cubes Interactively d3heatmap Interactive Heat Maps Using htmlwidgets and D3.js D3partitionR Interactive Charts of Nested and Hierarchical Data with D3.js d3Tree Create Interactive Collapsible Trees with the JavaScript D3 Library datadigest Create an Interactive Data Summary datamaps Create Interactive Web Maps with the JavaScript Datamaps Library diffr Display Differences Between Two Files using Codediff Library dragulaR Drag and Drop Elements in Shiny using Dragula Javascript Library DT A Wrapper of the JavaScript Library DataTables dygraphs Interface to Dygraphs Interactive Time Series Charting Library echarts4r Create Interactive Graphs with Echarts JavaScript Version 4 excelR A Wrapper of the JavaScript Library jExcel focusedMDS Focused, Interactive Multidimensional Scaling g3viz Interactively Visualize Genetic Mutation Data using a Lollipop-Diagram ggiraph Make ggplot2 Graphics Interactive gradientPickerD3 Interactive Color Gradient Picker Using htmlwidgets and the Modified JS Script jquery-gradient-picker heatmaply Interactive Cluster Heat Maps Using plotly highcharter A Wrapper for the Highcharts Library iheatmapr Interactive, Complex Heatmaps imageviewer Simple htmlwidgets Image Viewer with WebGL Brightness/Contrast jsTree Create Interactive Trees with the jQuery jsTree Plugin leaflet Create Interactive Web Maps with the JavaScript Leaflet Library learnr Interactive Tutorials for R listviewer htmlwidget for Interactive Views of R Lists manipulateWidget Add Even More Interactivity to Interactive Charts mapdeck Interactive Maps Using Mapbox GL JS and Deck.gl mapedit Interactive Editing of Spatial Data in R mapview Interactive Viewing of Spatial Data in R metricsgraphics Create Interactive Charts with the JavaScript MetricsGraphics Library networkD3 D3 JavaScript Network Graphs from R parcats Interactive Parallel Categories Diagrams for easyalluvial parcoords Htmlwidget for d3.js Parallel Coordinates Chart phylocanvas Interactive Phylogenetic Trees Using the Phylocanvas JavaScript Library plainview Plot Raster Images Interactively on a Plain HTML Canvas plotly Create Interactive Web Graphics via plotly.js profvis Interactive Visualizations for Profiling R Code QRAGadget A Shiny Gadget for Interactive QRA Visualizations qrage Tools that Create D3 JavaScript Force Directed Graph from R qtlcharts Interactive Graphics for QTL Experiments radarchart Radar Chart from Chart.js RagGrid A Wrapper of the JavaScript Library agGrid rAmCharts JavaScript Charts Tool reactable Interactive Data Tables Based on React Table rhandsontable Interface to the Handsontable.js Library safetyGraphics Create Interactive Graphics Related to Clinical Trial Safety scatterD3 D3 JavaScript Scatterplot from R shinyTree jsTree Bindings for Shiny sigmajs Interface to Sigma.js Graph Visualization Library sigmaNet Render Graphs Using Sigma.js slickR Create Interactive Carousels with the JavaScript Slick Library threejs Interactive 3D Scatter Plots, Networks and Globes timevis Create Interactive Timeline Visualizations in R trelliscopejs Create Interactive Trelliscope Displays visNetwork Network Visualization using vis.js Library 下面以 highcharter 包为例介绍动态图形， 不推荐使用 highcharter 包提供的 hchart() 接口，这个接口函数走的路线和 ggplot2 包内的 qplot() 函数一致，用它就好像在拄着拐杖走路，很别扭！ highchart() hc 对象 hc_* 系列函数分类整理出 R 包结构，归纳出学习路径 hc_color() 配色 hc_xAxis() X 轴 hc_yAxis() Y 轴 hc_title() 标题 hc_subtitle() 副标题 hc_legend() 图例 hc_add_series() 添加序列 hc_rm_series() 移除序列 hc_exporting() 导出图形 hc_credits() 添加图形注释，比如数据来源，版权 以数据集 discoveries 为例介绍 highcharter 包的使用 library(highcharter) highchart() %&gt;% hc_xAxis(type = &quot;datetime&quot;) %&gt;% hc_title(text = &quot;Yearly Numbers of Important Discoveries&quot;, margin = 20, align = &quot;left&quot;, style = list(color = &quot;#51B749&quot;, useHTML = TRUE)) %&gt;% hc_add_series(data = discoveries, name = &quot;discoveries&quot;) %&gt;% hc_exporting(enabled = TRUE) 16.1 折线图 16.1.1 简单折线图 ggplot(data = BOD, aes(x = Time, y = demand)) + geom_point() + geom_line() + theme_minimal() hchart(BOD, &quot;line&quot;, hcaes(x = Time, y = demand)) 16.1.2 分组折线图 ggplot(data = Orange, aes(x = age, y = circumference, color = Tree)) + geom_point() + geom_line() + theme_minimal() hchart(Orange, &quot;line&quot;, hcaes(x = age, y = circumference, group = Tree)) # hchart(DNase, &quot;line&quot;, hcaes(x = conc, y = density, group = Run)) # hchart(Loblolly, &quot;line&quot;, hcaes(x = age, y = height, group = Seed)) 16.1.3 时间序列图 ggfortify 包 (???) 大大扩展了 ggplot2 包内置的函数 autoplot() 的功能，使得它可以适用多种数据对象的直接绘图 Base R 对时间序列类型 ts 的数据对象提供了泛型函数 plot.ts() 支持 plot(Nile, main = &quot;Flow of the River Nile&quot;) autoplot(Nile, xlab = &quot;Time&quot;, ylab = &quot;Nile&quot;, main = &quot;Flow of the River Nile&quot;) + theme_minimal() 图 16.1: 时序图 highchart() %&gt;% hc_xAxis(type = &quot;datetime&quot;) %&gt;% hc_add_series(data = Nile, name = &quot;Nile&quot;) 16.2 散点图 散点图，没有比散点图更能表达数据 16.2.1 简单散点图 hchart(faithful, &quot;scatter&quot;, hcaes(x = waiting, y = eruptions)) hchart(women, &quot;scatter&quot;, hcaes(x = weight, y = height)) 16.2.2 分组散点图 hchart(sleep, &quot;scatter&quot;, hcaes(x = ID, y = extra, group = group)) hchart(Puromycin, &quot;scatter&quot;, hcaes(x = conc, y = rate, group = state)) hchart(Orange, &quot;scatter&quot;, hcaes(x = age, y = circumference, group = Tree)) 16.3 条形图 本书中条形图和柱形图不再做区分，一般来讲，横着放叫条形图，否则就叫柱形图 16.3.1 简单条形图 严格来讲，条形图适合分类数据的展示 barplot( data = BOD, demand ~ Time, col = &quot;#4285F4&quot;, border = &quot;white&quot;, horiz = TRUE, xlim = c(0, 20) ) ggplot(data = BOD, aes(x = factor(Time), y = demand)) + geom_col(fill = &quot;#4285F4&quot;) + coord_flip() + theme_minimal() + labs(x = &quot;Time&quot;) 图 16.2: 条形图 # 条形图 hchart(BOD, &quot;bar&quot;, hcaes(x = factor(Time), y = demand)) # 柱形图 hchart(BOD, &quot;column&quot;, hcaes(x = factor(Time), y = demand), color = &quot;#4285F4&quot;) %&gt;% hc_xAxis(title = list(text = &quot;Time&quot;)) 16.3.2 复合条形图 longer_VADeaths &lt;- transform( expand.grid( sex = colnames(VADeaths), age = rownames(VADeaths) ), rates = as.vector(t(VADeaths)) ) hchart(longer_VADeaths, &quot;column&quot;, hcaes(x = sex, y = rates, group = age)) 16.3.3 堆积条形图 16.3.4 百分比条形图 16.4 箱线图 16.4.1 简单箱线图 with(ToothGrowth, { hcboxplot(x = len, var = supp) }) #&gt; Warning: `cols` is now required. #&gt; Please use `cols = c(data)` 16.4.2 复合箱线图 with(ToothGrowth, { hcboxplot(x = len, var = supp, var2 = dose, outliers = FALSE) %&gt;% hc_chart(type = &quot;column&quot;) # to put box vertical }) #&gt; Warning: `cols` is now required. #&gt; Please use `cols = c(data)` 16.5 密度图 hchart(density(diamonds$price), type = &quot;area&quot;, color = &quot;#B71C1C&quot;, name = &quot;Price&quot;) 16.6 直方图 hchart(diamonds$price, name = &quot;price&quot;) 16.7 生存图 library(survival) leukemia.surv &lt;- survfit(Surv(time, status) ~ x, data = aml) hchart(leukemia.surv, ranges = TRUE) 16.8 等高图 颜色等高图 hchart(volcano) %&gt;% hc_colorAxis(stops = color_stops(colors = hcl.colors(10))) 16.9 相关图 hchart(cor(swiss)) 16.10 矩阵图 library(&quot;treemap&quot;) data(GNI2014) treemap(GNI2014, index = c(&quot;continent&quot;, &quot;iso3&quot;), vSize = &quot;population&quot;, vColor = &quot;GNI&quot;, type = &quot;comp&quot;, palette = hcl.colors(6), draw = TRUE ) #&gt; Warning in if (class(try(col2rgb(palette), silent = TRUE)) == &quot;try-error&quot;) #&gt; stop(&quot;color palette is not correct&quot;): the condition has length &gt; 1 and only the #&gt; first element will be used tm &lt;- treemap(GNI2014, index = c(&quot;continent&quot;, &quot;iso3&quot;), vSize = &quot;population&quot;, vColor = &quot;GNI&quot;, type = &quot;comp&quot;, palette = hcl.colors(6), draw = FALSE ) #&gt; Warning in if (class(try(col2rgb(palette), silent = TRUE)) == &quot;try-error&quot;) #&gt; stop(&quot;color palette is not correct&quot;): the condition has length &gt; 1 and only the #&gt; first element will be used hctreemap(tm, allowDrillToNode = TRUE, layoutAlgorithm = &quot;squarified&quot;) %&gt;% hc_title(text = &quot;Gross National Income World Data&quot;) %&gt;% hc_tooltip(pointFormat = &quot;&lt;b&gt;{point.name}&lt;/b&gt;:&lt;br&gt; Pop: {point.value:,.0f}&lt;br&gt; GNI: {point.valuecolor:,.0f}&quot;) #&gt; Warning: &#39;hctreemap&#39; is deprecated. #&gt; Use &#39;hctreemap2&#39; instead. #&gt; See help(&quot;Deprecated&quot;) 考虑用 hctreemap2() 函数 hctreemap2(GNI2014, group_vars = c(&quot;continent&quot;, &quot;iso3&quot;), size_var = &quot;population&quot;, color_var = &quot;GNI&quot;, layoutAlgorithm = &quot;squarified&quot;) library(RColorBrewer) data.frame( index1 = sample(LETTERS[1:5], 500, replace = T), index2 = sample(LETTERS[6:10], 500, replace = T), index3 = sample(LETTERS[11:15], 500, replace = T), value = rpois(500, 5), color_value = rpois(500, 5) ) %&gt;% hctreemap2( group_vars = c(&quot;index1&quot;, &quot;index2&quot;, &quot;index3&quot;), size_var = &quot;value&quot;, color_var = &quot;color_value&quot;, layoutAlgorithm = &quot;squarified&quot;, levelIsConstant = FALSE, levels = list( list(level = 1, dataLabels = list(enabled = TRUE)), list(level = 2, dataLabels = list(enabled = FALSE)), list(level = 3, dataLabels = list(enabled = FALSE)) ) ) %&gt;% hc_colorAxis( minColor = brewer.pal(7, &quot;Greens&quot;)[1], maxColor = brewer.pal(7, &quot;Greens&quot;)[7] ) %&gt;% hc_tooltip(pointFormat = &quot;&lt;b&gt;{point.name}&lt;/b&gt;:&lt;br&gt; Value: {point.value:,.0f}&lt;br&gt; Color Value: {point.colorValue:,.0f}&quot;) "],
["dv-lattice.html", "第 17 章 Lattice 图形 17.1 箱线图 17.2 折线图 17.3 平滑图 17.4 点图 17.5 阶梯图 17.6 分面图 17.7 等高线图 17.8 地图 17.9 聚类图 17.10 运行环境", " 第 17 章 Lattice 图形 If you imagine that this pen is Trellis, then Lattice is not this pen. — Paul Murrell50 把网站搬出来，汉化 http://latticeextra.r-forge.r-project.org/ 17.1 箱线图 library(lattice) bwplot(voice.part ~ height, data = singer) 17.2 折线图 latticeExtra 包提供了强大的图层函数 layer() 多元时间序列 library(RColorBrewer) library(latticeExtra) xyplot(EuStockMarkets) + layer(panel.scaleArrow( x = 0.99, append = &quot; units&quot;, col = &quot;grey&quot;, srt = 90, cex = 0.8 )) 如何解释 时序图 Plot many time series in parallel horizonplot(EuStockMarkets, colorkey = TRUE, origin = 4000, horizonscale = 1000 ) + layer(panel.scaleArrow( x = 0.99, digits = 1, col = &quot;grey&quot;, srt = 90, cex = 0.7 )) + layer( lim &lt;- current.panel.limits(), panel.text(lim$x[1], lim$y[1], round(lim$y[1], 1), font = 2, cex = 0.7, adj = c(-0.5, -0.5), col = &quot;#9FC8DC&quot; ) ) # # https://stackoverflow.com/questions/25109196/r-lattice-package-add-legend-to-a-figure library(lattice) library(nlme) plot(Orange, outer = ~1, key = list( space = &quot;right&quot;, title = &quot;Tree&quot;, cex.title = 1, lines = list(lty = 1, col = hcl.colors(5)), # points = list(pch = 1, col = hcl.colors(5)), text = list(c(&quot;3&quot;, &quot;1&quot;, &quot;5&quot;, &quot;2&quot;, &quot;4&quot;)) ), par.settings = list( # plot.line = list(col = hcl.colors(5), border = &quot;transparent&quot;), # plot.symbol = list(col = hcl.colors(5), border = &quot;transparent&quot;), strip.background = list(col = &quot;white&quot;), strip.border = list(col = &quot;black&quot;) ) ) library(MASS) library(lattice) ## Plot the claims frequency against age group by engine size and district barchart(Claims / Holders ~ Age | Group, groups = District, data = Insurance, origin = 0, auto.key = TRUE ) barchart(Claims / Holders ~ Age | Group, groups = District, data = Insurance, main = &quot;Claims frequency&quot;, auto.key = list(space = &quot;top&quot;, columns = 4, title = &quot;District&quot;, cex.title = 1) ) # lattice 的设置 show.settings() myColours &lt;- brewer.pal(6, &quot;Blues&quot;) my.settings &lt;- list( superpose.polygon = list(col = myColours[2:5], border = &quot;transparent&quot;), strip.background = list(col = myColours[6]), strip.border = list(col = &quot;black&quot;) ) # 获取参数设置 trellis.par.get() # 全局参数设置 trellis.par.set(my.settings) library(MASS) library(lattice) myColours &lt;- hcl.colors(6) barchart(Claims / Holders * 100 ~ Age | Group, groups = District, data = Insurance, origin = 0, main = &quot;Motor insurance claims frequency&quot;, xlab = &quot;Age&quot;, ylab = &quot;Claims frequency %&quot;, scales = list(alternating = 1), auto.key = list( space = &quot;top&quot;, columns = 4, points = FALSE, rectangles = TRUE, title = &quot;District&quot;, cex.title = 1 ), par.settings = list( superpose.polygon = list(col = myColours[2:5], border = &quot;transparent&quot;), strip.background = list(col = myColours[6]), strip.border = list(col = &quot;black&quot;) ), par.strip.text = list(col = &quot;white&quot;, font = 2), panel = function(x, y, ...) { panel.grid(h = -1, v = 0) panel.barchart(x, y, ...) } ) 17.3 平滑图 set.seed(1) xy &lt;- data.frame( x = runif(100), y = rt(100, df = 5) ) xyplot(y ~ x, xy, panel = function(...) { panel.xyplot(...) panel.smoother(..., span = 0.9) }) library(splines) xyplot(y ~ x, xy) + layer(panel.smoother(y ~ ns(x, 5), method = &quot;lm&quot;)) library(nlme) library(mgcv) xyplot(y ~ x, xy) + layer(panel.smoother(y ~ s(x), method = &quot;gam&quot;)) Trellis Displays of Tukey’s Hanging Rootograms x &lt;- rpois(1000, lambda = 50) rootogram(~x, dfun = function(x) dpois(x, lambda = 50)) 17.4 点图 # 添加背景网格线作为参考线 segplot(reorder(factor(county), rate.male) ~ LCL95.male + UCL95.male, data = subset(USCancerRates, state == &quot;Washington&quot;), draw.bands = FALSE, centers = rate.male ) 17.5 阶梯图 经验累积分布图 ecdfplot(~height | voice.part, data = singer) 17.6 分面图 ## a variant of Figure 5.6 from Sarkar (2008) ## http://lmdvr.r-forge.r-project.org/figures/figures.html?chapter=05;figure=05_06 depth.ord &lt;- rev(order(quakes$depth)) quakes$Magnitude &lt;- equal.count(quakes$mag, 4) quakes.ordered &lt;- quakes[depth.ord, ] levelplot(depth ~ long + lat | Magnitude, data = quakes.ordered, panel = panel.levelplot.points, type = c(&quot;p&quot;, &quot;g&quot;), aspect = &quot;iso&quot;, prepanel = prepanel.default.xyplot) 17.7 等高线图 set.seed(1) xyz &lt;- data.frame(x = rnorm(100), y = rnorm(100)) xyz$z &lt;- with(xyz, x * y + rnorm(100, sd = 1)) ## GAM smoother with smoothness by cross validation library(mgcv) levelplot(z ~ x * y, xyz, panel = panel.2dsmoother, form = z ~ s(x, y), method = &quot;gam&quot; ) 17.8 地图 library(maps) library(mapproj) # 找一个新的 map 包含夏威夷和阿拉斯加 ## Note: Alaska, Hawaii and others are not included in county map; ## this generates warnings with both USCancerRates and ancestry. data(USCancerRates) mapplot(rownames(USCancerRates) ~ log(rate.male) + log(rate.female), data = USCancerRates, map = map(&quot;county&quot;, plot = FALSE, fill = TRUE, projection = &quot;mercator&quot;)) 17.9 聚类图 xyplot(Sepal.Length ~ Petal.Length, groups = Species, data = iris, scales = &quot;free&quot;, par.settings = list( superpose.symbol = list(pch = c(15:17)), superpose.line = list(lwd = 2, lty = 1:3) ), panel = function(x, y, ...) { panel.xyplot(x, y, ...) panel.ellipse(x, y, ...) }, auto.key = list(x = .1, y = .8, corner = c(0, 0)) ) 17.10 运行环境 sessionInfo() #&gt; R Under development (unstable) (2020-02-04 r77771) #&gt; Platform: x86_64-pc-linux-gnu (64-bit) #&gt; Running under: Ubuntu 16.04.6 LTS #&gt; #&gt; Matrix products: default #&gt; BLAS: /home/travis/R-bin/lib/R/lib/libRblas.so #&gt; LAPACK: /home/travis/R-bin/lib/R/lib/libRlapack.so #&gt; #&gt; locale: #&gt; [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C #&gt; [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 #&gt; [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 #&gt; [7] LC_PAPER=en_US.UTF-8 LC_NAME=C #&gt; [9] LC_ADDRESS=C LC_TELEPHONE=C #&gt; [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C #&gt; #&gt; attached base packages: #&gt; [1] splines stats graphics grDevices utils datasets methods #&gt; [8] base #&gt; #&gt; other attached packages: #&gt; [1] mapproj_1.2.7 maps_3.3.0 mgcv_1.8-31 #&gt; [4] MASS_7.3-51.5 nlme_3.1-143 latticeExtra_0.6-29 #&gt; [7] RColorBrewer_1.1-2 lattice_0.20-38 #&gt; #&gt; loaded via a namespace (and not attached): #&gt; [1] Rcpp_1.0.3 knitr_1.26 magrittr_1.5 jpeg_0.1-8.1 #&gt; [5] rlang_0.4.4 stringr_1.4.0 tools_4.0.0 grid_4.0.0 #&gt; [9] xfun_0.12 png_0.1-7 htmltools_0.4.0 yaml_2.2.1 #&gt; [13] digest_0.6.23 bookdown_0.17 Matrix_1.2-18 curl_4.3 #&gt; [17] evaluate_0.14 rmarkdown_2.1 stringi_1.4.5 compiler_4.0.0 Paul 在 DSC 2001 大会上的幻灯片 见https://www.stat.auckland.ac.nz/~paul/Talks/dsc2001.pdf↩︎ "],
["dv-network.html", "第 18 章 网络数据", " 第 18 章 网络数据 library(magrittr) library(ggplot2) options( ggplot2.continuous.colour = &quot;viridis&quot;, ggplot2.continuous.fill = &quot;viridis&quot; ) 介绍图的基本概念，出度、入度、有向图，邻接矩阵等，如何用 igraph 绘图表示 参考 Katherine Ognyanova 的博文网络分析和可视化与 R 语言、igraph 包的介绍51，Sam Tyner、 François Briatte 和 Heike Hofmann 总结了基于 ggplot2 的网络可视化工具包(???)，Bodong Chen 编写的教材 Applied Social Network Analysis in Education， François Briatte 介绍 ggnet2: network visualization with ggplot2 以及整理的 网络分析资源大列表。 igraph 提供了 R 和 Python 接口 https://github.com/igraph。 qgraph 开发者 Sacha Epskamp 在个人主页上提供了很多网络数据分析的学习资料， Rgraphviz 基于 Graphviz BiocManager::install(&quot;Rgraphviz&quot;, version = &quot;3.9&quot;) Gephi (???) 和 igraph 能处理的最大网络，R 包和作者依赖关系图 14000+ 包和 7000+ 作者，CRAN 是全球R包开发者之网，自发布 R 1.0.0 (February, 2000) 距今 19 年 案例学习 2017-Help Us Map TrumpWorld 2017-Trumpworld Analysis: Ownership Relations in his Business Network 2017-Social Network Analysis and Topic Modeling of codecentric’s Twitter friends and followers Using the iGraph package to Analyse the Enron Corpus Help Us Map TrumpWorld Enron Email Dataset Statnet Mining Twitter with R graphTweets Building Wordclouds in R | DataScience+ Introducing tidygraph Network analysis of Game of Thrones | DataScience+ Game of Thrones network analysis 权利的游戏 网络 Using R packages and education to scale Data Science at Airbnb RPubs - Twitter Coverage of the ISMB/ECCB Conference 2017 Gephi 中文教程 | Udemy UCI Network Data Repository library(DiagrammeR) svg &lt;- DiagrammeRsvg::export_svg( grViz(&quot; digraph neato { graph [layout = neato] node [shape = circle, style = filled, color = grey, label = &#39;&#39;] node [fillcolor = red] yihui_pkgs$Package node [fillcolor = green] unique(unlist(ctb)) node [fillcolor = orange] edge [color = grey] yihui_pkgs$Package[1] -&gt; ctb[[1]] yihui_pkgs$Package[2] -&gt; ctb[[2]] yihui_pkgs$Package[3] -&gt; ctb[[3]] yihui_pkgs$Package[4] -&gt; ctb[[4]] }&quot;) ) # this can then be used with htmltools and can save significantly # on size of output using svg rather than unrendered grViz library(htmltools) HTML(svg) # 将输出结果保存在svg格式矢量文件 即可 html_print(HTML(svg)) Network Analysis and Visualization with R and igraph https://kateto.net/networks-r-igraph with PDF↩︎ "],
["dv-spatio-temporal.html", "第 19 章 时空可视化 19.1 地图 19.2 空间数据对象", " 第 19 章 时空可视化 library(ggplot2) library(magrittr) options( ggplot2.continuous.colour = &quot;viridis&quot;, ggplot2.continuous.fill = &quot;viridis&quot; ) Robert J. Hijmans52 开发了 raster 包用于网格空间数据的读、写、操作、分析和建模，同时维护了空间数据分析的网站 https://www.rspatial.org Edzer Pebesma53 和 Roger Bivand 等创建了 sp 包定义了空间数据类型和方法，提供了大量的空间数据操作方法，同时维护了空间数据对象 sp 的绘图网站 https://edzer.github.io/sp/，他们也一起合作写了新书 Spatial Data Science，提供了在线 网页版 书籍及其 源代码 Edzer Pebesma 后来开发了 sf 包重新定义了空间数据对象和操作方法，并维护了空间数据分析、建模和可视化网站 https://www.r-spatial.org/ 课程案例学习 2018-Introduction to Geospatial Raster and Vector Data with R 空间数据分析课程 Peter Ellis 新西兰大选和普查数据 More cartograms of New Zealand census data: district and city level 2017-Mapping oil production by country in R 石油产量在全球的分布 2017-How to highlight countries on a map 高亮地图上的国家 2017-Mapping With Sf: Part 3 Data Visualization Shiny Apps 数据可视化核密度估计 In this app I identify crime hotspots using a bivariate density estimation strategy Association of Statisticians of American Religious Bodies (ASARB) viridis USA map 出租车行车轨迹数据 Geospatial processing with Clickhouse-CARTO Blog 19.1 地图 我们先来看看中国及其周边，这个地图的缺陷就是中国南海及九段线没有标记，台湾和中国大陆不是一种颜色标记，地图数据来自 R 包的 maps 和 mapdata library(maps) library(mapdata) east_asia &lt;- map_data(&quot;worldHires&quot;, region = c( &quot;Japan&quot;, &quot;Taiwan&quot;, &quot;China&quot;, &quot;North Korea&quot;, &quot;South Korea&quot; ) ) ggplot(east_asia, aes(x = long, y = lat, group = group, fill = region)) + geom_polygon(colour = &quot;black&quot;) + scale_fill_brewer(palette = &quot;Set2&quot;) 19.1.1 投影和观察方位 世界地图引发的 https://d.cosx.org/d/420808 worldmap &lt;- map_data(&quot;world&quot;) ggplot(worldmap, aes(long, lat, group = group)) + geom_polygon() + coord_map( xlim = c(-120, 40), ylim = c(30, 90), orientation = c(90, 0, 0) ) # 默认mercator投影下的默认视角 c(90, 0, mean(range(x))) ggplot(worldmap, aes(long, lat, group = group)) + geom_polygon(aes(fill = region), show.legend = FALSE) + coord_map( xlim = c(-120, 40), ylim = c(30, 90) ) # 相当于 (-120 + 40)/2 = -40 ggplot(worldmap, aes(long, lat, group = group)) + geom_polygon(aes(fill = region), show.legend = FALSE) + coord_map( xlim = c(-120, 40), ylim = c(30, 90), orientation = c(90, 0, -40) ) # 从西经 120 度到东经 40度 不同的看待 range(x) ggplot(worldmap, aes(long, lat, group = group)) + geom_polygon(aes(fill = region), show.legend = FALSE) + coord_map( xlim = c(-120, 40), ylim = c(30, 90), orientation = c(90, 0, -20) ) # 换观察角度 ggplot(worldmap, aes(long, lat, group = group)) + geom_polygon(aes(fill = region), show.legend = FALSE) + coord_map( xlim = c(-120, 40), ylim = c(30, 90), orientation = c(90, 0, 0) ) # 换投影坐标系 ggplot(worldmap, aes(long, lat, group = group)) + geom_polygon(aes(fill = region), show.legend = FALSE) + coord_map(&quot;ortho&quot;, xlim = c(-120, 40), ylim = c(30, 90) ) # 二者皆换 ggplot(worldmap, aes(long, lat, group = group)) + geom_polygon(aes(fill = region), show.legend = FALSE) + coord_map(&quot;ortho&quot;, xlim = c(-120, 40), ylim = c(30, 90), orientation = c(90, 0, 0) ) 19.1.2 美国各州犯罪率 美国各州的犯罪率数据 USArrests 准备数据集 crimes &lt;- data.frame(state = tolower(rownames(USArrests)), USArrests) crimesm &lt;- reshape2::melt(crimes, id = 1) head(crimesm) #&gt; state variable value #&gt; 1 alabama Murder 13.2 #&gt; 2 alaska Murder 10.0 #&gt; 3 arizona Murder 8.1 #&gt; 4 arkansas Murder 8.8 #&gt; 5 california Murder 9.0 #&gt; 6 colorado Murder 7.9 添加地图数据 library(maps) states_map &lt;- map_data(&quot;state&quot;) head(states_map) #&gt; long lat group order region subregion #&gt; 1 -87.46201 30.38968 1 1 alabama &lt;NA&gt; #&gt; 2 -87.48493 30.37249 1 2 alabama &lt;NA&gt; #&gt; 3 -87.52503 30.37249 1 3 alabama &lt;NA&gt; #&gt; 4 -87.53076 30.33239 1 4 alabama &lt;NA&gt; #&gt; 5 -87.57087 30.32665 1 5 alabama &lt;NA&gt; #&gt; 6 -87.58806 30.32665 1 6 alabama &lt;NA&gt; 绘图 ggplot(crimes, aes(map_id = state)) + geom_map(aes(fill = Murder), map = states_map) + expand_limits(x = states_map$long, y = states_map$lat) + coord_map() 图 11.6: 1973年美国各州的犯罪率数据 ggplot(crimesm, aes(map_id = state)) + geom_map(aes(fill = value), map = states_map) + expand_limits(x = states_map$long, y = states_map$lat) + facet_wrap(~variable) 图 14.3: 四类犯罪在各州的分布 19.1.3 斐济地震带 比较 viridis 和 Spectral 两块调色板，如图 19.1 所示，可见 Spectral 的可识别性高些 dat &lt;- as.data.frame(cbind(rep(1948 + seq(12), each = 12), rep(seq(12), 12), AirPassengers)) colnames(dat) &lt;- c(&quot;year&quot;, &quot;month&quot;, &quot;passengers&quot;) ggplot(data = dat, aes(as.factor(year), as.factor(month))) + geom_point(aes(colour = passengers), pch = 15, size = 8) + scale_colour_distiller(palette = &quot;Spectral&quot;) + labs(x = &quot;Year&quot;, y = &quot;Month&quot;) + theme_minimal() 图 19.1: viridis 和 Spectral对比 再举栗子，图19.2是正负例对比，其中好在哪里呢？这张图要表达美国黄石国家公园的老忠实泉间歇喷发的时间规律，那么好的标准就是层次分明，以突出不同颜色之间的时间差异。这个差异，还要看起来不那么费眼睛，越一目了然越好。 library(gridExtra) erupt &lt;- ggplot(faithfuld, aes(waiting, eruptions, fill = density)) + geom_raster() + scale_x_continuous(NULL, expand = c(0, 0)) + scale_y_continuous(NULL, expand = c(0, 0)) + theme(legend.position = &quot;none&quot;) erupt1 &lt;- erupt + scale_fill_gradientn(colours = gray.colors(7)) erupt2 &lt;- erupt + scale_fill_distiller(palette = &quot;Spectral&quot;) erupt3 &lt;- erupt + scale_fill_gradientn(colours = terrain.colors(7)) erupt4 &lt;- erupt grid.arrange(erupt1, erupt2, erupt3, erupt4, ncol = 2) 图 19.2: 美国黄石国家公园的老忠实泉 此处调用 RColorBrewer 中 Spectral 调色板，它本来只有11中颜色，通过 scale_colour_distiller 却可以把它映射到连续型数值变量 mag 上，发散型调色板本身的对比性也可以起到很好的区分度，如图 19.3 所示 FijiMap &lt;- map_data(&quot;worldHires&quot;, region = &quot;Fiji&quot;) ggplot(FijiMap, aes(x = long, y = lat)) + geom_map(map = FijiMap, aes(map_id = region), size = .2) + geom_point(data = quakes, aes(x = long, y = lat, colour = mag), pch = 16) + xlim(160, 195) + scale_colour_distiller(palette = &quot;Spectral&quot;) + scale_y_continuous(breaks = (-18:18) * 5) + coord_map(&quot;ortho&quot;, orientation = c(-10, 180, 0)) + labs(colour = &quot;Magnitude&quot;, x = &quot;Longitude&quot;, y = &quot;Latitude&quot;) + theme_minimal() 图 19.3: 斐济地震带 此外， colormap 包提供更加丰富的调色板，通过 scale_color_colormap 支持 ggplot2 绘图风格 19.1.4 美国各城镇失业率 # 数据来源 http://datasets.flowingdata.com/unemployment09.csv unemp &lt;- read.csv( file = &quot;http://datasets.flowingdata.com/unemployment09.csv&quot;, header = FALSE, stringsAsFactors = FALSE ) names(unemp) &lt;- c( &quot;id&quot;, &quot;state_fips&quot;, &quot;county_fips&quot;, &quot;name&quot;, &quot;year&quot;, &quot;?&quot;, &quot;?&quot;, &quot;?&quot;, &quot;rate&quot; ) unemp$county &lt;- tolower(gsub(&quot; County, [A-Z]{2}&quot;, &quot;&quot;, unemp$name)) unemp$state &lt;- gsub(&quot;^.*([A-Z]{2}).*$&quot;, &quot;\\\\1&quot;, unemp$name) county_df &lt;- map_data(&quot;county&quot;) names(county_df) &lt;- c(&quot;long&quot;, &quot;lat&quot;, &quot;group&quot;, &quot;order&quot;, &quot;state_name&quot;, &quot;county&quot;) county_df$state &lt;- state.abb[match(county_df$state_name, tolower(state.name))] county_df$state_name &lt;- NULL state_df &lt;- map_data(&quot;state&quot;) # Combine together choropleth &lt;- merge(county_df, unemp, by = c(&quot;state&quot;, &quot;county&quot;)) choropleth &lt;- choropleth[order(choropleth$order), ] choropleth$rate_d &lt;- cut(choropleth$rate, breaks = c(seq(0, 10, by = 2), 35)) library(ggthemes) ggplot(choropleth, aes(long, lat, group = group)) + geom_polygon(aes(fill = rate_d), colour = alpha(&quot;white&quot;, 1 / 4), size = 0.2) + geom_polygon(data = state_df, colour = &quot;white&quot;, fill = NA) + scale_fill_brewer(palette = &quot;PuRd&quot;) + labs( fill = &quot;ratio&quot;, title = &quot;ratio of unemployment by county, 2009&quot;, caption = &quot;data source: http://datasets.flowingdata.com/unemployment09.csv&quot; ) + coord_map(&quot;polyconic&quot;) + theme_map() 图 19.4: 2009年美国各城镇失业率 美国各地区失业率地图，配不同颜色， colormap 适合给静态图配色 19.2 空间数据对象 19.2.1 sp 空间数据对象，以类 sp 方式存储 (Pebesma and Bivand 2005) library(sp) crs = CRS(&quot;+init=epsg:28992&quot;) data(&quot;meuse&quot;) coordinates(meuse) &lt;- ~x+y proj4string(meuse) &lt;- crs class(meuse) #&gt; [1] &quot;SpatialPointsDataFrame&quot; #&gt; attr(,&quot;package&quot;) #&gt; [1] &quot;sp&quot; proj4string(meuse) #&gt; [1] &quot;+init=epsg:28992 +proj=sterea +lat_0=52.15616055555555 +lon_0=5.38763888888889 +k=0.9999079 +x_0=155000 +y_0=463000 +ellps=bessel +towgs84=565.4171,50.3319,465.5524,-0.398957388243134,0.343987817378283,-1.87740163998045,4.0725 +units=m +no_defs&quot; plot(meuse, axes = TRUE) 图 19.5: sp 对象 library(rgdal) #&gt; rgdal: version: 1.4-8, (SVN revision 845) #&gt; Geospatial Data Abstraction Library extensions to R successfully loaded #&gt; Loaded GDAL runtime: GDAL 2.2.2, released 2017/09/15 #&gt; Path to GDAL shared files: /usr/share/gdal/2.2 #&gt; GDAL binary built with GEOS: TRUE #&gt; Loaded PROJ.4 runtime: Rel. 4.9.2, 08 September 2015, [PJ_VERSION: 492] #&gt; Path to PROJ.4 shared files: (autodetected) #&gt; Linking to sp version: 1.3-2 crs.longlat &lt;- CRS(&quot;+init=epsg:4326&quot;) meuse.longlat &lt;- spTransform(meuse, crs.longlat) plot(meuse.longlat, axes = TRUE) 图 19.6: sp 对象 library(maptools) #&gt; Checking rgeos availability: FALSE #&gt; Note: when rgeos is not available, polygon geometry computations in maptools depend on gpclib, #&gt; which has a restricted licence. It is disabled by default; #&gt; to enable gpclib, type gpclibPermit() fname &lt;- system.file(&quot;shapes/sids.shp&quot;, package = &quot;maptools&quot;) p4s &lt;- CRS(&quot;+proj=longlat +datum=NAD27&quot;) nc &lt;- readShapePoly(fname, proj4string = p4s) #&gt; Warning: readShapePoly is deprecated; use rgdal::readOGR or sf::st_read plot(nc, axes = TRUE, col = grey(1 - nc$SID79 / 57)) # Trellis maps arrow &lt;- list(&quot;SpatialPolygonsRescale&quot;, layout.north.arrow(2), offset = c(-76, 34), scale = 0.5, which = 2 ) spplot(nc, c(&quot;SID74&quot;, &quot;SID79&quot;), as.table = TRUE, scales = list(draw = T), sp.layout = arrow ) maptools 提供的 readShapePoly 函数去读取 shp 文件的方式已经过时，推荐使用 rgdal::readOGR 或者 sf::st_read 方式读取 19.2.2 raster raster 包定义了获取和操作空间 raster 类型数据集的类和方法，rasterVis 补充加强了 raster 包在数据可视化和交互方面的功能。可视化是基于 lattice 的 raster 包的开发已经被作者 Robert J. Hijmans 迁移到 Github 上啦，官方文档 https://www.rspatial.org/ 星号 * 标记的是 S3 方法 methods(plot) #&gt; [1] plot,ANY,ANY-method #&gt; [2] plot,color,ANY-method #&gt; [3] plot,Spatial,missing-method #&gt; [4] plot,SpatialGrid,missing-method #&gt; [5] plot,SpatialGridDataFrame,missing-method #&gt; [6] plot,SpatialLines,missing-method #&gt; [7] plot,SpatialMultiPoints,missing-method #&gt; [8] plot,SpatialPixels,missing-method #&gt; [9] plot,SpatialPixelsDataFrame,missing-method #&gt; [10] plot,SpatialPoints,missing-method #&gt; [11] plot,SpatialPolygons,missing-method #&gt; [12] plot.acf* #&gt; [13] plot.data.frame* #&gt; [14] plot.decomposed.ts* #&gt; [15] plot.default #&gt; [16] plot.dendrogram* #&gt; [17] plot.density* #&gt; [18] plot.ecdf #&gt; [19] plot.factor* #&gt; [20] plot.formula* #&gt; [21] plot.function #&gt; [22] plot.ggplot* #&gt; [23] plot.gtable* #&gt; [24] plot.hcl_palettes* #&gt; [25] plot.hclust* #&gt; [26] plot.histogram* #&gt; [27] plot.HoltWinters* #&gt; [28] plot.isoreg* #&gt; [29] plot.lm* #&gt; [30] plot.medpolish* #&gt; [31] plot.mlm* #&gt; [32] plot.ppr* #&gt; [33] plot.prcomp* #&gt; [34] plot.princomp* #&gt; [35] plot.profile.nls* #&gt; [36] plot.R6* #&gt; [37] plot.raster* #&gt; [38] plot.shingle* #&gt; [39] plot.spec* #&gt; [40] plot.stepfun #&gt; [41] plot.stl* #&gt; [42] plot.table* #&gt; [43] plot.trans* #&gt; [44] plot.trellis* #&gt; [45] plot.ts #&gt; [46] plot.tskernel* #&gt; [47] plot.TukeyHSD* #&gt; see &#39;?methods&#39; for accessing help and source code 查看函数的定义 getAnywhere(plot.raster) #&gt; A single object matching &#39;plot.raster&#39; was found #&gt; It was found in the following places #&gt; registered S3 method for plot from namespace graphics #&gt; namespace:graphics #&gt; with value #&gt; #&gt; function (x, y, xlim = c(0, ncol(x)), ylim = c(0, nrow(x)), xaxs = &quot;i&quot;, #&gt; yaxs = &quot;i&quot;, asp = 1, add = FALSE, ...) #&gt; { #&gt; if (!add) { #&gt; plot.new() #&gt; plot.window(xlim = xlim, ylim = ylim, asp = asp, xaxs = xaxs, #&gt; yaxs = yaxs) #&gt; } #&gt; rasterImage(x, 0, 0, ncol(x), nrow(x), ...) #&gt; } #&gt; &lt;bytecode: 0x74621e0&gt; #&gt; &lt;environment: namespace:graphics&gt; rasterImage 函数来绘制图像，如果想知道 rasterImage 的内容可以继续看 getAnywhere(rasterImage) getAnywhere(rasterImage) #&gt; A single object matching &#39;rasterImage&#39; was found #&gt; It was found in the following places #&gt; package:graphics #&gt; namespace:graphics #&gt; with value #&gt; #&gt; function (image, xleft, ybottom, xright, ytop, angle = 0, interpolate = TRUE, #&gt; ...) #&gt; { #&gt; .External.graphics(C_raster, if (inherits(image, &quot;nativeRaster&quot;)) image else as.raster(image), #&gt; as.double(xleft), as.double(ybottom), as.double(xright), #&gt; as.double(ytop), as.double(angle), as.logical(interpolate), #&gt; ...) #&gt; invisible() #&gt; } #&gt; &lt;bytecode: 0x61b8ba0&gt; #&gt; &lt;environment: namespace:graphics&gt; 通过查看函数的帮助 ?rasterImage ，我们需要重点关注一下 参数 image 传递的 raster 对象 plot(c(100, 250), c(300, 450), type = &quot;n&quot;, xlab = &quot;&quot;, ylab = &quot;&quot;) image &lt;- as.raster(matrix(0:1, ncol = 5, nrow = 3)) rasterImage(image, 100, 300, 150, 350, interpolate = FALSE) rasterImage(image, 100, 400, 150, 450) rasterImage(image, 200, 300, 200 + xinch(.5), 300 + yinch(.3), interpolate = FALSE ) rasterImage(image, 200, 400, 250, 450, angle = 15, interpolate = FALSE) 图 11.14: raster 图像 library(raster) #&gt; #&gt; Attaching package: &#39;raster&#39; #&gt; The following object is masked from &#39;package:magrittr&#39;: #&gt; #&gt; extract meuse.test &lt;- raster(x = system.file(&quot;external/test.grd&quot;, package=&quot;raster&quot;)) class(meuse.test) #&gt; [1] &quot;RasterLayer&quot; #&gt; attr(,&quot;package&quot;) #&gt; [1] &quot;raster&quot; plot(meuse.test, legend = F) 图 11.17: raster 对象 Edzer Pebesma 开发了 stars 包 # https://resources.rstudio.com/rstudio-conf-2019/spatial-data-science-in-the-tidyverse library(abind) library(sf) #&gt; Linking to GEOS 3.7.1, GDAL 2.2.2, PROJ 4.9.2 library(stars) x &lt;- system.file(&quot;tif/L7_ETMs.tif&quot;, package = &quot;stars&quot;) %&gt;% read_stars() ggplot() + geom_stars(data = x) + coord_equal() + facet_wrap(~band) + theme_void() + scale_fill_viridis_c() + scale_x_discrete(expand = c(0, 0)) + scale_y_discrete(expand = c(0, 0)) 19.2.3 sf nc &lt;- system.file(&quot;gpkg/nc.gpkg&quot;, package = &quot;sf&quot;) %&gt;% read_sf() nc2 &lt;- nc %&gt;% dplyr::select(SID74, SID79) %&gt;% tidyr::gather(VAR, SID, -geom) ggplot() + geom_sf(data = nc2, aes(fill = SID)) + facet_wrap(~VAR, ncol = 1) 参考文献 "],
["dynamic-documents.html", "第 20 章 动态性文档 R 调用 Python 20.1 Markdown 20.2 Pandoc’s Markdown 20.3 R Markdown 20.4 表格样式 20.5 插件 20.6 报告 20.7 简历 20.8 书籍 20.9 网站 20.10 Shiny 20.11 幻灯片 20.12 动画视频 20.13 图表", " 第 20 章 动态性文档 import os print(os.listdir()) #&gt; [&#39;Dockerfile&#39;, &#39;interactives&#39;, &#39;data-table.utf8.md&#39;, &#39;includes&#39;, &#39;files.md&#39;, &#39;Adobe-Fonts.zip&#39;, &#39;dc-string-manipulation.Rmd&#39;, &#39;data-parallel.md&#39;, &#39;dv-ggplot2.utf8.md&#39;, &#39;dv-highcharter_cache&#39;, &#39;RGraphics.Rproj&#39;, &#39;_common.R&#39;, &#39;dc-string-manipulation.utf8.md&#39;, &#39;dv-ggplot2.Rmd&#39;, &#39;requirements.txt&#39;, &#39;data-tibble.Rmd&#39;, &#39;dc-regular-expressions_cache&#39;, &#39;odbc.ini&#39;, &#39;dv-colors-fonts.Rmd&#39;, &#39;data-import.md&#39;, &#39;setup.Rmd&#39;, &#39;dv-plot.Rmd&#39;, &#39;dv-plotly.utf8.md&#39;, &#39;data-objects.utf8.md&#39;, &#39;preface_cache&#39;, &#39;data-parallel.utf8.md&#39;, &#39;dc-stringr.Rmd&#39;, &#39;dv-highcharter.md&#39;, &#39;.Rprofile&#39;, &#39;dv-plotly_cache&#39;, &#39;interactive-graphics.Rmd&#39;, &#39;index_cache&#39;, &#39;_bookdown_files&#39;, &#39;README.md&#39;, &#39;dv-plot_files&#39;, &#39;dv-plot3d.utf8.md&#39;, &#39;_bookdown.yml&#39;, &#39;preface.md&#39;, &#39;dv-spatio-temporal.utf8.md&#39;, &#39;data-frame.utf8.md&#39;, &#39;data-frame_cache&#39;, &#39;cs-cran-network_files&#39;, &#39;files.utf8.md&#39;, &#39;dv-highcharter.Rmd&#39;, &#39;99-references.Rmd&#39;, &#39;sidebar.lua&#39;, &#39;Makefile&#39;, &#39;docker-compose.yml&#39;, &#39;dc-regular-expressions.utf8.md&#39;, &#39;figures&#39;, &#39;_book&#39;, &#39;refer.bib&#39;, &#39;dv-highcharter_files&#39;, &#39;data&#39;, &#39;DESCRIPTION&#39;, &#39;dc-regular-expressions.Rmd&#39;, &#39;dv-plot3d_cache&#39;, &#39;dv-ggplot2_cache&#39;, &#39;cs-cran-network.Rmd&#39;, &#39;dv-highcharter.utf8.md&#39;, &#39;data-frame.Rmd&#39;, &#39;dc-regular-expressions.md&#39;, &#39;index.utf8.md&#39;, &#39;.gitignore&#39;, &#39;style.css&#39;, &#39;files_cache&#39;, &#39;_render.R&#39;, &#39;ubuntu&#39;, &#39;data-import_cache&#39;, &#39;dv-lattice.md&#39;, &#39;data-parallel.Rmd&#39;, &#39;files.Rmd&#39;, &#39;render4acf47b1331b.rds&#39;, &#39;index.Rmd&#39;, &#39;dv-plot3d.md&#39;, &#39;_build.sh&#39;, &#39;dv-lattice_files&#39;, &#39;setup.utf8.md&#39;, &#39;data-objects.Rmd&#39;, &#39;setup.md&#39;, &#39;index.md&#39;, &#39;dv-lattice_cache&#39;, &#39;dynamic-documents.Rmd&#39;, &#39;data-import.Rmd&#39;, &#39;dynamic-documents_files&#39;, &#39;data-tibble.utf8.md&#39;, &#39;bookdown4acf719ebdfd.bak&#39;, &#39;dv-plot3d-tikzDictionary&#39;, &#39;dv-spatio-temporal.md&#39;, &#39;data-table.Rmd&#39;, &#39;dv-plot.md&#39;, &#39;animated-graphics.Rmd&#39;, &#39;dv-plotly.md&#39;, &#39;.travis.yml&#39;, &#39;.git&#39;, &#39;data-objects.md&#39;, &#39;data-tibble_cache&#39;, &#39;_main.rds&#39;, &#39;dv-plot3d_files&#39;, &#39;dv-colors-fonts.utf8.md&#39;, &#39;dv-ggplot2_files&#39;, &#39;data-frame.md&#39;, &#39;dv-colors-fonts.md&#39;, &#39;preface.Rmd&#39;, &#39;dv-plot3d.Rmd&#39;, &#39;LICENSE&#39;, &#39;data-objects_cache&#39;, &#39;dv-lattice.Rmd&#39;, &#39;data-frame_files&#39;, &#39;dv-network.md&#39;, &#39;dv-network.utf8.md&#39;, &#39;preface.utf8.md&#39;, &#39;data-tibble.md&#39;, &#39;demos&#39;, &#39;data-import.utf8.md&#39;, &#39;dv-spatio-temporal.Rmd&#39;, &#39;data-table.md&#39;, &#39;dv-plotly.Rmd&#39;, &#39;dv-ggplot2.md&#39;, &#39;cumcm2011A.RDS&#39;, &#39;dc-string-manipulation.md&#39;, &#39;dv-lattice.utf8.md&#39;, &#39;preamble.tex&#39;, &#39;dv-network.Rmd&#39;, &#39;maintainer_author.rds&#39;, &#39;dc-string-manipulation_cache&#39;, &#39;dv-colors-fonts_files&#39;, &#39;data-table_cache&#39;, &#39;dv-colors-fonts_cache&#39;, &#39;_deploy.sh&#39;, &#39;dv-plot_cache&#39;, &#39;_output.yml&#39;, &#39;dv-plot.utf8.md&#39;, &#39;animated-graphics_files&#39;, &#39;dynamic-documents_cache&#39;, &#39;dv-spatio-temporal_files&#39;] R Markdown 文档(Xie, Allaire, and Grolemund 2018) 中的 Python 代码块是由 knitr 包 (Xie 2015) 负责调度处理的，展示 Matplotlib 绘图的结果使用了 reticulate 包 (???) 提供的 Python 引擎而不是 knitr 自带的。 LaTeX 专家黄晨成写的译文 Matplotlib 教程 周沫凡 制作的莫烦 Python 系列视频教程之 Matplotlib 数据可视化神器 陈治兵维护的在线 Matplotlib 中文文档 编译书籍使用的 Python 3 模块有 pip3 list --format=columns Package Version absl-py 0.9.0 astor 0.8.1 cachetools 4.0.0 certifi 2019.11.28 chardet 3.0.4 cycler 0.10.0 gast 0.2.2 google-auth 1.11.0 google-auth-oauthlib 0.4.1 google-pasta 0.1.8 grpcio 1.27.0 h5py 2.10.0 idna 2.8 Keras-Applications 1.0.8 Keras-Preprocessing 1.1.0 kiwisolver 1.1.0 Markdown 3.1.1 matplotlib 3.0.3 numpy 1.16.4 oauthlib 3.1.0 opt-einsum 3.1.0 pandas 0.24.2 pip 20.0.2 protobuf 3.11.3 pyasn1 0.4.8 pyasn1-modules 0.2.8 pyparsing 2.4.6 python-dateutil 2.8.1 pytz 2019.3 requests 2.22.0 requests-oauthlib 1.3.0 rsa 4.0 scipy 1.3.0 setuptools 45.1.0 six 1.14.0 tensorboard 2.1.0 tensorflow 2.1.0 tensorflow-estimator 2.1.0 termcolor 1.1.0 urllib3 1.25.8 Werkzeug 0.16.1 wheel 0.34.2 wrapt 1.11.2 在 knitr::opts_chunk 中设置 python.reticulate = TRUE 意味着所有的 Python 代码块共享一个 Python Session，而 python.reticulate = FALSE 意味着使用 knitr 提供的 Python 引擎，所有的 Python 代码块独立运行。 python.reticulate = TRUE 会使用 reticulate 提供的 Python 引擎，它支持 matplotlib 绘图，但是不支持图 caption，knitr 的 python 引擎是支持 caption 的 R 和 Python 之间的交互，Python 负责数据处理和建模， R 负责绘图，有些复杂的机器学习模型及其相关数据操作需要在 Python 中完成，数据集清理至数据框的形式后导入到 R 中，画各种静态或者动态图，这时候需要加载 reticulate 包，只是设置 python.reticulate = TRUE 还不够 R 调用 Python pandas 读取数据，整理后由 reticulate 包传递给 R 环境中的 data.frame 对象，加载 ggplot2 绘图 import pandas as pd iris2 = pd.read_csv(&#39;iris.csv&#39;) library(reticulate) library(ggplot2) ggplot(py$iris2, aes(x = Sepal.Length, y = Sepal.Width)) + geom_point(aes(color = Species)) + scale_color_viridis_d() 图 20.1: 散点图 library(ggplot2) ggplot(faithfuld, aes(waiting, eruptions)) + geom_raster(aes(fill = density)) + scale_fill_continuous() 如图 ?? 所示 import matplotlib.pyplot as plt plt.switch_backend(&#39;agg&#39;) import numpy as np n = 1024 # data size X = np.random.normal(0, 1, n) Y = np.random.normal(0, 1, n) T = np.arctan2(Y,X) # for color value plt.scatter(X, Y, s=75, c=T, alpha=.5) plt.xlim(-1.5, 1.5) #&gt; (-1.5, 1.5) plt.ylim(-1.5, 1.5) #&gt; (-1.5, 1.5) plt.show() Pandoc 对 Markdown 语法的扩充 R Markdown 加持 可重复数据分析 Rmd dashboard 面板 Shiny 文档 写书 写博客 写幻灯片 shiny Mastering Shiny Shiny Server Professional Administrator’s Guide Learn Shiny rstudio::conf 2018 三剑客 Markdown &amp; Pandoc’s Markdown &amp; R Markdown Markdown for scientific writing 首先介绍 Markdown 在强调、标题、列表、断行、链接、图片、引用、代码块、LaTeX 公式等使用方式，然后在 Markdown 的基础上介绍 Pandoc’s Markdown 功能有加强的地方，R Markdown 在 Pandoc’s Markdown 的基础上介绍功能有加强的地方 20.1 Markdown Markdown 基础语法见 RStudio IDE 自带的 Markdown 手册：RStudio 顶部菜单栏 -&gt; Help -&gt; Markdown Quick Reference，这里主要介绍一下Markdown 高级语法，特别是 Pandoc’s Markdown，其实是 Pandoc 提供了很多对 Markdown 的扩展支持，下面介绍一下被 Pandoc 加强后的 Markdown 表格、图片和公式的使用 20.1.1 列表 有序的列表 第一条 第二条 无序的列表 第一条 第二条 here is my first list item. and my second. 嵌套的列表 有序 Item 2 Item 3 Item 3a Item 3b 无序 Item 2 Item 2a Item 2b 定义型列表中包含代码 Term 1 Definition 1 Term 2 with inline markup Definition 2 { some code, part of Definition 2 } Third paragraph of definition 2. 定义类型的列表，紧凑形式 Term 1 Definition 1 Term 2 Definition 2a Definition 2b 无序列表 fruits apples macintosh red delicious pears peaches vegetables broccoli chard 对应 LaTeX 列表环境里的有序环境，通篇计数 My first example will be numbered (1). My second example will be numbered (2). Explanation of examples. My third example will be numbered (3). (@) 环境可以引用 这是一个好例子 正如 (4) 所指出的那样， 列表里包含代码块 item one item two { my code block } 显示反引号 ` 20.1.2 强调 轻微强调 这是倾斜的文字 下划线表示强调, and this is 星花表示强调. 特别强调 这是加粗的文字 strong emphasis and with underscores. 强烈强调 这是斜体加粗的文字 三个星花 删除线 This is deleted text. 上下标 H2O is a liquid. 210 is 1024. C137 是一种放射性元素 20.1.3 引用 注意在引用末尾空两格，出处另起一行，引用名人名言: It’s always better to give than to receive. 或者 A Markdown-formatted document should be publishable as-is, as plain text, without looking like it’s been marked up with tags or formatting instructions. — John Gruber Trellis graphics are a bit like hash functions: you can be close to the target, but get a far-off result.54 — Dieter Menne If you imagine that this pen is Trellis, then Lattice is not this pen.55 — Paul Murrell You’re overlooking something like line 800 of the documentation for xyplot. […] It’s probably in the R-FAQ as well, since my original feeling was that this behaviour was chosen in order to confuse people and see how many people read the FAQ… :)56 — Barry Rowlingson 20.1.4 表格 插入表格很简单的，如表 20.1 所示，还带脚注哦，复杂的表格制作可以借助 R 包 knitr 提供的 kable 函数以及 kableExtra 包57，此外谢益辉的书籍 bookdown: Authoring Books and Technical Documents with R Markdown 中也有一节专门介绍表格 https://bookdown.org/yihui/bookdown/tables.html 表 20.1: 表格标题58 First Header Second Header Content Cell Content Cell Content Cell Content Cell kable 支持多个表格并排，如表 20.2 所示 knitr::kable( list( head(iris[, 1:2], 3), head(mtcars[, 1:3], 5) ), caption = &#39;A Tale of Two Tables.&#39;, booktabs = TRUE ) 表 20.2: A Tale of Two Tables. Sepal.Length Sepal.Width 5.1 3.5 4.9 3.0 4.7 3.2 mpg cyl disp Mazda RX4 21.0 6 160 Mazda RX4 Wag 21.0 6 160 Datsun 710 22.8 4 108 Hornet 4 Drive 21.4 6 258 Hornet Sportabout 18.7 8 360 在表格中引入数学符号 knitr::kable( rbind(c(&quot;&quot;, &quot;continuous&quot;, &quot;discrete&quot;), c(&quot;nominal&quot;, &quot;&quot;, &quot;$\\\\checkmark$&quot;), c(&quot;ordinal&quot;, &quot;&quot;, &quot;$\\\\checkmark$&quot;), c(&quot;interval&quot;, &quot;$\\\\checkmark$&quot;, &quot;$\\\\checkmark$&quot;), c(&quot;ratio&quot;, &quot;$\\\\checkmark$&quot;, &quot;$\\\\checkmark$&quot;) ) , caption = &#39;The relationship between the scales of measurement and the discrete/continuity distinction. Cells with a tick mark correspond to things that are possible.&#39;, align=&quot;lcc&quot;, booktabs = TRUE ) 表 20.3: The relationship between the scales of measurement and the discrete/continuity distinction. Cells with a tick mark correspond to things that are possible. continuous discrete nominal \\(\\checkmark\\) ordinal \\(\\checkmark\\) interval \\(\\checkmark\\) \\(\\checkmark\\) ratio \\(\\checkmark\\) \\(\\checkmark\\) kableExtra 、broom 和 pixiedust 包实现表格样式的精细调整，如黄湘云制作的 样例 20.1.5 图片 插入图片大体遵循的语法如下 ![...](...){...} 中括号包含图片的标题，小括号是图片插入路径，大括号控制图片属性 利用 knitr::include_graphics 函数在代码块中插入图片是很简单的，如图20.2所示，图、表的标题很长或者需要插入脚注，可以使用[文本引用][text-references] knitr::include_graphics(path = system.file(&quot;help/figures&quot;, &quot;mai.png&quot;, package = &quot;graphics&quot;)) 图 20.2: (ref:footnote) par(mar = c(4.1, 4.1, 0.5, 0.5)) plot(rnorm(10), xlab = &quot;&quot;, ylab = &quot;&quot;) 图 14.3: (ref:fig-cap) 插入一幅普通图片，如图 20.3 和图 20.4 所示分别控制图片插入的宽度[^css-position] ![(\\#fig:left-fig) 默认图片位置居左^[这里是脚注]](figures/mai.png){ width=45% } 图 20.3: 默认图片位置居左59 ![(\\#fig:full-fig) 一幅全宽的图片](figures/mai.png){.full} 图 20.4: 一幅全宽的图片 One Two 还可以在列表环境中插入图片 Three 根据代码动态生成图片，并插入文档中；外部图片插入文档中 plot(AirPassengers) 图 20.5: 时间序列图 plot(pressure) plot(AirPassengers) 图 20.6: 2行1列布局 plot(pressure) plot(AirPassengers) 图 20.7: 1行2列布局 plot(pressure) plot(AirPassengers) plot(pressure) plot(AirPassengers) 图 20.8: 2x2图布局 (ref:fig-cap) 测试文本引用 (ref:text-references) 图表标题很长可使用[文本引用][text-references] (ref:footnote) 表格标题里插入脚注，但是 ebooks 不支持这样插入脚注[^longnote] [^longnote]: Here’s one with multiple blocks. [text-references]: https://bookdown.org/yihui/bookdown/markdown-extensions-by-bookdown.html#text-references [^css-position]: 参考谢益辉的博客： CSS 的位置属性以及如何居中对齐超宽元素 https://yihui.name/cn/2018/05/css-position/ 20.1.6 公式 行内公式一对美元符号 \\(\\alpha\\) 或者 \\(\\alpha+\\beta\\)，行间公式 \\[\\alpha\\] 或者 \\[\\alpha + \\beta\\] 对公式编号，如公式 (20.1) \\[\\begin{equation} L(\\beta,\\boldsymbol{\\theta}) = f(y;\\beta,\\boldsymbol{\\theta}) = \\int_{\\mathbb{R}^{n}}N(t;D\\beta,\\Sigma(\\boldsymbol{\\theta}))f(y|t)dt \\tag{20.1} \\end{equation}\\] 多行公式分别编号，如公式(20.2) 和公式(20.3) \\[\\begin{align} \\log\\{\\frac{p_i}{1-p_i}\\} &amp; = T_{i} = d(x_i)&#39;\\beta + S(x_i) + Z_i \\tag{20.2}\\\\ \\log(\\lambda_i) &amp; = T_{i} = d(x_i)&#39;\\beta + S(x_i) + Z_i \\tag{20.3} \\end{align}\\] 多行公式中对某一（些）行编号，如公式 (20.4) 和 公式 (20.5) \\[\\begin{align} g(X_{n}) &amp;= g(\\theta)+g&#39;({\\tilde{\\theta}})(X_{n}-\\theta) \\\\ \\sqrt{n}[g(X_{n})-g(\\theta)] &amp;= g&#39;\\left({\\tilde{\\theta}}\\right) \\sqrt{n}[X_{n}-\\theta ] \\tag{20.4} \\\\ \\log(\\lambda_i) &amp; = T_{i} = d(x_i)&#39;\\beta + S(x_i) + Z_i \\tag{20.5} \\end{align}\\] 多行公式共用一个编号，如公式 (20.6) \\[\\begin{equation} \\begin{aligned} L(\\beta,\\boldsymbol{\\theta}) &amp; = \\int_{\\mathbb{R}^{n}} \\frac{N(t;D\\beta,\\Sigma(\\boldsymbol{\\theta}))f(y|t)}{N(t;D\\beta_{0},\\Sigma(\\boldsymbol{\\theta}_{0}))f(y|t)}f(y,t)dt\\\\ &amp; \\varpropto \\int_{\\mathbb{R}^{n}} \\frac{N(t;D\\beta,\\Sigma(\\boldsymbol{\\theta}))}{N(t;D\\beta_{0},\\Sigma(\\boldsymbol{\\theta}_{0}))}f(t|y)dt \\\\ &amp;= E_{T|y}\\left[\\frac{N(t;D\\beta,\\Sigma(\\boldsymbol{\\theta}))}{N(t;D\\beta_{0},\\Sigma(\\boldsymbol{\\theta}_{0}))}\\right] \\end{aligned} \\tag{20.6} \\end{equation}\\] 推荐在 equation 公式中，使用 split 环境，意思是一个公式很长，需要拆成多行，如公式(20.7) \\[\\begin{equation} \\begin{split} \\mathrm{Var}(\\hat{\\beta}) &amp; =\\mathrm{Var}((X&#39;X)^{-1}X&#39;y)\\\\ &amp; =(X&#39;X)^{-1}X&#39;\\mathrm{Var}(y)((X&#39;X)^{-1}X&#39;)&#39;\\\\ &amp; =(X&#39;X)^{-1}X&#39;\\mathrm{Var}(y)X(X&#39;X)^{-1}\\\\ &amp; =(X&#39;X)^{-1}X&#39;\\sigma^{2}IX(X&#39;X)^{-1}\\\\ &amp; =(X&#39;X)^{-1}\\sigma^{2} \\end{split} \\tag{20.7} \\end{equation}\\] 注意，\\mathbf 只对字母 \\(a,b,c,A,B,C\\) 加粗，mathjax 不支持公式中使用 \\bm 对 \\(\\theta,\\alpha,\\beta,\\ldots,\\gamma\\) 加粗，应该使用 \\boldsymbol 20.2 Pandoc’s Markdown 介绍在 Markdown 的基础上添加的功能 20.3 R Markdown R Markdown 站在巨人的肩膀上，这些巨人有 Markdown、 Pandoc 和 LaTeX 等。 生态系统 报告 learnr: Interactive Tutorials with R Markdown https://rstudio.github.com/learnr/ r2d3: R Interface to D3 Visualizations https://rstudio.github.io/r2d3/ radix: Radix combines the technical authoring features of Distill with R Markdown, enabling a fully reproducible workflow based on literate programming https://github.com/radixpub/radix-r 网络服务 RestRserve: RestRserve is a R web API framework for building high-performance microservices and app backends https://github.com/dselivanov/RestRserve 基于 Rserve 在笔记本上处理请求的吞吐量是每秒10000次，比 plumber 快大约20倍 plumber: Turn your R code into a web API. https://www.rplumber.io 展示 revealjs: R Markdown Format for reveal.js Presentations https://github.com/rstudio/revealjs xaringan: Presentation Ninja 幻灯忍者写轮眼 https://slides.yihui.name/xaringan/ 在指定目录创建 Book 项目， bookdown:::bookdown_skeleton(&quot;~/bookdown-demo&quot;) 项目根目录的文件列表 directory/ ├── index.Rmd ├── 01-intro.Rmd ├── 02-literature.Rmd ├── 03-method.Rmd ├── 04-application.Rmd ├── 05-summary.Rmd ├── 06-references.Rmd ├── _bookdown.yml ├── _output.yml ├── book.bib ├── preamble.tex ├── README.md └── style.css 20.3.1 语法高亮 Pandoc 通过 LaTeX 环境 lstlisting 支持语法高亮，比如 ```TeX \\begin{lstlisting} \\documentclass[cn]{elegantbook} \\documentclass[lang=cn]{elegantbook} \\end{lstlisting} \\begin{lstlisting}[frame=single] \\nocite{EINAV2010,Havrylchyk2018} %or include some bibitems \\nocite{*} %include all the bibitems \\end{lstlisting} ``` # knit 支持的编程语言及其语法高亮环境 names(knitr::knit_engines$get()) #&gt; [1] &quot;awk&quot; &quot;bash&quot; &quot;coffee&quot; &quot;gawk&quot; &quot;groovy&quot; #&gt; [6] &quot;haskell&quot; &quot;lein&quot; &quot;mysql&quot; &quot;node&quot; &quot;octave&quot; #&gt; [11] &quot;perl&quot; &quot;psql&quot; &quot;Rscript&quot; &quot;ruby&quot; &quot;sas&quot; #&gt; [16] &quot;scala&quot; &quot;sed&quot; &quot;sh&quot; &quot;stata&quot; &quot;zsh&quot; #&gt; [21] &quot;highlight&quot; &quot;Rcpp&quot; &quot;tikz&quot; &quot;dot&quot; &quot;c&quot; #&gt; [26] &quot;fortran&quot; &quot;fortran95&quot; &quot;asy&quot; &quot;cat&quot; &quot;asis&quot; #&gt; [31] &quot;stan&quot; &quot;block&quot; &quot;block2&quot; &quot;js&quot; &quot;css&quot; #&gt; [36] &quot;sql&quot; &quot;go&quot; &quot;python&quot; &quot;julia&quot; &quot;sass&quot; #&gt; [41] &quot;scss&quot; &quot;theorem&quot; &quot;lemma&quot; &quot;corollary&quot; &quot;proposition&quot; #&gt; [46] &quot;conjecture&quot; &quot;definition&quot; &quot;example&quot; &quot;exercise&quot; &quot;proof&quot; #&gt; [51] &quot;remark&quot; &quot;solution&quot; &quot;nomnoml&quot; # knit 支持的语法高亮主题 # Pandoc 支持的语法高亮环境 c( &quot;ABAP&quot;, &quot;IDL&quot;, &quot;Plasm&quot;, &quot;ACSL&quot;, &quot;inform&quot;, &quot;POV&quot;, &quot;Ada&quot;, &quot;Java&quot;, &quot;Prolog&quot;, &quot;Algol&quot;, &quot;JVMIS&quot;, &quot;Promela&quot;, &quot;Ant&quot;, &quot;ksh&quot;, &quot;Python&quot;, &quot;Assembler&quot;, &quot;Lisp&quot;, &quot;R&quot;, &quot;Awk&quot;, &quot;Logo&quot;, &quot;Reduce&quot;, &quot;bash&quot;, &quot;make&quot;, &quot;Rexx&quot;, &quot;Basic&quot;, &quot;Mathematica&quot;, &quot;RSL&quot;, &quot;C&quot;, &quot;Matlab&quot;, &quot;Ruby&quot;, &quot;C++&quot;, &quot;Mercury&quot;, &quot;S&quot;, &quot;Caml&quot;, &quot;MetaPost&quot;, &quot;SAS&quot;, &quot;Clean&quot;, &quot;Miranda&quot;, &quot;Scilab&quot;, &quot;Cobol&quot;, &quot;Mizar&quot;, &quot;sh&quot;, &quot;Comal&quot;, &quot;ML&quot;, &quot;SHELXL&quot;, &quot;csh&quot;, &quot;Modula-2&quot;, &quot;Simula&quot;, &quot;Delphi&quot;, &quot;MuPAD&quot;, &quot;SQL&quot;, &quot;Eiffel&quot;, &quot;NASTRAN&quot;, &quot;tcl&quot;, &quot;Elan&quot;, &quot;Oberon-2&quot;, &quot;TeX&quot;, &quot;erlang&quot;, &quot;OCL&quot;, &quot;VBScript&quot;, &quot;Euphoria&quot;, &quot;Octave&quot;, &quot;Verilog&quot;, &quot;Fortran&quot;, &quot;Oz&quot;, &quot;VHDL&quot;, &quot;GCL&quot;, &quot;Pascal&quot;, &quot;VRML&quot;, &quot;Gnuplot&quot;, &quot;Perl&quot;, &quot;XML&quot;, &quot;Haskell&quot;, &quot;PHP&quot;, &quot;XSLT&quot;, &quot;HTML&quot;, &quot;PL/I&quot; ) #&gt; [1] &quot;ABAP&quot; &quot;IDL&quot; &quot;Plasm&quot; &quot;ACSL&quot; &quot;inform&quot; #&gt; [6] &quot;POV&quot; &quot;Ada&quot; &quot;Java&quot; &quot;Prolog&quot; &quot;Algol&quot; #&gt; [11] &quot;JVMIS&quot; &quot;Promela&quot; &quot;Ant&quot; &quot;ksh&quot; &quot;Python&quot; #&gt; [16] &quot;Assembler&quot; &quot;Lisp&quot; &quot;R&quot; &quot;Awk&quot; &quot;Logo&quot; #&gt; [21] &quot;Reduce&quot; &quot;bash&quot; &quot;make&quot; &quot;Rexx&quot; &quot;Basic&quot; #&gt; [26] &quot;Mathematica&quot; &quot;RSL&quot; &quot;C&quot; &quot;Matlab&quot; &quot;Ruby&quot; #&gt; [31] &quot;C++&quot; &quot;Mercury&quot; &quot;S&quot; &quot;Caml&quot; &quot;MetaPost&quot; #&gt; [36] &quot;SAS&quot; &quot;Clean&quot; &quot;Miranda&quot; &quot;Scilab&quot; &quot;Cobol&quot; #&gt; [41] &quot;Mizar&quot; &quot;sh&quot; &quot;Comal&quot; &quot;ML&quot; &quot;SHELXL&quot; #&gt; [46] &quot;csh&quot; &quot;Modula-2&quot; &quot;Simula&quot; &quot;Delphi&quot; &quot;MuPAD&quot; #&gt; [51] &quot;SQL&quot; &quot;Eiffel&quot; &quot;NASTRAN&quot; &quot;tcl&quot; &quot;Elan&quot; #&gt; [56] &quot;Oberon-2&quot; &quot;TeX&quot; &quot;erlang&quot; &quot;OCL&quot; &quot;VBScript&quot; #&gt; [61] &quot;Euphoria&quot; &quot;Octave&quot; &quot;Verilog&quot; &quot;Fortran&quot; &quot;Oz&quot; #&gt; [66] &quot;VHDL&quot; &quot;GCL&quot; &quot;Pascal&quot; &quot;VRML&quot; &quot;Gnuplot&quot; #&gt; [71] &quot;Perl&quot; &quot;XML&quot; &quot;Haskell&quot; &quot;PHP&quot; &quot;XSLT&quot; #&gt; [76] &quot;HTML&quot; &quot;PL/I&quot; 20.4 表格样式 在数据分析报告中，根据报告的文本格式，我们有不同的数据呈现形式，基于 HTML 和 LaTeX 甚至 DOCX 表格样式工具 gt kableExtra flextable 和 DT remedy 格式化 Markdown 语法 beautifyR 整理 Markdown 表格 20.4.1 HTML 样式 20.4.2 LaTeX 样式 20.5 插件 提高写作效率的 10 大 R 包或 RStudio 插件 简化 Markdown 写作 remedy 源代码截图 carbonate 整理 Markdown 表格 beautifyR 引用参考文献 citr 格式化 R 代码块 styler 准备可重复的例子，方便在论坛/Github上发问 reprex 快速获取 Github 等社交网络活动记录 butteRfly 统计 R Markdown 文档中的单词 wordcountaddin 写可重复性研究报告 rrtools RStudio 插件集合 addinslist 高亮支持 R 帮助文档 rdoc markdown 简洁设计哲学， Sweave 文学编程思想，期间各种工具粉墨登场，最后分别回到 Pandoc 和 R Markdown 表 20.4: R Markdown 生态系统 Package Title addinsOutline RStudio Addins for Show Outline of a R Markdown/LaTeX Project blogdown Create Blogs and Websites with R Markdown bookdown Authoring Books and Technical Documents with R Markdown bsplus Adds Functionality to the R Markdown + Shiny Bootstrap Framework distill R Markdown Format for Scientific and Technical Writing flexdashboard R Markdown Format for Flexible Dashboards govdown GOV.UK Style Templates for R Markdown lazyrmd Render R Markdown Outputs Lazily liftr Containerize R Markdown Documents for Continuous Reproducibility memor A rmarkdown Template that Can be Highly Customized pagedown Paginate the HTML Output of R Markdown with CSS for Print posterdown Generate PDF Conference Posters Using R Markdown prereg R Markdown Templates to Preregister Scientific Studies prettydoc Creating Pretty Documents from R Markdown radix R Markdown Format for Scientific and Technical Writing revealjs R Markdown Format for reveal.js Presentations rmdfiltr Lua filters for R Markdown rmdformats HTML Output Formats and Templates for rmarkdown Documents rmdplugr Plugins for R Markdown Formats rmdshower R Markdown Format for shower Presentations rticles Article Formats for R Markdown tufte Tufte’s Styles for R Markdown Documents tufterhandout Tufte-style html document format for rmarkdown uiucthemes R Markdown Themes for UIUC Documents and Presentations vitae Curriculum Vitae for R Markdown webex Create Interactive Web Exercises in R Markdown ymlthis Write YAML for R Markdown, bookdown, blogdown, and More 20.6 报告 数据分析报告 R Markdown 20.7 简历 pagedown 20.8 书籍 bookdown 20.9 网站 blogdown 20.10 Shiny 以 shiny 为代表 library(ggplot2) p1 &lt;- ggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) + geom_point() + theme_minimal() p2 &lt;- ggplot(data = iris, aes(x = Petal.Length, y = Petal.Width, color = Species)) + geom_point() + theme_minimal() library(patchwork) p1 + p2 ggiraph 将 ggplot 对象转化为网页 library(ggiraph) girafe(code = print(p1 + p2), width_svg = 8, height_svg = 3) 将动态图形嵌入 Shiny App 中 图 20.9: A Shiny app created via the ggiraph package; you can see a live version at https://xiangyun.shinyapps.io/01-iris-ggiraph/. 20.11 幻灯片 xaringan 20.12 动画视频 animation 包 (???) 将 Base R 绘制的图形转化为动画或视频 av 包 (???) 基于 FFmpeg 将静态图片合成视频，而 gifski 包 (???) 基于 gifski 将静态图片合成 GIF 动画，gganimate 包 (???) 支持将 ggplot2 生成的图形，借助 gifski 包转化为动态图片或视频 library(gganimate) ggplot(data = Orange, aes(x = age, y = circumference, color = Tree)) + geom_point() + geom_line() + transition_reveal(age) 制作设计文档 ggplot2 功能结构图 R 闭包、环境等的关系图 20.13 图表 20.13.1 TikZ \\usetikzlibrary{arrows} \\begin{tikzpicture}[node distance=2cm, auto,&gt;=latex&#39;, thick, scale = 0.5] \\node (P) {$P$}; \\node (B) [right of=P] {$B$}; \\node (A) [below of=P] {$A$}; \\node (C) [below of=B] {$C$}; \\node (P1) [node distance=1.4cm, left of=P, above of=P] {$\\hat{P}$}; \\draw[-&gt;] (P) to node {$f$} (B); \\draw[-&gt;] (P) to node [swap] {$g$} (A); \\draw[-&gt;] (A) to node [swap] {$f$} (C); \\draw[-&gt;] (B) to node {$g$} (C); \\draw[-&gt;, bend right] (P1) to node [swap] {$\\hat{g}$} (A); \\draw[-&gt;, bend left] (P1) to node {$\\hat{f}$} (B); \\draw[-&gt;, dashed] (P1) to node {$k$} (P); \\end{tikzpicture} 图 20.10: Funky tikz 20.13.2 DOT digraph test123 { a -&gt; b -&gt; c; a -&gt; {x y}; b [shape=box]; c [label=&quot;hello\\nworld&quot;,color=blue,fontsize=24, fontname=&quot;Palatino-Italic&quot;,fontcolor=red,style=filled]; a -&gt; z [label=&quot;hi&quot;, weight=100]; x -&gt; z [label=&quot;multi-line\\nlabel&quot;]; edge [style=dashed,color=red]; b -&gt; x; {rank=same; b x} } 图 20.11: Funky dot DiagrammeR library(DiagrammeR) 20.13.3 UML nomnoml #stroke: orange #.circle: fill=#8f8 dashed visual=note [A]-[B] [B]-[&lt;circle&gt;C] 20.13.4 表格 DT gt 和 kableExtra DT 可以嵌在网页或 Shiny 应用中 kableExtra 支持 HTML 网页和 PDF 文档两种呈现方式 参考文献 "],
["animated-graphics.html", "第 21 章 动画 21.1 gganimate 21.2 magick", " 第 21 章 动画 rgl 和 svg 制作的动画，包括由静态图形转化过来的图形如 animation 或者 magick 和 gganimate 制作的图形 mapmate 制作地图方面的三维可视化图形和 gganimate 案例合集 21.1 gganimate library(ggplot2) library(gganimate) 生成静态图片 ggplot(mtcars, aes(disp, mpg)) + geom_point(colour = &quot;purple&quot;, size = 3) + facet_wrap(~cyl) 用来分面的变量 cyl 作为转场的帧 base_pic &lt;- ggplot(mtcars, aes(disp, mpg)) + geom_point(colour = &quot;purple&quot;, size = 3) + facet_wrap(~cyl) + transition_manual(cyl) + labs(title = &quot;{current_frame}&quot;) animate(base_pic, nframes = 100, fps = 50) #&gt; nframes and fps adjusted to match transition install.packages(c(&#39;transformr&#39;,&#39;gganimate&#39;,&#39;av&#39;)) # Create the gganimate plot library(gganimate) p &lt;- ggplot(airquality, aes(Day, Temp)) + geom_line(size = 2, colour = &#39;steelblue&#39;) + transition_states(Month, 4, 1) + shadow_mark(size = 1, colour = &#39;grey&#39;) # Render and show the video q &lt;- 2 df &lt;- animate(p, renderer = av_renderer(&#39;animation.mp4&#39;), width = 720*q, height = 480*q, res = 72*q, fps = 25) utils::browseURL(&#39;animation.mp4&#39;) 21.2 magick 由一帧帧静态图片合并转化为 GIF 图 library(gapminder) library(magick) img &lt;- image_graph(res = 96) datalist &lt;- split(gapminder, gapminder$year) out &lt;- lapply(datalist, function(data) { p &lt;- ggplot(data, aes(gdpPercap, lifeExp, size = pop, color = continent)) + scale_size(&quot;population&quot;, limits = range(gapminder$pop)) + scale_x_log10(limits = range(gapminder$gdpPercap)) + geom_point() + ylim(20, 90) + ggtitle(data$year) + theme_classic() print(p) }) dev.off() gapminder &lt;- image_animate(img, fps = 2) image_write(gapminder, &quot;data/gapminder.gif&quot;) gapminder 汉斯罗琳的 TED 演讲 tweenr 用于中间过渡，插值。 这个栗子叫 3D 版邪恶的曲线，源于 Y 叔的博客60。 \\[f(x;\\theta,\\phi) = \\theta x\\log(x)-\\frac{1}{\\phi}\\mathit{e}^{-\\phi^4(x-\\frac{1}{\\mathit{e}})^4}\\] 其中 \\(\\theta \\in (2,3), \\phi \\in (30,50), x \\in (0,1)\\) f &lt;- function(a, b) { function(y) { a * y * log(y, base = 10) - 1 / b * exp(-(b * y - b / exp(1))^4) } } y &lt;- seq(0, 1, length.out = 100) cols &lt;- colorspace::rainbow_hcl(5) d5 &lt;- data.frame(x = f(3, 30)(y), y = y, color = cols[1]) d4 &lt;- data.frame(x = f(2.8, 33)(y), y = y, color = cols[2]) d3 &lt;- data.frame(x = f(2.5, 36)(y), y = y, color = cols[3]) d2 &lt;- data.frame(x = f(2.2, 40)(y), y = y, color = cols[4]) d1 &lt;- data.frame(x = f(2, 50)(y), y = y, color = cols[5]) df &lt;- list(d5, d4, d3, d2, d1) library(tweenr) df2 &lt;- tween_states(df, tweenlength = 2, statelength = 1, ease = rep(&quot;cubic-in-out&quot;, 4), nframes = 100 ) library(ggplot2) ggplot(data = df2, aes(x, y, color = I(color), frame = .frame)) + geom_path() + coord_flip() + theme_minimal() + labs(x = NULL, y = NULL) #&gt; Warning: Removed 52 rows containing missing values (geom_path). 图 21.1: tweenr 添加过渡效果 https://guangchuangyu.github.io/cn/2017/09/3d-breast/↩︎ "],
["interactive-graphics.html", "第 22 章 交互式图形 22.1 rgl 22.2 plotly 22.3 leaflet 22.4 highcharter 22.5 vegawidget 22.6 网络图 22.7 threejs", " 第 22 章 交互式图形 htmlwidgets 将基于 JavaScript 的图形渲染库引入 R， svgViewR 包制作基于 SVG 和 WebGL 的 3D 动画 Vega and Vega-Lite vegawidget R ggplot2 “bindings” for Vega-Lite vegalite rgl 基于 opengl 的交互式三维图形可视化工具包 library(rgl) 22.1 rgl # demo(&#39;ChinaHeart3D&#39;, package = &#39;fun&#39;, ask = FALSE, echo = FALSE) xtheta = function(x, theta, y, w = 0, tt = 0) { (x^2 + (x * tan(theta))^2 + 2 * y^2 + 0.1 * cos(w * tt) - 0.9)^3 - (x^2 + y^2/9) * (x * tan(theta))^3 } fz = function(z, x, y, w = 0, tt = 0) { (x^2 + 2 * y^2 + z^2 + 0.1 * cos(w * tt) - 0.9)^3 - (x^2 + y^2/9) * z^3 } n = 100 y = seq(-2, 2, length.out = n) y0 = xx = zz = NULL for (i in 1:length(y)) { theta = seq(-pi/2, 1.5 * pi, length.out = n) solvex = function(theta, y) { if (theta == -pi/2 | theta == pi/2 | theta == 1.5 * pi) { return(0) } else if (theta &gt; -pi/2 &amp; theta &lt; pi/2) { interval = c(0, 2) } else { interval = c(-2, 0) } x.root = uniroot(xtheta, interval, theta, y)$root return(x.root) } if (xtheta(0, pi/4, y[i]) * xtheta(2, pi/4, y[i]) &gt; 0) next y0 = c(y0, y[i]) x = sapply(theta, solvex, y[i]) zplus = uniroot(fz, c(0, 2), 0, y[i])$root zminus = uniroot(fz, c(-2, 0), 0, y[i])$root z = numeric(n) z[x != 0] = x[x != 0] * tan(theta[x != 0]) z[x == 0] = (theta[x == 0] == pi/2) * zplus + (theta[x == 0] != pi/2) * zminus xx = cbind(xx, x) zz = cbind(zz, z) } yy = matrix(rep(y0, n), n, length(y0), byrow = TRUE) library(rgl) persp3d(zz, xx, yy, col = &quot;red&quot;, xlim = c(-1.2, 1.2), ylim = c(-1.2, 1.2), zlim = c(-1, 1), axes = FALSE, box = FALSE, xlab = &quot;&quot;, ylab = &quot;&quot;, zlab = &quot;&quot;) fy = function(y, pars) { z = pars[1] x = pars[2] w = pars[3] tt = pars[4] (x^2 + 2 * y^2 + z^2 + 0.1 * cos(w * tt) - 0.9)^3 - (x^2 + y^2/9) * z^3 } gety = function(z, x, interval = c(0.01, 1), w = 0, tt = 0) { mpars = cbind(z, x, w, tt) solvey = function(pars) { if (fy(interval[1], pars) * fy(interval[2], pars) &gt; 0) { return(NA) } else { y = uniroot(fy, interval, pars)$root } } y = apply(mpars, 1, solvey) return(y) } x0 = z0 = seq(-1, 1, length.out = n) y0 = outer(z0, x0, gety) persp3d(x = z0, y = x0, z = y0, zlim = c(-1, 1), col = &quot;white&quot;, texture = system.file(&quot;img&quot;, &quot;flag.png&quot;, package = &quot;fun&quot;), add = TRUE) #&gt; Warning in normalizePath(texture): path[1]=&quot;&quot;: No such file or directory persp3d(x = z0, y = x0, z = -y0, zlim = c(-1, 1), col = &quot;red&quot;, add = TRUE) 22.2 plotly plotly 类似 GGplot2 提供了各种交互图形的绘制函数，其中 plot_ly 函数提供了两种风格的绘图方式，一种是 Base R 另一种是 GGplot2，我们主要考虑使用 GGplot2 这种风格的 22.2.1 直方图 library(plotly, warn.conflicts = FALSE) #&gt; Loading required package: ggplot2 # 生成一些随机数 days &lt;- abs(rnorm(1000, 80, 125)) p1 &lt;- plot_ly(as.data.frame(days), x = ~days) %&gt;% add_histogram(name = &quot;plotly.js&quot;) # hist 的默认方法是 Sturges price_hist &lt;- function(method = &quot;FD&quot;) { h &lt;- hist(diamonds$price, breaks = method, plot = FALSE) plot_ly(x = h$mids, y = h$counts) %&gt;% add_bars(name = method) } subplot( p1, price_hist(), price_hist(&quot;Sturges&quot;), price_hist(&quot;Scott&quot;), nrows = 4, shareX = TRUE ) 22.2.2 地图 library(maps) map_data(&quot;world&quot;, &quot;china&quot;) %&gt;% group_by(group) %&gt;% plot_geo(x = ~long, y = ~lat) %&gt;% add_markers(size = I(1)) 22.2.3 热力图 data(geyser, package = &quot;MASS&quot;) den &lt;- MASS::kde2d(geyser$waiting, geyser$duration) # 热力图 plot_ly(x = den$x, y = den$y, z = den$z) %&gt;% add_heatmap() # 等高线图 plot_ly(x = den$x, y = den$y, z = den$z) %&gt;% add_contour() Tal Galili 开发的 heatmaply 包(???) 层次聚类可视化 22.3 leaflet leaflet 基于 leaflet.js 展示空间数据 library(leaflet) # a map with the default OSM tile layer leaflet() %&gt;% addTiles() %&gt;% setView(-93.65, 42.0285, zoom = 17) %&gt;% addPopups(-93.65, 42.0285, &#39;Here is the &lt;b&gt;Department of Statistics&lt;/b&gt;, ISU&#39;) 22.4 highcharter 22.4.1 时序图 可能需要研究下 highcharts.js 的 API https://api.highcharts.com/highcharts/series library(highcharter) #&gt; Registered S3 method overwritten by &#39;quantmod&#39;: #&gt; method from #&gt; as.zoo.data.frame zoo #&gt; Highcharts (www.highcharts.com) is a Highsoft software product which is #&gt; not free for commercial and Governmental use methods(hchart) #&gt; [1] hchart.acf* hchart.character* hchart.data.frame* #&gt; [4] hchart.default* hchart.density* hchart.dist* #&gt; [7] hchart.ets* hchart.factor* hchart.forecast* #&gt; [10] hchart.histogram* hchart.igraph* hchart.matrix* #&gt; [13] hchart.mforecast* hchart.mts* hchart.numeric* #&gt; [16] hchart.prcomp* hchart.princomp* hchart.stl* #&gt; [19] hchart.survfit* hchart.tibble* hchart.ts* #&gt; [22] hchart.xts* #&gt; see &#39;?methods&#39; for accessing help and source code getAnywhere(hchart.mts) #&gt; A single object matching &#39;hchart.mts&#39; was found #&gt; It was found in the following places #&gt; registered S3 method for hchart from namespace highcharter #&gt; namespace:highcharter #&gt; with value #&gt; #&gt; function (object, ..., separate = TRUE, heights = rep(1, ncol(object))) #&gt; { #&gt; if (separate) { #&gt; hc &lt;- hchart.mts2(object, heights = heights, ...) #&gt; } #&gt; else { #&gt; hc &lt;- hchart.mts1(object, ...) #&gt; } #&gt; hc #&gt; } #&gt; &lt;bytecode: 0x997f6b0&gt; #&gt; &lt;environment: namespace:highcharter&gt; class(EuStockMarkets) #&gt; [1] &quot;mts&quot; &quot;ts&quot; &quot;matrix&quot; # hchart(EuStockMarkets) # 为何不能绘制 hchart(AirPassengers) highchart() %&gt;% hc_chart(type = &quot;line&quot;) %&gt;% hc_title(text = &quot;Monthly Average Temperature&quot;) %&gt;% hc_subtitle(text = &quot;Source: WorldClimate.com&quot;) %&gt;% hc_xAxis(categories = c(&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;)) %&gt;% hc_yAxis(title = list(text = &quot;Temperature (C)&quot;)) %&gt;% hc_plotOptions(line = list( dataLabels = list(enabled = TRUE), enableMouseTracking = FALSE) ) %&gt;% hc_series( list( name = &quot;Tokyo&quot;, data = c(7.0, 6.9, 9.5, 14.5, 18.4, 21.5, 25.2, 26.5, 23.3, 18.3, 13.9, 9.6) ), list( name = &quot;London&quot;, data = c(3.9, 4.2, 5.7, 8.5, 11.9, 15.2, 17.0, 16.6, 14.2, 10.3, 6.6, 4.8) ) ) 22.4.2 散点图 data(diamonds, mpg, package = &quot;ggplot2&quot;) hchart(mpg, &quot;scatter&quot;, hcaes(x = displ, y = hwy, group = class)) 22.4.3 地图 美国失业率数据 data(unemployment, package = &quot;highcharter&quot;) temp &lt;- unlist(strsplit(unemployment[, 2], &quot;,&quot;)) # 拆成两列 unique(temp[seq(from = 2, to = length(temp), by = 2)]) # 51 个州 # US Counties unemployment rate # code: The county code. # # name: The county name. # # value: The unemployment. # A data.frame with 3 variables and 3216 observations. data(unemployment) hcmap(&quot;countries/us/us-all-all&quot;, data = unemployment, name = &quot;Unemployment&quot;, value = &quot;value&quot;, joinBy = c(&quot;hc-key&quot;, &quot;code&quot;), borderColor = &quot;transparent&quot; ) %&gt;% hc_colorAxis(dataClasses = color_classes(c(seq(0, 10, by = 2), 50))) %&gt;% hc_legend( layout = &quot;vertical&quot;, align = &quot;right&quot;, floating = TRUE, valueDecimals = 0, valueSuffix = &quot;%&quot; ) 22.5 vegawidget 动态交互图形包 vegawidget 基于 vega 支持导出 SVG 格式图片 library(&quot;vegawidget&quot;) spec_mtcars &lt;- list( `$schema` = vega_schema(), # specifies Vega-Lite description = &quot;An mtcars example.&quot;, data = list(values = mtcars), mark = &quot;point&quot;, encoding = list( x = list(field = &quot;wt&quot;, type = &quot;quantitative&quot;), y = list(field = &quot;mpg&quot;, type = &quot;quantitative&quot;), color = list(field = &quot;cyl&quot;, type = &quot;nominal&quot;) ) ) %&gt;% as_vegaspec() spec_mtcars 22.6 网络图 visNetwork 基于 vis.js 库 library(visNetwork) nodes &lt;- data.frame(id = 1:7, label = 1:7) edges &lt;- data.frame( from = c(1, 2, 2, 2, 3, 3, 2), to = c(2, 3, 4, 5, 6, 7, 7) ) 从上到下的方向 visNetwork(nodes, edges, width = &quot;100%&quot;) %&gt;% visEdges(arrows = &quot;from&quot;) %&gt;% visHierarchicalLayout() # same as visLayout(hierarchical = TRUE) 从左到右的方向 visNetwork(nodes, edges, width = &quot;100%&quot;) %&gt;% visEdges(arrows = &quot;to&quot;) %&gt;% visHierarchicalLayout(direction = &quot;LR&quot;, levelSeparation = 500) DiagrammeR 优点是可以将网络图导出 SVG 格式 22.7 threejs 三维交互可视化库，比如交互式全球可视化 Building an Interactive Globe Visualization in R threejs "],
["cs-cran-network.html", "第 23 章 案例：分析 CRAN 23.1 R 核心团队 23.2 高产的开发者 23.3 社区开发者 23.4 首次贡献 R 包 23.5 贡献关系网络 23.6 更新知多少 23.7 使用许可证 23.8 R 包增长速度 23.9 选择 R 包 23.10 运行环境", " 第 23 章 案例：分析 CRAN library(ggplot2) library(magrittr) options( ggplot2.continuous.colour = &quot;viridis&quot;, ggplot2.continuous.fill = &quot;viridis&quot; ) 首先我们从 CRAN 官网下载 R 包描述信息 pdb &lt;- tools::CRAN_package_db() 接着，我们可以看看CRAN 上发布的 R 包数量 length(pdb[, &quot;Package&quot;]) #&gt; [1] 15352 经过与官网发布的数据来对比，我们发现这里计算的结果与实际不符，多出来了几十个R包，所以我们再观察一下是否有重复的 R 包描述信息 pdb[, &quot;Package&quot;][duplicated(pdb[, &quot;Package&quot;])] #&gt; [1] &quot;boot&quot; &quot;class&quot; &quot;cluster&quot; &quot;codetools&quot; &quot;foreign&quot; #&gt; [6] &quot;KernSmooth&quot; &quot;lattice&quot; &quot;MASS&quot; &quot;Matrix&quot; &quot;mgcv&quot; #&gt; [11] &quot;nlme&quot; &quot;nnet&quot; &quot;rpart&quot; &quot;spatial&quot; &quot;survival&quot; #&gt; [16] &quot;adimpro&quot; &quot;aws&quot; &quot;frailtypack&quot; &quot;mpmi&quot; 不难发现，果然有！所以去掉重复的 R 包信息，就是 CRAN 上实际发布的 R 包数量 dim(subset(pdb, subset = !duplicated(pdb[, &quot;Package&quot;])))[1] #&gt; [1] 15333 接下来就是分析去掉重复信息后的数据矩阵 pdb pdb &lt;- subset(pdb, subset = !duplicated(pdb[, &quot;Package&quot;])) 23.1 R 核心团队 R 核心团队除了维护开发 Base R 包以外，还开发了哪些 R 包，我们依据这些开发者邮箱 &lt;Firstname&gt;.&lt;Lastname&gt;@R-project.org 的特点，从数据集 pdb 中提取他们开发的 R 包 core_pdb &lt;- subset(pdb, subset = grepl( x = pdb[, &quot;Maintainer&quot;], pattern = &quot;(@R-project\\\\.org)&quot; ), select = c(&quot;Package&quot;, &quot;Maintainer&quot;) ) dim(core_pdb[order(core_pdb[, &quot;Maintainer&quot;]), ]) #&gt; [1] 96 2 这么少，是不是有点意外，看来很多大佬更喜欢用自己的邮箱，比如 Paul Murrell， 他的邮箱是 paul@stat.auckland.ac.nz subset(pdb, subset = grepl(x = pdb[, &quot;Maintainer&quot;], pattern = &quot;(Paul Murrell)&quot;), select = c(&quot;Package&quot;, &quot;Maintainer&quot;)) #&gt; Package Maintainer #&gt; 2086 compare Paul Murrell &lt;p.murrell@auckland.ac.nz&gt; #&gt; 5304 graphicsQC Paul Murrell &lt;paul@stat.auckland.ac.nz&gt; #&gt; 5337 gridBase Paul Murrell &lt;paul@stat.auckland.ac.nz&gt; #&gt; 5338 gridBezier Paul Murrell &lt;paul@stat.auckland.ac.nz&gt; #&gt; 5339 gridDebug Paul Murrell &lt;p.murrell@auckland.ac.nz&gt; #&gt; 5341 gridGeometry Paul Murrell &lt;paul@stat.auckland.ac.nz&gt; #&gt; 5342 gridGraphics Paul Murrell &lt;paul@stat.auckland.ac.nz&gt; #&gt; 5343 gridGraphviz Paul Murrell &lt;p.murrell@auckland.ac.nz&gt; #&gt; 5346 gridSVG Paul Murrell &lt;paul@stat.auckland.ac.nz&gt; .... 所以这种方式不行了，只能列举所有 R Core Team 成员，挨个去匹配，幸好 contributors() 函数已经收集了成员名单，不需要我们去官网找了。 core_team &lt;- read.table( text = &quot; Douglas Bates John Chambers Peter Dalgaard Robert Gentleman Kurt Hornik Ross Ihaka Tomas Kalibera Michael Lawrence Friedrich Leisch Uwe Ligges Thomas Lumley Martin Maechler Martin Morgan Paul Murrell Martyn Plummer Brian Ripley Deepayan Sarkar Duncan Temple Lang Luke Tierney Simon Urbanek Heiner Schwarte Guido Masarotto Stefano Iacus Seth Falcon Duncan Murdoch David Meyer Simon Wood &quot;, header = FALSE, sep = &quot;\\n&quot;, check.names = FALSE, stringsAsFactors = FALSE, colClasses = &quot;character&quot;, comment.char = &quot;&quot;, col.names = &quot;name&quot; ) R 核心团队维护的 R 包及其最新发布的日期 core_pdb &lt;- subset(pdb, subset = grepl( x = pdb[, &quot;Maintainer&quot;], pattern = paste(&quot;(&quot;, core_team$name, &quot;)&quot;, collapse = &quot;|&quot;, sep = &quot;&quot;) ), select = c(&quot;Package&quot;, &quot;Maintainer&quot;, &quot;Published&quot;) ) 清理 Maintainer 字段中的邮箱部分，方便表格展示 clean_maintainer &lt;- function(x) { # 去掉邮箱 x &lt;- gsub(&quot;&lt;([^&lt;&gt;]*)&gt;&quot;, &quot;&quot;, x) # 去掉 \\n \\t \\&#39; \\&quot; 和 &#39; x &lt;- gsub(&quot;(\\\\\\n)|(\\\\\\t)|(\\\\\\&quot;)|(\\\\\\&#39;)|(&#39;)&quot;, &quot;&quot;, x) # 去掉末尾空格 x &lt;- gsub(&quot; +$&quot;, &quot;&quot;, x) } core_pdb[, &quot;Maintainer&quot;] &lt;- clean_maintainer(core_pdb[, &quot;Maintainer&quot;]) 我们可以看到 R 核心团队总共开发维护有 172 个 R 包 dim(core_pdb) #&gt; [1] 172 3 篇幅所限，我们就展示部分人和R包，见表 23.1 按照拼音顺序 Brian Ripley 是第一位 knitr::kable(head(core_pdb[order( core_pdb[, &quot;Maintainer&quot;], core_pdb[, &quot;Published&quot;] ), ], 10), caption = &quot;R Core Team 维护的 R 包（展示部分）&quot;, booktabs = TRUE, row.names = FALSE ) 表 23.1: R Core Team 维护的 R 包（展示部分） Package Maintainer Published spatial Brian Ripley 2015-08-30 nnet Brian Ripley 2016-02-02 mix Brian Ripley 2017-06-12 pspline Brian Ripley 2017-06-12 class Brian Ripley 2019-01-01 tree Brian Ripley 2019-04-26 fastICA Brian Ripley 2019-07-08 RODBC Brian Ripley 2019-09-03 KernSmooth Brian Ripley 2019-10-15 gee Brian Ripley 2019-11-07 分组计数，看看每个核心开发者维护的 R 包有多少 sort(table(core_pdb[, &quot;Maintainer&quot;]), decreasing = TRUE) #&gt; #&gt; Kurt Hornik Martin Maechler Simon Urbanek Paul Murrell #&gt; 28 27 24 18 #&gt; Brian Ripley Thomas Lumley Uwe Ligges Duncan Murdoch #&gt; 12 10 9 7 #&gt; Michael Lawrence David Meyer Friedrich Leisch Luke Tierney #&gt; 7 6 5 5 #&gt; Douglas Bates John Chambers Simon Wood Deepayan Sarkar #&gt; 3 3 3 2 #&gt; Martyn Plummer Peter Dalgaard #&gt; 2 1 23.2 高产的开发者 这些人的个人简介 接下来，我们再来查看一些比较高产的 R 包开发者谢益辉都维护了哪些R包，如表 23.2 所示 yihui_pdb &lt;- subset(pdb, subset = grepl(&quot;Yihui Xie&quot;, pdb[, &quot;Maintainer&quot;]), select = c(&quot;Package&quot;, &quot;Title&quot;) ) yihui_pdb[, &quot;Title&quot;] &lt;- gsub(&quot;(\\\\\\n)&quot;, &quot; &quot;, yihui_pdb[, &quot;Title&quot;]) knitr::kable(yihui_pdb, caption = &quot;谢益辉维护的 R Markdown 生态&quot;, booktabs = TRUE, row.names = FALSE) 表 23.2: 谢益辉维护的 R Markdown 生态 Package Title animation A Gallery of Animations in Statistics and Utilities to Create Animations blogdown Create Blogs and Websites with R Markdown bookdown Authoring Books and Technical Documents with R Markdown DT A Wrapper of the JavaScript Library ‘DataTables’ evaluate Parsing and Evaluation Tools that Provide More Details than the Default formatR Format R Code Automatically fun Use R for Fun highr Syntax Highlighting for R Source Code knitr A General-Purpose Package for Dynamic Report Generation in R markdown Render Markdown with the C Library ‘Sundown’ mime Map Filenames to MIME Types MSG Data and Functions for the Book Modern Statistical Graphics pagedown Paginate the HTML Output of R Markdown with CSS for Print printr Automatically Print R Objects to Appropriate Formats According to the ‘knitr’ Output Format Rd2roxygen Convert Rd to ‘Roxygen’ Documentation rmarkdown Dynamic Documents for R rolldown R Markdown Output Formats for Storytelling rticles Article Formats for R Markdown servr A Simple HTTP Server to Serve Static Files or Dynamic Documents testit A Simple Package for Testing R Packages tinytex Helper Functions to Install and Maintain ‘TeX Live’, and Compile ‘LaTeX’ Documents tufte Tufte’s Styles for R Markdown Documents xaringan Presentation Ninja xfun Miscellaneous Functions by ‘Yihui Xie’ Jeroen Ooms 维护从 C++ 世界搬运进来的库，如图像处理 magick 包、 视频处理 av 包、 PDF 文档操作 qpdf 包 subset(pdb, subset = grepl(&quot;Jeroen Ooms&quot;, pdb[, &quot;Maintainer&quot;]), select = &#39;Package&#39;, drop = TRUE) #&gt; [1] &quot;antiword&quot; &quot;askpass&quot; &quot;av&quot; &quot;base64&quot; &quot;bcrypt&quot; #&gt; [6] &quot;brotli&quot; &quot;cld2&quot; &quot;cld3&quot; &quot;commonmark&quot; &quot;credentials&quot; #&gt; [11] &quot;curl&quot; &quot;gert&quot; &quot;gifski&quot; &quot;gpg&quot; &quot;graphql&quot; #&gt; [16] &quot;hunspell&quot; &quot;jenkins&quot; &quot;jose&quot; &quot;js&quot; &quot;jsonld&quot; #&gt; [21] &quot;jsonlite&quot; &quot;magick&quot; &quot;minimist&quot; &quot;mongolite&quot; &quot;opencpu&quot; #&gt; [26] &quot;opencv&quot; &quot;openssl&quot; &quot;pdftools&quot; &quot;protolite&quot; &quot;qpdf&quot; #&gt; [31] &quot;RAppArmor&quot; &quot;rjade&quot; &quot;RMySQL&quot; &quot;rsvg&quot; &quot;rzmq&quot; #&gt; [36] &quot;sodium&quot; &quot;spelling&quot; &quot;ssh&quot; &quot;sys&quot; &quot;tesseract&quot; #&gt; [41] &quot;unix&quot; &quot;unrtf&quot; &quot;V8&quot; &quot;webp&quot; &quot;webutils&quot; #&gt; [46] &quot;writexl&quot; &quot;xslt&quot; Dirk Eddelbuettel 维护 Rcpp 生态 subset(pdb, subset = grepl(&quot;Dirk Eddelbuettel&quot;, pdb[, &quot;Maintainer&quot;]), select = &#39;Package&#39;, drop = TRUE) #&gt; [1] &quot;anytime&quot; &quot;AsioHeaders&quot; &quot;BH&quot; #&gt; [4] &quot;binb&quot; &quot;dang&quot; &quot;digest&quot; #&gt; [7] &quot;drat&quot; &quot;gaussfacts&quot; &quot;gcbd&quot; #&gt; [10] &quot;gettz&quot; &quot;gunsales&quot; &quot;inline&quot; #&gt; [13] &quot;linl&quot; &quot;littler&quot; &quot;nanotime&quot; #&gt; [16] &quot;pinp&quot; &quot;pkgKitten&quot; &quot;prrd&quot; #&gt; [19] &quot;random&quot; &quot;RApiDatetime&quot; &quot;RApiSerialize&quot; #&gt; [22] &quot;Rblpapi&quot; &quot;Rcpp&quot; &quot;RcppAnnoy&quot; #&gt; [25] &quot;RcppAPT&quot; &quot;RcppArmadillo&quot; &quot;RcppBDT&quot; #&gt; [28] &quot;RcppCCTZ&quot; &quot;RcppClassic&quot; &quot;RcppClassicExamples&quot; #&gt; [31] &quot;RcppCNPy&quot; &quot;RcppDE&quot; &quot;RcppEigen&quot; #&gt; [34] &quot;RcppExamples&quot; &quot;RcppGetconf&quot; &quot;RcppGSL&quot; #&gt; [37] &quot;RcppMsgPack&quot; &quot;RcppNLoptExample&quot; &quot;RcppQuantuccia&quot; #&gt; [40] &quot;RcppRedis&quot; &quot;RcppSMC&quot; &quot;RcppStreams&quot; #&gt; [43] &quot;RcppTOML&quot; &quot;RcppXts&quot; &quot;RcppZiggurat&quot; #&gt; [46] &quot;RDieHarder&quot; &quot;rfoaas&quot; &quot;RInside&quot; #&gt; [49] &quot;rmsfact&quot; &quot;RProtoBuf&quot; &quot;RPushbullet&quot; #&gt; [52] &quot;RQuantLib&quot; &quot;RVowpalWabbit&quot; &quot;sanitizers&quot; #&gt; [55] &quot;tint&quot; &quot;ttdo&quot; &quot;x13binary&quot; Hadley Wickham 维护 tidyverse 生态 subset(pdb, subset = grepl(&quot;Hadley Wickham&quot;, pdb[, &quot;Maintainer&quot;]), select = &#39;Package&#39;, drop = TRUE) #&gt; [1] &quot;assertthat&quot; &quot;babynames&quot; &quot;bigrquery&quot; &quot;classifly&quot; #&gt; [5] &quot;clusterfly&quot; &quot;conflicted&quot; &quot;dbplyr&quot; &quot;dplyr&quot; #&gt; [9] &quot;dtplyr&quot; &quot;ellipsis&quot; &quot;feather&quot; &quot;forcats&quot; #&gt; [13] &quot;fueleconomy&quot; &quot;ggplot2&quot; &quot;ggplot2movies&quot; &quot;gtable&quot; #&gt; [17] &quot;haven&quot; &quot;hflights&quot; &quot;highlight&quot; &quot;httr&quot; #&gt; [21] &quot;lazyeval&quot; &quot;lobstr&quot; &quot;lvplot&quot; &quot;meifly&quot; #&gt; [25] &quot;modelr&quot; &quot;nasaweather&quot; &quot;nycflights13&quot; &quot;pkgdown&quot; #&gt; [29] &quot;plyr&quot; &quot;productplots&quot; &quot;profr&quot; &quot;proto&quot; #&gt; [33] &quot;pryr&quot; &quot;rappdirs&quot; &quot;reshape&quot; &quot;reshape2&quot; #&gt; [37] &quot;rggobi&quot; &quot;roxygen2&quot; &quot;rvest&quot; &quot;scales&quot; #&gt; [41] &quot;sloop&quot; &quot;stringr&quot; &quot;testthat&quot; &quot;tidyr&quot; #&gt; [45] &quot;tidyverse&quot; &quot;vctrs&quot; Scott Chamberlain 是非营利性组织 rOpenSci 的联合创始人，但是没几个 R 包听说过 subset(pdb, subset = grepl(&quot;Scott Chamberlain&quot;, pdb[, &quot;Maintainer&quot;]), select = &#39;Package&#39;, drop = TRUE) #&gt; [1] &quot;analogsea&quot; &quot;bold&quot; &quot;brranching&quot; &quot;ccafs&quot; &quot;charlatan&quot; #&gt; [6] &quot;citecorp&quot; &quot;ckanr&quot; &quot;conditionz&quot; &quot;cowsay&quot; &quot;crevents&quot; #&gt; [11] &quot;crminer&quot; &quot;crul&quot; &quot;discgolf&quot; &quot;elastic&quot; &quot;fauxpas&quot; #&gt; [16] &quot;finch&quot; &quot;fulltext&quot; &quot;geoaxe&quot; &quot;geojson&quot; &quot;geojsonio&quot; #&gt; [21] &quot;geojsonlint&quot; &quot;geoops&quot; &quot;getlandsat&quot; &quot;gistr&quot; &quot;handlr&quot; #&gt; [26] &quot;hoardr&quot; &quot;httpcode&quot; &quot;httping&quot; &quot;isdparser&quot; &quot;jaod&quot; #&gt; [31] &quot;jqr&quot; &quot;lawn&quot; &quot;mapr&quot; &quot;microdemic&quot; &quot;mregions&quot; #&gt; [36] &quot;natserv&quot; &quot;nodbi&quot; &quot;oai&quot; &quot;openadds&quot; &quot;originr&quot; #&gt; [41] &quot;pangaear&quot; &quot;phylocomr&quot; &quot;pleiades&quot; &quot;pubchunks&quot; &quot;randgeo&quot; #&gt; [46] &quot;rbhl&quot; &quot;rbison&quot; &quot;rbraries&quot; &quot;rcitoid&quot; &quot;rcoreoa&quot; #&gt; [51] &quot;rcrossref&quot; &quot;rdatacite&quot; &quot;rdpla&quot; &quot;rdryad&quot; &quot;request&quot; #&gt; [56] &quot;rerddap&quot; &quot;rgbif&quot; &quot;rif&quot; &quot;ritis&quot; &quot;rjsonapi&quot; #&gt; [61] &quot;rnoaa&quot; &quot;rnpn&quot; &quot;rorcid&quot; &quot;rphylopic&quot; &quot;rplos&quot; #&gt; [66] &quot;rredlist&quot; &quot;rsnps&quot; &quot;rvertnet&quot; &quot;scrubr&quot; &quot;seaaroundus&quot; #&gt; [71] &quot;sofa&quot; &quot;solrium&quot; &quot;spocc&quot; &quot;taxize&quot; &quot;taxizedb&quot; #&gt; [76] &quot;traits&quot; &quot;vcr&quot; &quot;webmockr&quot; &quot;wellknown&quot; &quot;wikitaxa&quot; #&gt; [81] &quot;worrms&quot; &quot;zbank&quot; 23.3 社区开发者 接下来，我们想看看 R 包维护者数量有多少 length(unique(pdb[, &quot;Maintainer&quot;])) #&gt; [1] 9059 可实际上没有这么多的开发者，因为存在这样的情况，以 R 包维护者 Hadley Wickham 为例，由于他曾使用过不同的邮箱，所以在维护者字段出现了不一致的情况，实际却是同一个人。 subset(pdb, subset = grepl(&quot;Hadley Wickham&quot;, pdb[, &quot;Maintainer&quot;]), select = c(&quot;Package&quot;, &quot;Maintainer&quot;) ) #&gt; Package Maintainer #&gt; 509 assertthat Hadley Wickham &lt;hadley@rstudio.com&gt; #&gt; 626 babynames Hadley Wickham &lt;hadley@rstudio.com&gt; #&gt; 1006 bigrquery Hadley Wickham &lt;hadley@rstudio.com&gt; #&gt; 1817 classifly Hadley Wickham &lt;h.wickham@gmail.com&gt; #&gt; 1903 clusterfly Hadley Wickham &lt;h.wickham@gmail.com&gt; #&gt; 2156 conflicted Hadley Wickham &lt;hadley@rstudio.com&gt; #&gt; 2692 dbplyr Hadley Wickham &lt;hadley@rstudio.com&gt; #&gt; 3199 dplyr Hadley Wickham &lt;hadley@rstudio.com&gt; #&gt; 3286 dtplyr Hadley Wickham &lt;hadley@rstudio.com&gt; .... 因此，有必要先把 Maintainer 字段中的邮箱部分去掉，这样我们可以得到比较靠谱的R包维护者数量了！ pdb[, &quot;Maintainer&quot;] &lt;- clean_maintainer(pdb[, &quot;Maintainer&quot;]) length(unique(pdb[, &quot;Maintainer&quot;])) #&gt; [1] 8381 接下来，我们还想把 R 包维护者，按照其维护的R包数量排个序，用条形图23.1 表示 top_maintainer &lt;- head(sort(table(pdb[, &quot;Maintainer&quot;]), decreasing = TRUE), 20) par(mar = c(2, 7, 1, 1)) barCenters &lt;- barplot(top_maintainer, col = &quot;lightblue&quot;, axes = FALSE, axisnames = FALSE, horiz = TRUE, border = &quot;white&quot; ) text( y = barCenters, x = par(&quot;usr&quot;)[3], adj = 1, labels = names(top_maintainer), xpd = TRUE ) axis(1, labels = seq(0, 90, by = 10), at = seq(0, 90, by = 10), las = 1, col = &quot;gray&quot; ) grid() 图 23.1: 维护R包数量最多的20个人63 调用 ggplot2 包绘图要求输入的数据类型是 data.frame，所以我们首先将 top_maintainer 转化为数据框类型 top_maintainer &lt;- as.data.frame(top_maintainer) colnames(top_maintainer) &lt;- c(&quot;Maintainer&quot;, &quot;Freq&quot;) ggplot(top_maintainer) + geom_bar(aes(x = Maintainer, y = Freq), stat = &quot;identity&quot;) + coord_flip() + xlab(&quot;Maintainer&quot;) + ylab(&quot;Numbers of Package&quot;) 条形图在柱子很多的情况下，点线图是一种更加简洁的替代方式 ggplot(top_maintainer, aes(x = Freq, y = Maintainer)) + geom_segment(aes(x = 20, xend = Freq, yend = Maintainer), colour = &quot;grey50&quot;) + geom_point(size = 2, colour = &quot;red&quot;) + labs(x = &quot; # of Packages &quot;, y = &quot; Maintainer &quot;) 接下来，我们想看看开发者维护的 R 包数量的分布，仅从上图，我们知道有的人能维护 80 多个 R 包，总体的分布情况又是如何呢？如图所示，我们将纵轴刻度设置为 log 模式，随着开发的R包数量的增加，开发者人数是指数级递减，可见开发R包依然是一个门槛很高的工作！ barplot(table(table(pdb[, &quot;Maintainer&quot;])), col = &quot;lightblue&quot;, log = &quot;y&quot;, border = &quot;white&quot;, xlab = &quot;# of Packages&quot;, ylab = &quot;# of Maintainers (log)&quot;, panel.first = grid() ) 只开发一个 R 包的人数达到 5276 人，占开发者总数的 67.31%，约为2/3。 23.4 首次贡献 R 包 我们还想进一步了解这些人是不是就自己开发自己维护，基本没有其他人参与，答案是 Almost Sure. 这些人其实占了大部分，相比于前面的 R 核心开发团队或者 R Markdown 生态的维护者，他们绝大部分属于金字塔底部的人，二八定律似乎在这里再次得到印证。 sub_pdb &lt;- subset(pdb, select = c(&quot;Package&quot;, &quot;Maintainer&quot;, &quot;Author&quot;)) 接着先清理一下 Maintainer 和 Author 字段，Author 字段的内容比起 Maintainer 复杂一些 clean_author &lt;- function(x) { # 去掉中括号及其内容 [aut] [aut, cre] x &lt;- gsub(&quot;(\\\\[.*?\\\\])&quot;, &quot;&quot;, x) # 去掉小括号及其内容 () x &lt;- gsub(&quot;(\\\\(.*?\\\\))&quot;, &quot;&quot;, x) # 去掉尖括号及其内容 &lt; &gt; x &lt;- gsub(&quot;(&lt;.*?&gt;)&quot;, &quot;&quot;, x) # 去掉 \\n x &lt;- gsub(&quot;(\\\\\\n)&quot;, &quot;&quot;, x) # 去掉制表符、双引号、单引号和 \\&#39;，如 &#39;Hadley Wickham&#39; 中的单引号 &#39; 等 x &lt;- gsub(&quot;(\\\\\\t)|(\\\\\\&quot;)|(\\\\\\&#39;)|(&#39;)|(\\\\))&quot;, &quot;&quot;, x) # Christian P. Robert, Universite Paris Dauphine, and Jean-Michel\\n Marin, Universite Montpellier 2 x &lt;- gsub(&quot;(and)&quot;, &quot;&quot;, x) # 两个以上的空格替换为一个空格 x &lt;- gsub(&quot;( {2,})&quot;,&quot; &quot;,x) x } sub_pdb[, &quot;Maintainer&quot;] &lt;- clean_maintainer(sub_pdb[, &quot;Maintainer&quot;]) sub_pdb[, &quot;Author&quot;] &lt;- clean_author(sub_pdb[, &quot;Author&quot;]) 维护多个 R 包的开发者数量 length(unique(sub_pdb[, &quot;Maintainer&quot;][duplicated(sub_pdb[, &quot;Maintainer&quot;])])) #&gt; [1] 2725 总的开发者中去掉开发了多个R包的人，就剩下只维护1个R包的开发者，共有 first_ctb &lt;- setdiff( sub_pdb[, &quot;Maintainer&quot;][!duplicated(sub_pdb[, &quot;Maintainer&quot;])], unique(sub_pdb[, &quot;Maintainer&quot;][duplicated(sub_pdb[, &quot;Maintainer&quot;])]) ) 按照每个R包贡献者的数量分组，如图所示，有一个或者没有贡献者的占总数占 70.60%，说明这些 R 包的开发者基本在单干，有 4 个及以下的贡献者占总数（这个总数是指只开发了一个R包的那些开发者）的 90.85%。 ctb_num &lt;- unlist( lapply( strsplit( subset(sub_pdb, subset = sub_pdb[, &quot;Maintainer&quot;] %in% first_ctb, select = &quot;Author&quot;, drop = TRUE # drop out data.frame return vector ), split = &quot;,&quot; ), length ) ) hist(ctb_num, col = &quot;lightblue&quot;, border = &quot;white&quot;, probability = TRUE, labels = TRUE, xlab = &quot;# of Contributors&quot;, ylab = &quot;Proportion&quot;, main = &quot;&quot;, panel.first = grid(), xlim = c(0, 10)) 这些基本单干的R包开发者是否参与其它 R 包的贡献？如果不参与，则他们对社区的贡献非常有限，仅限于为社区带来数量上的堆积！ table(ctb_num) #&gt; ctb_num #&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #&gt; 2724 1183 742 457 215 107 76 49 32 23 10 10 3 3 3 #&gt; 16 17 18 19 21 22 27 42 #&gt; 5 3 2 1 3 2 2 1 有意思的是，有一个开发者虽然只开发了一个 R 包，但是却引来37位贡献者（包括开发者本人在内），下面把这个颇受欢迎的 R 包找出来 # 找到开发者 first_ctb[which.max(ctb_num)] #&gt; [1] &quot;Matt Dowle&quot; # 找到 R 包 subset(sub_pdb, subset = grepl(&quot;Matt Dowle&quot;, sub_pdb[, &quot;Maintainer&quot;]), select = &quot;Package&quot;) #&gt; Package #&gt; 2614 data.table 哇，大名鼎鼎的 data.table 包！！ I JUST find it!! 这是个异数，我们知道 data.table 在R社区享有盛名，影响范围很广，从 Matt Dowle 的 Github 主页 来看，他确实只开发了这一个 R 包！黑天鹅在这里出现了！如果按照谁的贡献者多谁影响力大的规律来看，有 10 个以上贡献者的其它几个 R 包也必定是名器！这里留给读者把它找出来吧！ 23.5 贡献关系网络 接下来进入本节最核心的部分，分析所有的开发者之间的贡献网络，在第23.4节清理 Author 字段的正则表达式几乎不可能覆盖到所有的情况，所以既然 Maintainer 字段是比较好清理的，不妨以它作为匹配的模式去匹配 Author 字段，这样做的代价就是迭代次数会很多，增加一定的计算负担，但是为了更加准确的清理结果，也是拼了！ net_pdb &lt;- subset(pdb, select = c(&quot;Maintainer&quot;, &quot;Author&quot;)) net_pdb[, &quot;Maintainer&quot;] &lt;- clean_maintainer(net_pdb[, &quot;Maintainer&quot;]) total_maintainer &lt;- unique(net_pdb[, &quot;Maintainer&quot;]) clean_author &lt;- function(maintainer) { sapply(net_pdb[, &quot;Author&quot;], grepl, pattern = paste0(&quot;(&quot;, maintainer, &quot;)&quot;)) } 接下来是非常耗时的一步，实际是两层循环 1.2 亿次左右的查找计算， grepl 耗时 30分钟左右，正则表达式本身的性能优化问题，maintainer_author 逻辑型矩阵占用内存空间 430 M 左右 maintainer_author &lt;- Reduce(&quot;cbind&quot;, lapply(total_maintainer, clean_author)) colnames(maintainer_author) &lt;- total_maintainer rownames(maintainer_author) &lt;- net_pdb[, &quot;Maintainer&quot;] 为了重复运行这段耗时很长的代码，我们将中间结果保存到磁盘，推荐保存为 R 支持的序列化后的数据格式 *.rds，相比于 *.csv 格式能极大地减少磁盘存储空间，读者可运行下面两行保存数据的代码，比较看看！ saveRDS(maintainer_author, file = &quot;data/maintainer_author.rds&quot;) write.table(maintainer_author,file = &quot;data/maintainer_author.csv&quot;, row.names = TRUE, col.names = TRUE) 查看 maintainer_author 数据集占用内存空间的大小 format(object.size(maintainer_author), units = &quot;auto&quot;) #&gt; [1] &quot;430.5 Mb&quot; 看几个数字，R 包贡献者最多的有 62 人,这个 R 包的粉丝是真多！有一个开发者对 137 个 R 包的做出过贡献，其中包括自己开发的 R 包，快来快来抓住他！ max(rowSums(maintainer_author)) #&gt; [1] 62 max(colSums(maintainer_author)) #&gt; [1] 137 继续看看每个开发者对外贡献的量的分布情况，由图可知，绝大部分开发者对外输出不超过 3，其表示对其它 R 包的贡献不超过 3个 hist(colSums(maintainer_author)[colSums(maintainer_author) &lt;= 10], probability = FALSE, xlab = &quot;&quot;, main = &quot;&quot;) 每个 R 包参与贡献的人数分布又是如何呢？如图所示，基本集中在1~2个人的样子 hist(rowSums(maintainer_author)[rowSums(maintainer_author) &lt;= 20], xlab = &quot;&quot;, main = &quot;&quot;,probability = FALSE) 好了，接下来我们要深入挖掘贡献协作网络中的结构特点，看看是不是由几位领导人在完全掌控，还有一大群人其实是自己搞自己的那点事，写论文、发布 R 包、投稿等如此循环。其实这就是 R 社区的特点，也决定了它不会像 Python 那样应用性强，有足够多的工程开发人员加入。大多数人写 R 包只是为了配合发论文而已，并不关心有没有人来用自己的 R 包！此外，没有人来做功能整合和持续维护，所以发展缓慢！各自造轮子的事情太多！ 接着，先从表面看看开发者和贡献者的关系矩阵，maintainer_author 是一个大型的超稀疏矩阵，非零元素最多的行、列分别只占 0.79% 和 0.95%，都不到百分之一。 # 非零元素最多的行 max(rowMeans(maintainer_author)) #&gt; [1] 0.007904131 # 非零元素最多的列 max(colMeans(maintainer_author)) #&gt; [1] 0.009548369 用稀疏索引的方式重新编码矩阵，然后用社群检测的算法找到其中的结构，网络关系图用 Gephi 画，igraph 肯定是不行了，参考文献 社会网络分析：探索人人网好友推荐系统 网络的统计建模分析61 重新获取 maintainer_author 矩阵，存储指标向量，然后调用 Matrix 生成稀疏矩阵，后续的数据操作就好办了，因为 Matrix 包是内置的，它定义的稀疏矩阵类其它 R 包也都支持。先以一个简单的例子说明构造稀疏矩阵的过程 library(Matrix) spM &lt;- spMatrix(3, 4, i = c(1, 1, 2, 3, 3), j = c(4, 1, 2, 1, 3), x = c(4, 4, 1, 4, 8)) spM #&gt; 3 x 4 sparse Matrix of class &quot;dgTMatrix&quot; #&gt; #&gt; [1,] 4 . . 4 #&gt; [2,] . 1 . . #&gt; [3,] 4 . 8 . image(spM) 图 23.2: 稀疏矩阵的图表示 i 和 j 表示矩阵中有值的位置，x 表示对应位置上的值，i，j 和 x 是三个长度相等的数值型向量，我们还可以调用 image函数，把稀疏矩阵可视化出来，对于大型稀疏矩阵可视化其稀疏模式是重要的。 贡献网络可视化62 clean_net_pdb &lt;- function(maintainer) { index &lt;- clean_author(maintainer) if (sum(index) == 0) { return(NULL) } data.frame( from_id = maintainer, to_id = net_pdb[, &quot;Maintainer&quot;][index], stringsAsFactors = FALSE ) } # maintainer_author &lt;- data.table::rbindlist(lapply(total_maintainer, clean_net_pdb)) # saveRDS(maintainer_author, file = &quot;data/maintainer_author.rds&quot;) toc &lt;- system.time({ maintainer_author_net &lt;- Reduce(&quot;rbind&quot;, lapply(total_maintainer, clean_net_pdb)) }, gcFirst = TRUE) 分组统计开发者之间贡献次数，从开发者到 maintainer_author_net$weight &lt;- 1 edges &lt;- aggregate(weight ~ from_id + to_id, data = maintainer_author_net, sum) dup_edges &lt;- edges[edges[, 1] != edges[, 2], ] library(geomnet) ggplot(data = dup_edges, aes(from_id = from_id, to_id = to_id)) + geom_net(aes(linewidth = weight), layout.alg = &quot;kamadakawai&quot;, labelon = FALSE, directed = TRUE, show.legend = FALSE, ealpha = 1, ecolour = &quot;grey70&quot;, arrowsize = 0.1, size = 0.5 ) + theme_net() # https://smallstats.blogspot.jp/2012/12/loading-huge-graphs-with-igraph-and-r.html library(igraph) # 贡献矩阵 ctb_df &lt;- graph.data.frame(maintainer_author, directed = TRUE) vertex.attrs &lt;- list(name = unique(c(ctb_df$from_id, ctb_df$to_id))) edges &lt;- rbind( match(ctb_df$from_id, vertex.attrs$name), match(ctb_df$to_id, vertex.attrs$name) ) ctb_net &lt;- graph.empty(n = 0, directed = T) ctb_net &lt;- add.vertices(ctb_net, length(vertex.attrs$name), attr = vertex.attrs) ctb_net &lt;- add.edges(ctb_net, edges) 23.6 更新知多少 这节标题取其字面意思表达 CRAN 服务器的特殊日子 2012-10-29，那天 CRAN 更新了一大波 R 包，像一根擎天柱一样支撑这幅图！ update_pdb &lt;- as.data.frame(pdb[, c(&quot;Package&quot;, &quot;Published&quot;)], stringsAsFactors = FALSE) # 这天要更新的R包最多 sort(table(update_pdb[,&quot;Published&quot;]), decreasing = TRUE)[1] #&gt; 2012-10-29 #&gt; 127 ggplot(update_pdb, aes(as.Date(Published))) + geom_bar(color = &quot;skyblue4&quot;) + geom_line( data = data.frame( date = as.Date(c(&quot;2011-01-01&quot;, &quot;2012-10-20&quot;)), count = c(80, 100) ), aes(x = date, y = count), arrow = arrow(angle = 15, length = unit(0.15, &quot;inches&quot;)) ) + annotate(&quot;text&quot;, x = as.Date(&quot;2010-11-01&quot;), y = 75, label = &quot;(2012-10-29,130)&quot;) + scale_x_date(date_breaks = &quot;1 year&quot;, date_labels = &quot;%Y&quot;) + labs(x = &quot;Published Date&quot;, y = &quot;Count&quot;) + theme_minimal() 图 23.3: R 包更新历史 当日发布的R包，不论是新增还是更新之前发布的R包都视为最新版，当日之前的都是旧版本，它们可能存在已经修复的 BUG！这句子好奇怪是吧，因为很多 R 包要么托管在 Github 上，要么托管在 R-Forge 上开发，而 CRAN 上的版本除了发布日外，一般来讲都会落后。如图所示待更新的 R 包在日期上的分布，有的已经10来年没有更新了，最老的 R 包可以追溯到 2006-03-15，它是 coxrobust！！ 23.7 使用许可证 列举 R 社区使用的许可证及其区别和联系 R 开源还体现在许可证信息，顺便谈谈美国和中国技术封锁，开源社区可能面临的风险 社区主要使用 GPL 及其相关授权协议，因为 R 软件本身也是授权在 GPL-2 或 GPL-3 下 license_pdb &lt;- head(sort(table(pdb[, &quot;License&quot;]), decreasing = TRUE), 20) par(mar = c(2, 12, 0.5, 0)) plot(c(1, 1e1, 1e2, 1e3, 1e4), c(1, 5, 10, 15, 20), type = &quot;n&quot;,panel.first = grid(), ann = FALSE, log = &quot;x&quot;, axes = FALSE ) axis(1, at = c(1, 1e1, 1e2, 1e3, 1e4), labels = expression(1, 10^1, 10^2, 10^3, 10^4) ) text( y = seq(length(license_pdb)), x = 1, cex = 1, offset = 1, pos = 2, labels = names(license_pdb), xpd = TRUE ) text(1e3, 15, &quot;CRAN&quot;) segments(x0 = 1, y0 = seq(length(license_pdb)), x1 = license_pdb, y1 = seq(length(license_pdb)), col = &quot;lightblue&quot;, lwd = 4) 图 23.4: CRAN 上采用的发布协议 rforge_pdb &lt;- available.packages(repos = &quot;http://R-Forge.R-project.org&quot;) license_rforge_pdb &lt;- head(sort(table(rforge_pdb[, &quot;License&quot;]), decreasing = TRUE), 20) par(mar = c(2, 12, 0.5, 0)) plot(c(1, 1e1, 1e2, 1e3), seq(from = 1, to = 20,length.out = 4), type = &quot;n&quot;,panel.first = grid(), ann = FALSE, log = &quot;x&quot;, axes = FALSE ) axis(1, at = c(1, 1e1, 1e2, 1e3), labels = expression(1, 10^1, 10^2, 10^3) ) text( y = seq(length(license_rforge_pdb)), x = 1, cex = 1, offset = 1, pos = 2, labels = names(license_rforge_pdb), xpd = TRUE ) text(1e2, 15, &quot;R-Forge&quot;) segments(x0 = 1, y0 = seq(length(license_rforge_pdb)), x1 = license_rforge_pdb, y1 = seq(length(license_rforge_pdb)), lwd = 4, col = &quot;lightblue&quot;) 图 23.5: R-Forge 开发者采用的发布协议 改进的方向是含义相同的进行合并，这需要研究一下各个许可证，然后使用对比型条形图合并上面两个图 CRAN 会检测 R 包的授权，只有授权协议包含在数据库中的才可以在 CRAN 上发布 https://svn.r-project.org/R/trunk/share/licenses/license.db 23.8 R 包增长速度 # 抓取网页数据 library(rvest) library(dplyr) library(zoo) url &lt;- &quot;https://cran.r-project.org/web/packages/available_packages_by_date.html&quot; page &lt;- read_html(url) page %&gt;% html_node(&quot;table&quot;) %&gt;% html_table() %&gt;% mutate(count = rev(1:nrow(.))) %&gt;% mutate(Date = as.Date(Date)) %&gt;% mutate(Month = format(Date, format = &quot;%Y-%m&quot;)) %&gt;% group_by(Month) %&gt;% summarise(published = min(count)) %&gt;% mutate(Date = as.Date(as.yearmon(Month))) -&gt; pkgs # 计算自2013年以来R包增长速度 pkgs %&gt;% filter(Date &gt; as.Date(&quot;2012-12-31&quot;)) %&gt;% mutate(publishedGrowth = c(tail(.$published, -1), NA) / published) %&gt;% mutate(counter = 1:nrow(.)) -&gt; new_pkgs # 绘图 library(ggplot2) library(grid) gg &lt;- ggplot(pkgs, aes(x = Date, y = published)) + geom_line(size = 1.5) + scale_y_log10( breaks = c(0, 10, 100, 1000, 10000), labels = c(&quot;1&quot;, &quot;10&quot;, &quot;100&quot;, &quot;1.000&quot;, &quot;10.000&quot;) ) + labs( x = &quot;&quot;, y = &quot;# Packages (log)&quot;, title = &quot;Packages published on CRAN ever since&quot; ) + theme_minimal(base_size = 14, base_family = &quot;sans&quot;) + theme(panel.grid.major.x = element_blank()) + geom_hline(yintercept = 0, size = 1, colour = &quot;#535353&quot;) gg2 &lt;- ggplot(new_pkgs, aes(x = Date, y = published)) + geom_line(size = 1) + geom_line( data = new_pkgs, aes(y = (min(published) * 1.048^counter)), color = &quot;red&quot;, size = .7, linetype = 1 ) + annotate(&quot;segment&quot;, x = as.Date(&quot;2015-04-01&quot;), xend = as.Date(&quot;2015-08-01&quot;), y = 1000, yend = 1000, colour = &quot;red&quot;, size = 1 ) + annotate(&quot;text&quot;, x = as.Date(&quot;2016-12-01&quot;), y = 1000, label = &quot;4.6% growth estimation&quot;, size = 3.5 ) + scale_y_continuous( breaks = seq(from = 0, to = 12000, by = 2000), labels = seq(from = 0, to = 12000, by = 2000) ) + labs(y = &quot;# Packages&quot;, x = &quot;&quot;, subtitle = &quot;Packages published on CRAN since 2013&quot;) + theme_minimal( base_size = 11, base_family = &quot;sans&quot; ) + theme(panel.grid.major.x = element_blank()) + geom_hline(yintercept = 0, size = .6, colour = &quot;#535353&quot;) gg print(gg2, vp = viewport(.70, .31, .43, .43)) 23.9 选择 R 包 R 社区开发的 R 包实在太多了，重复造的轮子也很多，哪个轮子结实好用就选哪个，挑选合适的 R 包 install.packages(&quot;formattable&quot;) devtools::install_github(&quot;ropenscilabs/packagemetrics&quot;) library(formattable) library(packagemetrics) library(dplyr) address &lt;- sprintf(&quot;%s/web/packages/packages.rds&quot;, getOption(&quot;repos&quot;)[&quot;CRAN&quot;]) con &lt;- url(address, &quot;rb&quot;) pdb &lt;- as.data.frame(readRDS(gzcon(con)), stringsAsFactors = FALSE) close(con) packages &lt;- subset(pdb, Maintainer == maintainer(&quot;rmarkdown&quot;), select = &quot;Package&quot;) pd &lt;- apply(packages, 1, combine_metrics) %&gt;% data.table::rbindlist() %&gt;% select( package, published, dl_last_month, stars, forks, last_commit, depends_count, watchers ) %&gt;% mutate(last_commit = round(last_commit, 1)) pd[is.na(pd)] &lt;- &quot;&quot; formattable(pd, list( package = formatter(&quot;span&quot;, style = x ~ style(font.weight = &quot;bold&quot;) ), contributors = color_tile(&quot;white&quot;, &quot;#1CC2E3&quot;), depends_count = color_tile(&quot;white&quot;, &quot;#1CC2E3&quot;), reverse_count = color_tile(&quot;white&quot;, &quot;#1CC2E3&quot;), tidyverse_happy = formatter(&quot;span&quot;, style = x ~ style(color = ifelse(x, &quot;purple&quot;, &quot;white&quot;)), x ~ icontext(ifelse(x, &quot;glass&quot;, &quot;glass&quot;)) ), vignette = formatter(&quot;span&quot;, style = x ~ style(color = ifelse(x, &quot;green&quot;, &quot;white&quot;)), x ~ icontext(ifelse(x, &quot;ok&quot;, &quot;ok&quot;)) ), has_tests = formatter(&quot;span&quot;, style = x ~ style(color = ifelse(x, &quot;green&quot;, &quot;red&quot;)), x ~ icontext(ifelse(x, &quot;ok&quot;, &quot;remove&quot;)) ), dl_last_month = color_bar(&quot;#56A33E&quot;), forks = color_tile(&quot;white&quot;, &quot;#56A33E&quot;), stars = color_tile(&quot;white&quot;, &quot;#56A33E&quot;), last_commit = color_tile(&quot;#F06B13&quot;, &quot;white&quot;, na.rm = T) )) webshot::webshot(url = &quot;http://localhost:16977/session/viewhtml150c673821fc/index.html&quot;,file = &quot;figures/packages.png&quot;) 23.10 运行环境 xfun::session_info() #&gt; R Under development (unstable) (2020-02-04 r77771) #&gt; Platform: x86_64-pc-linux-gnu (64-bit) #&gt; Running under: Ubuntu 16.04.6 LTS #&gt; #&gt; Locale: #&gt; LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C #&gt; LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 #&gt; LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 #&gt; LC_PAPER=en_US.UTF-8 LC_NAME=C #&gt; LC_ADDRESS=C LC_TELEPHONE=C #&gt; LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C #&gt; #&gt; Package version: #&gt; assertthat_0.2.1 base64enc_0.1.3 BH_1.72.0.3 #&gt; bookdown_0.17 cli_2.0.1 colorspace_1.4-1 #&gt; compiler_4.0.0 crayon_1.3.4 curl_4.3 #&gt; digest_0.6.23 dplyr_0.8.4 ellipsis_0.3.0 #&gt; evaluate_0.14 fansi_0.4.1 farver_2.0.3 #&gt; ggplot2_3.2.1 glue_1.3.1 graphics_4.0.0 #&gt; grDevices_4.0.0 grid_4.0.0 gtable_0.3.0 #&gt; highr_0.8 htmltools_0.4.0 jsonlite_1.6.1 #&gt; knitr_1.26 labeling_0.3 lattice_0.20-38 #&gt; lazyeval_0.2.2 lifecycle_0.1.0 magrittr_1.5 #&gt; markdown_1.1 MASS_7.3.51.5 Matrix_1.2-18 #&gt; methods_4.0.0 mgcv_1.8.31 mime_0.9 #&gt; munsell_0.5.0 nlme_3.1.143 pillar_1.4.3 #&gt; pkgconfig_2.0.3 plogr_0.2.0 plyr_1.8.5 #&gt; purrr_0.3.3 R6_2.4.1 RColorBrewer_1.1.2 #&gt; Rcpp_1.0.3 reshape2_1.4.3 rlang_0.4.4 #&gt; rmarkdown_2.1 scales_1.1.0 splines_4.0.0 #&gt; stats_4.0.0 stringi_1.4.5 stringr_1.4.0 #&gt; tibble_2.1.3 tidyselect_1.0.0 tinytex_0.19 #&gt; tools_4.0.0 utf8_1.1.4 utils_4.0.0 #&gt; vctrs_0.2.2 viridisLite_0.3.0 withr_2.1.2 #&gt; xfun_0.12 yaml_2.2.1 其中 Orphaned 表示之前的R包维护者不愿意继续维护了，后来有人接手维护，Orphaned 表示这一类接盘侠↩︎ Statistical Modeling of Networks in R https://user2010.org/Invited/handcockuser2010.pdf↩︎ Network Analysis and Visualization with R and igraph https://kateto.net/networks-r-igraph with PDF↩︎ "],
["99-references.html", "参考文献", " 参考文献 "]
]
