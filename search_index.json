[
["index.html", "数据可视化与R语言 Data Visualization with R 欢迎 Why R 目标读者 获取帮助 发展历史 记号约定 运行环境", " 数据可视化与R语言 Data Visualization with R 黄湘云 2019-07-27 13:13:41 CST 欢迎 这本书还处于一个很早期的阶段 Why R GNU R 是发布在 GPL-2/3 下的开源自由软件，意味着只要你遵循该协议，就可以自由地获取、修改和发布R 源代码，R 本身的这种开源自由的属性，决定你可以免费地使用它。《The Art of R Programming》的作者 Norm Matloff 给出使用 R 语言的四个优势：它是统计学家开发的，也是为统计学家打造的；内建的矩阵类型和矩阵操作非常高效；不管是来自基础 R 还是 CRAN 上的绘图包，都提供强大的绘图功能；还有优秀的并行能力1，最近他更是在数据科学中全面比较了 R 与 Python2。关于 R 语言和 Python 语言的对比，网络上充斥着很多的文章，除了赞扬，还有表示反对的声音，如 R语言采用的对 GPL 协议3，甚至有人列举了逃离 R 语言阵营的10大上榜理由4，datacamp 提供了一份较为完整的对比图，仅供参考5。如果你是学统计的学生或者数据分析师，我都建议你先学习 R6，如果你是社会科学的学生和研究者， R 社区开发了 GUI 工具，如 Rcmdr 和 rattle，还有基于 Shiny 的分析工具 radiant 和类似 SPSS 的 JASP。 R 语言比较遭人诟病的大概有： R 包总体数量已达到 15000+，年度增长速度大约在 4.6% 左右，很多 R 包都在重复造轮子，且 R 包之间依赖关系非常复杂。若与 Python 作一个对比，所有的 R 包和 Python 模块必须处于活跃维护，拥有大批粉丝，维护者在社区内享有声誉，有厂子或科研经费支持。我们不打嘴仗，不下结论，只做对比，不完善之处还请大家指出并补充，见表 0.1。 每个 Base R 包内的函数非常多，参数也非常多，功能涉及方方面面，初学者学习起来难度非常大！数据处理和可视化常用基本包最流行的 tidyverse 系列和基础 R 系统存在很多不一致，在不清楚的情况下很难掌握，而陷于已有的函数不能自拔！ R 是面向对象的程序设计语言，是解释性的语言，也是函数式编程语言，包含的程序设计风格非常多，仅面向对象的设计就有 S3、 S4、 RC、 R5 和 R6。每一个操作都是函数调用，一切皆是对象的环境和闭包概念简洁又复杂。 R 内置的数据结构非常多，原子类型的有字符、布尔、整型、复数、双精度浮点、单精度浮点等，此外常见的还有数据框、列表。每个特定的领域往往还有特殊的类型，如时间序列 ts、zoo 等， 空间对象 sp、 raster 和 sf 等。 深入学习 R 实现的统计模型，如 lm、glm 等，你可能会发现统计学家的程序设计思维如此难懂。 Thomas Lumley, “R Fundamentals and Programming Techniques” https://faculty.washington.edu/tlumley/Rcourse/R-fundamentals.pdf 表 0.1: R 与 Python 常用模块对照表 比较内容 具体范围 R 包 Python 模块 数据获取 本地、数据库、远程 内置，RCurl、XML、rvest、data.table、 odbc scrapy 数据清理 正则表达式 内置，stringi、stringr、tidyr re 数据聚合 SQL支持的所有操作 内置，dplyr、purrr、dbplyr、sparklyr Numpy、Scipy、Pandas 数据分析 统计推断的所有方法 内置，lme4、rstan、mxnet、xgoost、 tensorflow xgboost、scikit-learn、tensorflow、mxnet 数据展示 数据可视化 内置，ggplot2、plotly matplotlib、bokeh、plotly 数据报告 网页文档、幻灯片 rmarkdown、bookdown、blogdown 数据落地 模型部署，调优，维护 plumber、opencpu、fiery 目标读者 本书起源于自己的学习笔记，侧重统计图形，当然也包括在制作统计图形之前的数据导入和ETL操作，后续的数据可视化。本书的目标可以是接触过 R 语言的读者，也可以是零基础者，书的内容侧重数据处理和可视化分析，数据建模的部分比较少。 获取帮助 R 语言官网给出了一份如何获取帮助的指导 https://www.r-project.org/help.html，RStudio 公司也总结了一份 Getting Help with R，又及 https://blog.rsquaredacademy.com/getting-help-in-r-updated/ 发展历史 GNU R 最初由 Ross Ihaka 和 Robert Gentleman 开发，它脱胎于 S 语言，S 语言形成于大名鼎鼎的美国贝尔实验室，距今已有40多年的历史了7，R语言的前世今生8，Ross Ihaka 总结了过去的经验，展望了 R 语言未来发展的方向9。 记号约定 写作风格，R 包名称都加粗表示，如 bookdown， rmarkdown 等，软件、编程语言名称保持原样，如 TinyTeX，LyX，TeXLive，R，Python，Stan，C++，SQL等，在代码块中，我们不使用R&gt;或+，代码输出结果用#&gt;注释。knitr (Xie 2015)、 bookdown (Xie 2016)、 Pandoc 和 TinyTeX ，请使用 XeLaTeX 编译这本书，等宽字体为 inconsolata 默认的文本字体为 Times 运行环境 重现书籍本节内容需要的 R 包列表如下 xfun::session_info(c(&quot;rmarkdown&quot;, &quot;bookdown&quot;)) #&gt; R version 3.6.1 (2019-07-05) #&gt; Platform: x86_64-pc-linux-gnu (64-bit) #&gt; Running under: Debian GNU/Linux 10 (buster) #&gt; #&gt; Locale: #&gt; LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C #&gt; LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 #&gt; LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 #&gt; LC_PAPER=en_US.UTF-8 LC_NAME=C #&gt; LC_ADDRESS=C LC_TELEPHONE=C #&gt; LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C #&gt; #&gt; Package version: #&gt; base64enc_0.1.3 bookdown_0.12 digest_0.6.20 evaluate_0.14 #&gt; glue_1.3.1 graphics_3.6.1 grDevices_3.6.1 highr_0.8 #&gt; htmltools_0.3.6 jsonlite_1.6 knitr_1.23 magrittr_1.5 #&gt; markdown_1.0 methods_3.6.1 mime_0.7 Rcpp_1.0.2 #&gt; rmarkdown_1.14 stats_3.6.1 stringi_1.4.3 stringr_1.4.0 #&gt; tinytex_0.14 tools_3.6.1 utils_3.6.1 xfun_0.8 #&gt; yaml_2.2.0 #&gt; #&gt; Pandoc version: 2.7.3 本书要求 R 软件版本 3.6.1 因为书中涉及 barplot 新增的公式方法，新增多维数组操作函数 asplit， axis 函数的 gap.axis ，新增 hcl.colors 函数等，完整列表见官网 What’s New? 书籍同时使用 bookdown.org 和 netlify 部署，网址分别是 https://bookdown.org/xiangyun/RGraphics/ 和 https://r-graphics.netlify.com/ 参考文献 "],
["preface.html", "前言 关于本书 本书结构 关于作者", " 前言 关于本书 这里写每章的主要内容介绍 本书结构 关于作者 热心开源事业，统计之都副主编，经常混迹于统计之都论坛、Github 和爆栈网。个人主页 https://www.xiangyunhuang.com.cn/ "],
["setup-startup.html", "第 1 章 安装与配置 1.1 仓库安装 1.2 源码安装 1.3 忍者安装 1.4 配置 1.5 命令行参数", " 第 1 章 安装与配置 主要参考 R-admin 1.1 仓库安装 1.1.1 Ubuntu 安装 openssh zsh 和 Git sudo apt-get install zsh openssh-server sudo add-apt-repository -y ppa:git-core/ppa sudo apt update &amp;&amp; sudo apt install git sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 只考虑最新的 Ubuntu 18.04 因为本书写成的时候，该版本应该已经大规模使用了，默认版本的安装和之前版本的安装就不再展示了。安装最新版 R-3.5.x，无论安装哪个版本，都要先导入密钥 sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv E084DAB9 Ubuntu 14.04.5 提供的默认版本 R 3.0.2，安装 R 3.5.x 系列之前的版本，如 R 3.4.4 sudo apt-add-repository -y &quot;deb http://cran.rstudio.com/bin/linux/ubuntu `lsb_release -cs`/&quot; sudo apt-get install r-base-dev 添加完仓库后，都需要更新源sudo apt-get update，安装 R 3.5.x 系列最新版 sudo apt-add-repository -y &quot;deb https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/linux/ubuntu trusty-cran35/&quot; Ubuntu 16.04.5 提供的默认版本 R 3.4.4，这是 R 3.4.x 系列的最新版，安装目前最新的 R 3.5.x 版本需要 sudo apt-add-repository -y &quot;deb https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/linux/ubuntu xenial-cran35/&quot; Ubuntu 18.04.1 提供的默认版本 R 3.4.4，安装目前的最新版本需要 sudo apt-add-repository -y &quot;deb https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/linux/ubuntu bionic-cran35/&quot; 接下来安装 R，详细安装指导见 CRAN 官网。 sudo apt-get install -y r-base-dev Michael Rutter 维护了编译好的二进制版本 https://launchpad.net/~marutter，比如 rstan 包可以通过安装 r-cran-rstan 完成 # R packages for Ubuntu LTS. Based on CRAN Task Views. sudo add-apt-repository -y ppa:marutter/c2d4u3.5 sudo apt-get install r-cran-rstan 1.1.2 CentOS 同样适用于 Fedora 安装指导10 1.2 源码安装 1.2.1 Ubuntu 首先启用源码仓库，否则执行 sudo apt-get build-dep r-base 会报如下错误 E: You must put some &#39;source&#39; URIs in your sources.list sudo sed -i -- &#39;s/#deb-src/deb-src/g&#39; /etc/apt/sources.list &amp;&amp; sudo sed -i -- &#39;s/# deb-src/deb-src/g&#39; /etc/apt/sources.list sudo apt-get update 安装编译 R 所需的系统依赖 sudo apt-get build-dep r-base-dev 编译安装 R ./configure make &amp;&amp; make install 自定义编译选项 ./configure --help 1.2.2 CentOS 基于 CentOS 7 和 GCC 4.8.5，参考 R-admin 手册 下载源码包 最新发布的稳定版 curl -fLo ./R-latest.tar.gz https://mirrors.tuna.tsinghua.edu.cn/CRAN/src/base/R-latest.tar.gz % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 10 28.7M 10 3232k 0 0 107k 0 0:04:34 0:00:30 0:04:04 118k 安装依赖 sudo yum install -y yum-utils epel-release &amp;&amp; sudo yum-builddep R-devel sudo dnf update &amp;&amp; sudo dnf builddep R-devel # Fedora 30 解压配置 mkdir R-latest &amp;&amp; tar -xzf ./R-latest.tar.gz -C ./R-latest &amp;&amp; cd R-3.5.2 ./configure --enable-R-shlib --enable-byte-compiled-packages \\ --enable-BLAS-shlib --enable-memory-profiling R is now configured for x86_64-pc-linux-gnu Source directory: . Installation directory: /usr/local C compiler: gcc -std=gnu99 -g -O2 Fortran 77 compiler: gfortran -g -O2 Default C++ compiler: g++ -g -O2 C++98 compiler: g++ -std=gnu++98 -g -O2 C++11 compiler: g++ -std=gnu++11 -g -O2 C++14 compiler: C++17 compiler: Fortran 90/95 compiler: gfortran -g -O2 Obj-C compiler: gcc -g -O2 -fobjc-exceptions Interfaces supported: X11, tcltk External libraries: readline, curl Additional capabilities: PNG, JPEG, TIFF, NLS, cairo, ICU Options enabled: shared R library, shared BLAS, R profiling, memory profiling Capabilities skipped: Options not enabled: Recommended packages: yes 编译安装 make -j 2 all sudo make install BLAS 加持（可选） BLAS 对于加快矩阵计算至关重要，编译 R 带 BLAS 支持，添加 OpenBLAS 支持 --with-blas=\"-lopenblas\" 或 ATLAS 支持 --with-blas=\"-L/usr/lib64/atlas -lsatlas\" sudo yum install -y openblas openblas-threads openblas-openmp ./configure --enable-R-shlib --enable-byte-compiled-packages \\ --enable-BLAS-shlib --enable-memory-profiling \\ --with-blas=&quot;-lopenblas&quot; R is now configured for x86_64-pc-linux-gnu Source directory: . Installation directory: /usr/local C compiler: gcc -std=gnu99 -g -O2 Fortran 77 compiler: gfortran -g -O2 Default C++ compiler: g++ -g -O2 C++98 compiler: g++ -std=gnu++98 -g -O2 C++11 compiler: g++ -std=gnu++11 -g -O2 C++14 compiler: C++17 compiler: Fortran 90/95 compiler: gfortran -g -O2 Obj-C compiler: gcc -g -O2 -fobjc-exceptions Interfaces supported: X11, tcltk External libraries: readline, **BLAS(OpenBLAS)**, curl Additional capabilities: PNG, JPEG, TIFF, NLS, cairo, ICU Options enabled: shared R library, shared BLAS, R profiling, memory profiling Capabilities skipped: Options not enabled: Recommended packages: yes 配置成功的标志，如 OpenBLAS checking for dgemm_ in -lopenblas... yes checking whether double complex BLAS can be used... yes checking whether the BLAS is complete... yes ATLAS 加持 sudo yum install -y atlas ./configure --enable-R-shlib --enable-byte-compiled-packages \\ --enable-BLAS-shlib --enable-memory-profiling \\ --with-blas=&quot;-L/usr/lib64/atlas -lsatlas&quot; R is now configured for x86_64-pc-linux-gnu Source directory: . Installation directory: /usr/local C compiler: gcc -std=gnu99 -g -O2 Fortran 77 compiler: gfortran -g -O2 Default C++ compiler: g++ -g -O2 C++98 compiler: g++ -std=gnu++98 -g -O2 C++11 compiler: g++ -std=gnu++11 -g -O2 C++14 compiler: C++17 compiler: Fortran 90/95 compiler: gfortran -g -O2 Obj-C compiler: gcc -g -O2 -fobjc-exceptions Interfaces supported: X11, tcltk External libraries: readline, **BLAS(generic)**, curl Additional capabilities: PNG, JPEG, TIFF, NLS, cairo, ICU Options enabled: shared R library, shared BLAS, R profiling, memory profiling Capabilities skipped: Options not enabled: Recommended packages: yes ATLAS 配置成功 checking for dgemm_ in -L/usr/lib64/atlas -lsatlas... yes checking whether double complex BLAS can be used... yes checking whether the BLAS is complete... yes 后续步骤同上 1.3 忍者安装 从源码自定义安装：加速 Intel MKL 和 大文件支持 https://software.intel.com/en-us/articles/using-intel-mkl-with-r 1.4 配置 1.4.1 初始会话 .Rprofile .Rprofile 文件位于 ~/ 目录下或者 R 项目的根目录下 查看帮助 ?.Rprofile 更多配置设置 startup 1.4.2 环境变量 .Renviron .Renviron 文件位于 ~/ 目录下 1.4.3 编译选项 Makevars Makevars 文件位于 ~/.R/ 目录下 1.5 命令行参数 commandArgs 从终端命令行中传递参数 rdoc 高亮 R 帮助文档中的 R 函数、关键字 NULL。启用需要在R控制台中执行 rdoc::use_rdoc() radian 代码自动补全和语法高亮，进入 R 控制台，终端中输入radian docopt 提供R命令行工具，如 littler 包，getopt 从终端命令行接受参数 optparse 命令行选项参数的解析器 安装完 R-littler R-littler-examples (centos) 或 littler r-cran-littler (ubuntu) 后，执行 # centos sudo ln -s /usr/lib64/R/library/littler/examples/install.r /usr/bin/install.r sudo ln -s /usr/lib64/R/library/littler/examples/install2.r /usr/bin/install2.r sudo ln -s /usr/lib64/R/library/littler/examples/installGithub.r /usr/bin/installGithub.r sudo ln -s /usr/lib64/R/library/littler/examples/testInstalled.r /usr/bin/testInstalled.r # ubuntu sudo ln -s /usr/lib/R/site-library/littler/examples/install.r /usr/bin/install.r sudo ln -s /usr/lib/R/site-library/littler/examples/install2.r /usr/bin/install2.r sudo ln -s /usr/lib/R/site-library/littler/examples/installGithub.r /usr/bin/installGithub.r sudo ln -s /usr/lib/R/site-library/littler/examples/testInstalled.r /usr/bin/testInstalled.r 这样可以载终端中安装 R 包了 install.r docopt #!/usr/bin/env Rscript # 安装 optparse 提供更加灵活的传参方式 # 也可参考 littler https://github.com/eddelbuettel/littler # if(&quot;optparse&quot; %in% .packages(TRUE)) install.packages(&#39;optparse&#39;,repos = &quot;https://cran.rstudio.com&quot;) # https://cran.r-project.org/doc/manuals/R-intro.html#Invoking-R-from-the-command-line # http://www.cureffi.org/2014/01/15/running-r-batch-mode-linux/ args = commandArgs(trailingOnly=TRUE) # 函数功能：在浏览器中同时打开多个 PDF 文档 open_pdf &lt;- function(pdf_path = &quot;./figures/&quot;, n = 1) { # pdf_path: PDF文件所在目录 # n: 默认打开1个PDF文档 # PDF文档目录 pdfs &lt;- list.files(pdf_path, pattern = &#39;\\\\.pdf$&#39;) # PDF 文档路径 path_to_pdfs &lt;- paste(pdf_path, pdfs, sep = .Platform$file.sep) # 打开 PDF 文档 invisible(lapply(head(path_to_pdfs, n), browseURL)) } open_pdf(pdf_path, n = args[1]) # 使用： Rscript --vanilla code/batch-open-pdf.R 20 "],
["dm-import-export.html", "第 2 章 数据搬运工 2.1 导入数据 2.2 其它数据格式 2.3 导入大数据集 2.4 从数据库导入 2.5 批量导入数据 2.6 批量导出数据 2.7 导出数据 2.8 运行环境", " 第 2 章 数据搬运工 导入数据与导出数据，各种数据格式，数据库 2.1 导入数据 Base R 针对不同的数据格式文件，提供了大量的数据导入和导出函数，不愧是专注数据分析20余年的优秀统计软件。 除了函数 write.ftable 和 read.ftable 来自 stats 包，都来自 base 和 utils 包 # 当前环境的搜索路径 searchpaths() #&gt; [1] &quot;.GlobalEnv&quot; &quot;/usr/lib/R/library/stats&quot; #&gt; [3] &quot;/usr/lib/R/library/graphics&quot; &quot;/usr/lib/R/library/grDevices&quot; #&gt; [5] &quot;/usr/lib/R/library/utils&quot; &quot;/usr/lib/R/library/datasets&quot; #&gt; [7] &quot;/usr/lib/R/library/methods&quot; &quot;Autoloads&quot; #&gt; [9] &quot;/usr/lib/R/library/base&quot; # 返回匹配结果及其所在路径的编号 apropos(&quot;^(read|write)&quot;, where = TRUE, mode = &quot;function&quot;) #&gt; 5 5 9 #&gt; &quot;read.csv&quot; &quot;read.csv2&quot; &quot;read.dcf&quot; #&gt; 5 5 5 #&gt; &quot;read.delim&quot; &quot;read.delim2&quot; &quot;read.DIF&quot; #&gt; 5 2 5 #&gt; &quot;read.fortran&quot; &quot;read.ftable&quot; &quot;read.fwf&quot; #&gt; 5 5 9 #&gt; &quot;read.socket&quot; &quot;read.table&quot; &quot;readBin&quot; #&gt; 9 5 9 #&gt; &quot;readChar&quot; &quot;readCitationFile&quot; &quot;readline&quot; #&gt; 9 9 9 #&gt; &quot;readLines&quot; &quot;readRDS&quot; &quot;readRenviron&quot; #&gt; 9 5 5 #&gt; &quot;write&quot; &quot;write.csv&quot; &quot;write.csv2&quot; #&gt; 9 2 5 #&gt; &quot;write.dcf&quot; &quot;write.ftable&quot; &quot;write.socket&quot; #&gt; 5 9 9 #&gt; &quot;write.table&quot; &quot;writeBin&quot; &quot;writeChar&quot; #&gt; 9 #&gt; &quot;writeLines&quot; 2.1.1 scan scan(file = &quot;&quot;, what = double(), nmax = -1, n = -1, sep = &quot;&quot;, quote = if(identical(sep, &quot;\\n&quot;)) &quot;&quot; else &quot;&#39;\\&quot;&quot;, dec = &quot;.&quot;, skip = 0, nlines = 0, na.strings = &quot;NA&quot;, flush = FALSE, fill = FALSE, strip.white = FALSE, quiet = FALSE, blank.lines.skip = TRUE, multi.line = TRUE, comment.char = &quot;&quot;, allowEscapes = FALSE, fileEncoding = &quot;&quot;, encoding = &quot;unknown&quot;, text, skipNul = FALSE) 首先让我们用 cat 函数创建一个练习数据集 ex.data cat(&quot;TITLE extra line&quot;, &quot;2 3 5 7&quot;, &quot;11 13 17&quot;) #&gt; TITLE extra line 2 3 5 7 11 13 17 cat(&quot;TITLE extra line&quot;, &quot;2 3 5 7&quot;, &quot;11 13 17&quot;, file = &quot;data/ex.data&quot;, sep = &quot;\\n&quot;) 以此练习数据集，介绍 scan 函数最常用的参数 scan(&quot;data/ex.data&quot;) #&gt; Error in scan(&quot;data/ex.data&quot;): scan() expected &#39;a real&#39;, got &#39;TITLE&#39; 从上面的报错信息，我们发现 scan 函数只能读取同一类型的数据，如布尔型 logical， 整型 integer，数值型 numeric(double)， 复数型 complex，字符型 character，raw 和列表 list。所以我们设置参数 skip = 1 把第一行跳过，就成功读取了数据 scan(&quot;data/ex.data&quot;, skip = 1) #&gt; [1] 2 3 5 7 11 13 17 如果设置参数 quiet = TRUE 就不会报告读取的数据量 scan(&quot;data/ex.data&quot;, skip = 1, quiet = TRUE) #&gt; [1] 2 3 5 7 11 13 17 参数 nlines = 1 表示只读取一行数据 scan(&quot;data/ex.data&quot;, skip = 1, nlines = 1) # only 1 line after the skipped one #&gt; [1] 2 3 5 7 默认参数 flush = TRUE 表示读取最后一个请求的字段后，刷新到行尾，下面对比一下读取的结果 scan(&quot;data/ex.data&quot;, what = list(&quot;&quot;, &quot;&quot;, &quot;&quot;)) # flush is F -&gt; read &quot;7&quot; #&gt; Warning in scan(&quot;data/ex.data&quot;, what = list(&quot;&quot;, &quot;&quot;, &quot;&quot;)): number of items #&gt; read is not a multiple of the number of columns #&gt; [[1]] #&gt; [1] &quot;TITLE&quot; &quot;2&quot; &quot;7&quot; &quot;17&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;extra&quot; &quot;3&quot; &quot;11&quot; &quot;&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;line&quot; &quot;5&quot; &quot;13&quot; &quot;&quot; scan(&quot;data/ex.data&quot;, what = list(&quot;&quot;, &quot;&quot;, &quot;&quot;), flush = TRUE) #&gt; [[1]] #&gt; [1] &quot;TITLE&quot; &quot;2&quot; &quot;11&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;extra&quot; &quot;3&quot; &quot;13&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;line&quot; &quot;5&quot; &quot;17&quot; 临时文件 ex.data 用完了，我们调用 unlink 函数将其删除，以免留下垃圾文件 unlink(&quot;data/ex.data&quot;) # tidy up 2.1.2 read.table read.table(file, header = FALSE, sep = &quot;&quot;, quote = &quot;\\&quot;&#39;&quot;, dec = &quot;.&quot;, numerals = c(&quot;allow.loss&quot;, &quot;warn.loss&quot;, &quot;no.loss&quot;), row.names, col.names, as.is = !stringsAsFactors, na.strings = &quot;NA&quot;, colClasses = NA, nrows = -1, skip = 0, check.names = TRUE, fill = !blank.lines.skip, strip.white = FALSE, blank.lines.skip = TRUE, comment.char = &quot;#&quot;, allowEscapes = FALSE, flush = FALSE, stringsAsFactors = default.stringsAsFactors(), fileEncoding = &quot;&quot;, encoding = &quot;unknown&quot;, text, skipNul = FALSE) read.csv(file, header = TRUE, sep = &quot;,&quot;, quote = &quot;\\&quot;&quot;, dec = &quot;.&quot;, fill = TRUE, comment.char = &quot;&quot;, ...) read.csv2(file, header = TRUE, sep = &quot;;&quot;, quote = &quot;\\&quot;&quot;, dec = &quot;,&quot;, fill = TRUE, comment.char = &quot;&quot;, ...) read.delim(file, header = TRUE, sep = &quot;\\t&quot;, quote = &quot;\\&quot;&quot;, dec = &quot;.&quot;, fill = TRUE, comment.char = &quot;&quot;, ...) read.delim2(file, header = TRUE, sep = &quot;\\t&quot;, quote = &quot;\\&quot;&quot;, dec = &quot;,&quot;, fill = TRUE, comment.char = &quot;&quot;, ...) 变量名是不允许以下划线开头的，同样在数据框里，列名也不推荐使用下划线开头。默认情况下，read.table 都会通过参数 check.names 检查列名的有效性，该参数实际调用了函数 make.names 去检查。如果想尽量保持数据集原来的样子可以设置参数 check.names = FALSE, stringsAsFactors = FALSE。 默认情形下，read.table 还会将字符串转化为因子变量，这是 R 的历史原因，作为一门统计学家的必备语言，在统计模型中，字符常用来描述类别，而类别变量在 R 环境中常用因子类型来表示，而且大量内置的统计模型也是将它们视为因子变量，如 lm 、glm 等 dat1 = read.table(header = TRUE, check.names = TRUE, text = &quot; _a _b _c 1 2 a1 3 4 a2 &quot;) dat1 #&gt; X_a X_b X_c #&gt; 1 1 2 a1 #&gt; 2 3 4 a2 dat2 = read.table(header = TRUE, check.names = FALSE, text = &quot; _a _b _c 1 2 a1 3 4 a2 &quot;) dat2 #&gt; _a _b _c #&gt; 1 1 2 a1 #&gt; 2 3 4 a2 dat3 = read.table(header = TRUE, check.names = FALSE, stringsAsFactors = FALSE, text = &quot; _a _b _c 1 2 a1 3 4 a2 &quot;) dat3 #&gt; _a _b _c #&gt; 1 1 2 a1 #&gt; 2 3 4 a2 2.1.3 readLines readLines(con = stdin(), n = -1L, ok = TRUE, warn = TRUE, encoding = &quot;unknown&quot;, skipNul = FALSE) 让我们折腾一波，读进来又写出去，只有 R 3.5.3 以上才能保持原样的正确输入输出，因为这里有一个之前版本包含的 BUG writeLines(readLines(system.file(&quot;DESCRIPTION&quot;, package = &quot;splines&quot;)), &quot;data/DESCRIPTION&quot;) # 比较一下 identical( readLines(system.file(&quot;DESCRIPTION&quot;, package = &quot;splines&quot;)), readLines(&quot;data/DESCRIPTION&quot;) ) #&gt; [1] TRUE 这次我们创建一个真的临时文件，因为重新启动 R 这个文件和文件夹就没有了，回收掉了 fil &lt;- tempfile(fileext = &quot;.data&quot;) cat(&quot;TITLE extra line&quot;, &quot;2 3 5 7&quot;, &quot;&quot;, &quot;11 13 17&quot;, file = fil, sep = &quot;\\n&quot;) fil #&gt; [1] &quot;/tmp/RtmpLmW61g/file486bd74aa1.data&quot; 设置参数 n = -1 表示将文件 fil 的内容从头读到尾 readLines(fil, n = -1) #&gt; [1] &quot;TITLE extra line&quot; &quot;2 3 5 7&quot; &quot;&quot; #&gt; [4] &quot;11 13 17&quot; 作为拥有良好习惯的 R 用户，这种垃圾文件最好用后即焚 unlink(fil) # tidy up 再举个例子，我们创建一个新的临时文件 fil，文件内容只有 cat(&quot;123\\nabc&quot;) #&gt; 123 #&gt; abc fil &lt;- tempfile(&quot;test&quot;) cat(&quot;123\\nabc\\n&quot;, file = fil, append = TRUE) fil #&gt; [1] &quot;/tmp/RtmpLmW61g/test4834174019&quot; readLines(fil) #&gt; [1] &quot;123&quot; &quot;abc&quot; 这次读取文件的过程给出了警告，原因是 fil 没有以空行结尾，warn = TRUE 表示这种情况要给出警告，如果设置参数 warn = FALSE 就没有警告。我们还是建议大家尽量遵循规范。 再举一个例子，从一个连接读取数据，建立连接的方式有很多，参见 ?file，下面设置参数 blocking con &lt;- file(fil, &quot;r&quot;, blocking = FALSE) readLines(con) #&gt; [1] &quot;123&quot; &quot;abc&quot; cat(&quot; def\\n&quot;, file = fil, append = TRUE) readLines(con) #&gt; [1] &quot; def&quot; # 关闭连接 close(con) # 清理垃圾文件 unlink(fil) 2.1.4 readRDS 序列化数据操作，Mark Klik 开发的 fst 和 Travers Ching 开发的 qs， Hadley Wickham 开发的 feather 包实现跨语言环境快速的读写数据 表 2.1: fst 序列化数据框对象性能比较 BaseR、 data.table 和 feather11 Method Format Time (ms) Size (MB) Speed (MB/s) N readRDS bin 1577 1000 633 112 saveRDS bin 2042 1000 489 112 fread csv 2925 1038 410 232 fwrite csv 2790 1038 358 241 read_feather bin 3950 813 253 112 write_feather bin 1820 813 549 112 read_fst bin 457 303 2184 282 write_fst bin 314 303 3180 291 目前比较好的是 qs 和 fst 包 2.2 其它数据格式 来自其它格式的数据形式，如 JSON、XML、YAML 需要转化清理成 R 中数据框的形式 data.frame Data Rectangling with jq Mongolite User Manual introduction to using MongoDB with the mongolite client in R jsonlite 读取 *.json 格式的文件，jsonlite::write_json 函数将 R对象保存为 JSON 文件，jsonlite::fromJSON 将 json 字符串或文件转化为 R 对象，jsonlite::toJSON 函数正好与之相反 library(jsonlite) # 从 json 格式的文件导入 # jsonlite::read_json(path = &quot;path/to/filename.json&quot;) # A JSON array of primitives json &lt;- &#39;[&quot;Mario&quot;, &quot;Peach&quot;, null, &quot;Bowser&quot;]&#39; # 简化为原子向量atomic vector fromJSON(json) #&gt; [1] &quot;Mario&quot; &quot;Peach&quot; NA &quot;Bowser&quot; # 默认返回一个列表 fromJSON(json, simplifyVector = FALSE) #&gt; [[1]] #&gt; [1] &quot;Mario&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;Peach&quot; #&gt; #&gt; [[3]] #&gt; NULL #&gt; #&gt; [[4]] #&gt; [1] &quot;Bowser&quot; yaml 包读取 *.yml 格式文件，返回一个列表，yaml::write_yaml 函数将 R 对象写入 yaml 格式 library(yaml) yaml::read_yaml(file = &#39;_bookdown.yml&#39;) #&gt; $delete_merged_file #&gt; [1] TRUE #&gt; #&gt; $language #&gt; $language$label #&gt; $language$label$fig #&gt; [1] &quot;图 &quot; #&gt; #&gt; $language$label$tab #&gt; [1] &quot;表 &quot; #&gt; #&gt; #&gt; $language$ui #&gt; $language$ui$edit #&gt; [1] &quot;编辑&quot; #&gt; #&gt; $language$ui$chapter_name #&gt; [1] &quot;第 &quot; &quot; 章&quot; #&gt; #&gt; #&gt; #&gt; $output_dir #&gt; [1] &quot;_book&quot; #&gt; #&gt; $new_session #&gt; [1] TRUE #&gt; #&gt; $before_chapter_script #&gt; [1] &quot;_common.R&quot; #&gt; #&gt; $rmd_files #&gt; [1] &quot;index.Rmd&quot; &quot;preface.Rmd&quot; &quot;dm-import-export.Rmd&quot; #&gt; [4] &quot;dm-base-r.Rmd&quot; &quot;dm-dplyr.Rmd&quot; &quot;99-references.Rmd&quot; 表 2.2: 导入来自其它数据分析软件产生的数据集 统计软件 R函数 R包 ERSI ArcGIS read.shapefile shapefiles Matlab readMat R.matlab minitab read.mtp foreign SAS (permanent data) read.ssd foreign SAS (XPORT format) read.xport foreign SPSS read.spss foreign Stata read.dta foreign Systat read.systat foreign Octave read.octave foreign 表 2.3: 导入来自其它格式的数据集 文件格式 R函数 R包 列联表数据 read.ftable stats 二进制数据 readBin base 字符串数据 readChar base 剪贴板数据 readClipboard utils read.dcf 函数读取 Debian 控制格式文件，这种类型的文件以人眼可读的形式在存储数据，如 R 包的 DESCRIPTION 文件或者包含所有 CRAN 上 R 包描述的文件 https://cran.r-project.org/src/contrib/PACKAGES x &lt;- read.dcf(file = system.file(&quot;DESCRIPTION&quot;, package = &quot;splines&quot;), fields = c(&quot;Package&quot;, &quot;Version&quot;, &quot;Title&quot;)) x #&gt; Package Version Title #&gt; [1,] &quot;splines&quot; &quot;3.6.1&quot; &quot;Regression Spline Functions and Classes&quot; 最后要提及拥有瑞士军刀之称的 rio 包，它集合了当前 R 可以读取的所有统计分析软件导出的数据。 2.3 导入大数据集 在不使用数据库的情况下，从命令行导入大数据集，如几百 M 或几个 G 的 csv 文件。利用 data.table 包的 fread 去读取 https://stackoverflow.com/questions/1727772/ 2.4 从数据库导入 Hands-On Programming with R 数据读写章节12 以及 R, Databases and Docker 将大量的 txt 文本存进 MySQL 数据库中，通过操作数据库来聚合文本，极大降低内存消耗13，而 ODBC 与 DBI 包是其它数据库接口的基础，knitr 提供了一个支持 SQL 代码的引擎，它便是基于 DBI，因此可以在 R Markdown 文档中直接使用 SQL 代码块14。这里制作一个归纳表格，左边数据库右边对应其 R 接口，两边都包含链接，如表 2.4 所示 表 2.4: 数据库接口 数据库 官网 R接口 开发仓 MySQL https://www.mysql.com/ RMySQL https://github.com/r-dbi/RMySQL SQLite https://www.sqlite.org RSQLite https://github.com/r-dbi/RSQLite PostgreSQL https://www.postgresql.org/ RPostgres https://github.com/r-dbi/RPostgres MariaDB https://mariadb.org/ RMariaDB https://github.com/r-dbi/RMariaDB 2.4.1 PostgreSQL odbc 可以支持很多数据库，下面以连接 PostgreSQL 数据库为例介绍其过程 首先在某台机器上，拉取 PostgreSQL 的 Docker 镜像 docker pull postgres 在 Docker 上运行 PostgreSQL，主机端口号 8181 映射给数据库 PostgreSQL 的默认端口号 5432（或其它你的 DBA 分配给你的端口） docker run --name psql -d -p 8181:5432 -e ROOT=TRUE \\ -e USER=xiangyun -e PASSWORD=cloud postgres 在主机 Ubuntu 上配置 sudo apt-get install unixodbc unixodbc-dev odbc-postgresql 端口 5432 是分配给 PostgreSQL 的默认端口，host 可以是云端的地址，如 你的亚马逊账户下的 PostgreSQL 数据库地址 &lt;ec2-54-83-201-96.compute-1.amazonaws.com&gt;，也可以是本地局域网IP地址，如&lt;192.168.1.200&gt;。通过参数 dbname 连接到指定的 PostgreSQL 数据库，如 Heroku，这里作为演示就以默认的数据库 postgres 为例 查看配置系统文件路径 odbcinst -j unixODBC 2.3.6 DRIVERS............: /etc/odbcinst.ini SYSTEM DATA SOURCES: /etc/odbc.ini FILE DATA SOURCES..: /etc/ODBCDataSources USER DATA SOURCES..: /root/.odbc.ini SQLULEN Size.......: 8 SQLLEN Size........: 8 SQLSETPOSIROW Size.: 8 不推荐修改全局配置文件，可设置 ODBCSYSINI 环境变量指定配置文件路径，如 ODBCSYSINI=~/ODBC http://www.unixodbc.org/odbcinst.html 安装完驱动程序，/etc/odbcinst.ini 文件内容自动更新，我们可以不必修改，如果你想自定义不妨手动修改，我们查看在 R 环境中注册的数据库，可以看到 PostgreSQL 的驱动已经配置好 odbc::odbcListDrivers() name attribute value 1 PostgreSQL ANSI Description PostgreSQL ODBC driver (ANSI version) 2 PostgreSQL ANSI Driver psqlodbca.so 3 PostgreSQL ANSI Setup libodbcpsqlS.so 4 PostgreSQL ANSI Debug 0 5 PostgreSQL ANSI CommLog 1 6 PostgreSQL ANSI UsageCount 1 7 PostgreSQL Unicode Description PostgreSQL ODBC driver (Unicode version) 8 PostgreSQL Unicode Driver psqlodbcw.so 9 PostgreSQL Unicode Setup libodbcpsqlS.so 10 PostgreSQL Unicode Debug 0 11 PostgreSQL Unicode CommLog 1 12 PostgreSQL Unicode UsageCount 1 系统配置文件 /etc/odbcinst.ini 已经包含有 PostgreSQL 的驱动配置，无需再重复配置 [PostgreSQL ANSI] Description=PostgreSQL ODBC driver (ANSI version) Driver=psqlodbca.so Setup=libodbcpsqlS.so Debug=0 CommLog=1 UsageCount=1 [PostgreSQL Unicode] Description=PostgreSQL ODBC driver (Unicode version) Driver=psqlodbcw.so Setup=libodbcpsqlS.so Debug=0 CommLog=1 UsageCount=1 只需将如下内容存放在 ~/.odbc.ini 文件中， [PostgreSQL] Driver = PostgreSQL Unicode Database = postgres Servername = 172.17.0.1 UserName = postgres Password = default Port = 8080 最后，一行命令 DNS 配置连接 https://github.com/r-dbi/odbc 这样就实现了代码中无任何敏感信息，这里为了展示这个配置过程故而把相关信息公开。 注意下面的内容需要在容器中运行， Windows 环境下的配置 PostgreSQL 的驱动有点麻烦就不搞了，意义也不大，现在数据库基本都是跑在 Linux 系统上 docker-machine.exe ip default 可以获得本地 Docker 的 IP，比如 192.168.99.101。 Travis 上 ip addr 可以查看 Docker 的 IP，如 172.17.0.1 library(DBI) con &lt;- dbConnect(RPostgres::Postgres(), dbname = &quot;postgres&quot;, host = ifelse(is_on_travis, Sys.getenv(&quot;DOCKER_HOST_IP&quot;), &quot;192.168.99.101&quot;), port = 8080, user = &quot;postgres&quot;, password = &quot;default&quot; ) library(DBI) con &lt;- dbConnect(odbc::odbc(), &quot;PostgreSQL&quot;) 列出数据库中的所有表 dbListTables(con) #&gt; character(0) 第一次启动从 Docker Hub 上下载的镜像，默认的数据库是 postgres 里面没有任何表，所以将 R 环境中的 mtcars 数据集写入 postgres 数据库 将数据集 mtcars 写入 PostgreSQL 数据库中，基本操作，写入表的操作也不能缓存，即不能缓存数据库中的表 mtcars dbWriteTable(con, &quot;mtcars&quot;, mtcars, overwrite = TRUE) 现在可以看到数据表 mtcars 的各个字段 dbListFields(con, &quot;mtcars&quot;) #&gt; [1] &quot;row_names&quot; &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; #&gt; [6] &quot;drat&quot; &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; #&gt; [11] &quot;gear&quot; &quot;carb&quot; 最后执行一条 SQL 语句 res &lt;- dbSendQuery(con, &quot;SELECT * FROM mtcars WHERE cyl = 4&quot;) # 发送 SQL 语句 dbFetch(res) # 获取查询结果 #&gt; row_names mpg cyl disp hp drat wt qsec vs am gear carb #&gt; 1 Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 #&gt; 2 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 #&gt; 3 Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 #&gt; 4 Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 #&gt; 5 Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 #&gt; 6 Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 #&gt; 7 Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 #&gt; 8 Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 #&gt; 9 Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 #&gt; 10 Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 #&gt; 11 Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 dbClearResult(res) # 清理查询通道 或者一条命令搞定 dbGetQuery(con, &quot;SELECT * FROM mtcars WHERE cyl = 4&quot;) #&gt; row_names mpg cyl disp hp drat wt qsec vs am gear carb #&gt; 1 Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 #&gt; 2 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 #&gt; 3 Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 #&gt; 4 Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 #&gt; 5 Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 #&gt; 6 Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 #&gt; 7 Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 #&gt; 8 Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 #&gt; 9 Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 #&gt; 10 Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 #&gt; 11 Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 再复杂一点的 SQL 查询操作 dbGetQuery(con, &quot;SELECT cyl, AVG(mpg) AS mpg FROM mtcars GROUP BY cyl ORDER BY cyl&quot;) #&gt; cyl mpg #&gt; 1 4 26.66364 #&gt; 2 6 19.74286 #&gt; 3 8 15.10000 aggregate(mpg ~ cyl, data = mtcars, mean) #&gt; cyl mpg #&gt; 1 4 26.66364 #&gt; 2 6 19.74286 #&gt; 3 8 15.10000 得益于 knitr (Xie 2015) 开发的钩子，这里直接写 SQL 语句块，打印出来见表 2.5，值得注意的是 SQL 代码块不能启用缓存，数据库连接通道也不能缓存，如果数据库中还没有写入表，那么写入表的操作也不能缓存 SELECT cyl, AVG(mpg) AS mpg FROM mtcars GROUP BY cyl ORDER BY cyl 表 2.5: 表格标题 cyl mpg 4 26.66364 6 19.74286 8 15.10000 如果将查询结果导出到变量，在 Chunk 设置 output.var = \"agg_cyl\" 可以使用缓存，下面将 mpg 按 cyl 分组聚合的结果打印出来 agg_cyl #&gt; cyl mpg #&gt; 1 4 26.66364 #&gt; 2 6 19.74286 #&gt; 3 8 15.10000 这种基于 odbc 的方式的好处就不需要再安装 R 包 RPostgres 和相关系统依赖，最后关闭连接通道 dbDisconnect(con) 2.4.2 MySQL MySQL 是一个很常见，应用也很广泛的数据库，数据分析的常见环境是在一个R Notebook 里，我们可以在正文之前先设定数据库连接信息 ```{r setup} library(DBI) # 指定数据库连接信息 db &lt;- dbConnect(RMySQL::MySQL(), dbname = &#39;dbtest&#39;, username = &#39;user_test&#39;, password = &#39;password&#39;, host = &#39;10.10.101.10&#39;, port = 3306 ) # 创建默认连接 knitr::opts_chunk$set(connection = &#39;db&#39;) # 设置字符编码，以免中文查询乱码 DBI::dbSendQuery(db, &#39;SET NAMES utf8&#39;) # 设置日期变量，以运用在SQL中 idate &lt;- &#39;2019-05-03&#39; ``` SQL 代码块中使用 R 环境中的变量，并将查询结果输出为R环境中的数据框 ```{sql, output.var=&#39;data_output&#39;} SELECT * FROM user_table where date_format(created_date,&#39;%Y-%m-%d&#39;)&gt;=?idate ``` 以上代码会将 SQL 的运行结果存在 data_output 这是数据库中，idate 取之前设置的日期2019-05-03，user_table 是 MySQL 数据库中的表名，created_date 是创建user_table时，指定的日期名。 如果 SQL 比较长，为了代码美观，把带有变量的 SQL 保存为demo.sql脚本，只需要在 SQL 的 chunk 中直接读取 SQL 文件15。 ```{sql, code=readLines(&#39;demo.sql&#39;), output.var=&#39;data_output&#39;} ``` 如果我们需要每天或者按照指定的日期重复地运行这个 R Markdown 文件，可以在 YAML 部分引入参数16 --- params: date: &quot;2019-05-03&quot; # 参数化日期 --- ```{r setup, include=FALSE} idate = params$date # 将参数化日期传递给 idate 变量 ``` 我们将这个 Rmd 文件命名为 MyDocument.Rmd，运行这个文件可以从 R 控制台执行或在 RStudio 点击 knit。 rmarkdown::render(&quot;MyDocument.Rmd&quot;, params = list( date = &quot;2019-05-03&quot; )) 如果在文档的 YAML 位置已经指定日期，这里可以不指定。注意在这里设置日期会覆盖 YAML 处指定的参数值，这样做的好处是可以批量化操作。 2.4.3 Spark 当数据分析报告遇上 Spark 时，就需要 SparkR、 sparklyr、 arrow 或 rsparking 接口了， Javier Luraschi 写了一本书 The R in Spark: Learning Apache Spark with R 详细介绍了相关扩展和应用 首先安装 sparklyr 包，RStudio 公司 Javier Lurasch 开发了 sparklyr 包，作为 Spark 与 R 语言之间的接口，安装完 sparklyr 包，还是需要 Spark 和 Hadoop 环境 install.packages(&#39;sparklyr&#39;) library(sparklyr) spark_install() # Installing Spark 2.4.0 for Hadoop 2.7 or later. # Downloading from: # - &#39;https://archive.apache.org/dist/spark/spark-2.4.0/spark-2.4.0-bin-hadoop2.7.tgz&#39; # Installing to: # - &#39;~/spark/spark-2.4.0-bin-hadoop2.7&#39; # trying URL &#39;https://archive.apache.org/dist/spark/spark-2.4.0/spark-2.4.0-bin-hadoop2.7.tgz&#39; # Content type &#39;application/x-gzip&#39; length 227893062 bytes (217.3 MB) # ================================================== # downloaded 217.3 MB # # Installation complete. 既然 sparklyr 已经安装了 Spark 和 Hadoop 环境，安装 SparkR 后，只需配置好路径，就可以加载 SparkR 包 install.packages(&#39;SparkR&#39;) if (nchar(Sys.getenv(&quot;SPARK_HOME&quot;)) &lt; 1) { Sys.setenv(SPARK_HOME = &quot;~/spark/spark-2.4.0-bin-hadoop2.7&quot;) } library(SparkR, lib.loc = c(file.path(Sys.getenv(&quot;SPARK_HOME&quot;), &quot;R&quot;, &quot;lib&quot;))) sparkR.session(master = &quot;local[*]&quot;, sparkConfig = list(spark.driver.memory = &quot;2g&quot;)) rscala 架起了 R 和 Scala 两门语言之间交流的桥梁，使得彼此之间可以互相调用 是否存在这样的可能， Spark 提供了大量的 MLib 库的调用接口，R 的功能支持是最少的，Java/Scala 是原生的，那么要么自己开发新的功能整合到 SparkR 中，要么借助 rscala 将 scala 接口代码封装进来 2.5 批量导入数据 library(tidyverse) read_list &lt;- function(list_of_datasets, read_func) { read_and_assign &lt;- function(dataset, read_func) { dataset_name &lt;- as.name(dataset) dataset_name &lt;- read_func(dataset) } # invisible is used to suppress the unneeded output output &lt;- invisible( sapply(list_of_datasets, read_and_assign, read_func = read_func, simplify = FALSE, USE.NAMES = TRUE ) ) # Remove the extension at the end of the data set names names_of_datasets &lt;- c(unlist(strsplit(list_of_datasets, &quot;[.]&quot;))[c(T, F)]) names(output) &lt;- names_of_datasets return(output) } 批量导入文件扩展名为 .csv 的数据文件，即逗号分割的文件 data_files &lt;- list.files(path = &quot;path/to/csv/dir&quot;,pattern = &quot;.csv&quot;, full.names = TRUE) print(data_files) 相比于 Base R 提供的 read.csv 函数，使用 readr 包的 read_csv 函数可以更快地读取csv格式文件，特别是在读取GB级数据文件时，效果特别明显。 list_of_data_sets &lt;- read_list(data_files, readr::read_csv) 使用 tibble 包的glimpse函数可以十分方便地对整个数据集有一个大致的了解，展示方式和信息量相当于 str 加 head 函数 tibble::glimpse(list_of_data_sets) 2.6 批量导出数据 假定我们有一个列表，其每个元素都是一个数据框，现在要把每个数据框分别存入 xlsx 表的工作薄中，以 mtcars 数据集为例，将其按分类变量 cyl 分组拆分，获得一个列表 list dat &lt;- split(mtcars, mtcars$cyl) dat #&gt; $`4` #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 #&gt; Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 #&gt; Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 #&gt; Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 #&gt; Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 #&gt; Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 #&gt; Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 #&gt; Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 #&gt; Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 #&gt; Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 #&gt; Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 #&gt; #&gt; $`6` #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 #&gt; Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 #&gt; Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 #&gt; Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 #&gt; Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 #&gt; Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 #&gt; Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 #&gt; #&gt; $`8` #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 #&gt; Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 #&gt; Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 #&gt; Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 #&gt; Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 #&gt; Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 #&gt; Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 #&gt; Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 #&gt; Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 #&gt; AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 #&gt; Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 #&gt; Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 #&gt; Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 #&gt; Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 将 xlsx 表格初始化，创建空白的工作薄， openxlsx 包不依赖 Java 环境，读写效率也高 ## 加载 openxlsx 包 library(openxlsx) ## 创建空白的工作薄 wb &lt;- createWorkbook() 将列表里的每张表分别存入 xlsx 表格的每个 worksheet，worksheet 的名字就是分组变量的名字 Map(function(data, name){ addWorksheet(wb, name) writeData(wb, name, data) }, dat, names(dat)) 最后保存数据到磁盘，见图 2.1 saveWorkbook(wb, file = &quot;data/matcars.xlsx&quot;, overwrite = TRUE) 图 2.1: 批量导出数据 处理 Excel 2003 (XLS) 和 Excel 2007 (XLSX) 文件还可以使用 WriteXLS 包，不过它依赖于 Perl，另一个 R 包 xlsx 与之功能类似，依赖 Java 环境。Jennifer Bryan 和 Hadley Wickham 开发的 readxl 包和 Jeroen Ooms 开发的 writexl 包专门处理 xlsx 格式并且无任何系统依赖 2.7 导出数据 2.7.1 导出运行结果 capture.output(..., file = NULL, append = FALSE, type = c(&quot;output&quot;, &quot;message&quot;), split = FALSE) capture.output 将一段R代码执行结果，保存到文件，参数为表达式。capture.output 和 sink 的关系相当于 with 和 attach 的关系。 glmout &lt;- capture.output(summary(glm(case ~ spontaneous + induced, data = infert, family = binomial() )), file = &quot;data/capture.txt&quot;) capture.output(1 + 1, 2 + 2) #&gt; [1] &quot;[1] 2&quot; &quot;[1] 4&quot; capture.output({ 1 + 1 2 + 2 }) #&gt; [1] &quot;[1] 4&quot; sink 函数将控制台输出结果保存到文件，只将 outer 函数运行的结果保存到 ex-sink.txt 文件，outer 函数计算的是直积，在这里相当于 seq(10) %*% t(seq(10))，而在 R 语言中，更加有效的计算方式是 tcrossprod(seq(10),seq(10)) sink(&quot;data/ex-sink.txt&quot;) i &lt;- 1:10 outer(i, i, &quot;*&quot;) #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #&gt; [1,] 1 2 3 4 5 6 7 8 9 10 #&gt; [2,] 2 4 6 8 10 12 14 16 18 20 #&gt; [3,] 3 6 9 12 15 18 21 24 27 30 #&gt; [4,] 4 8 12 16 20 24 28 32 36 40 #&gt; [5,] 5 10 15 20 25 30 35 40 45 50 #&gt; [6,] 6 12 18 24 30 36 42 48 54 60 #&gt; [7,] 7 14 21 28 35 42 49 56 63 70 #&gt; [8,] 8 16 24 32 40 48 56 64 72 80 #&gt; [9,] 9 18 27 36 45 54 63 72 81 90 #&gt; [10,] 10 20 30 40 50 60 70 80 90 100 sink() 2.7.2 导出数据对象 load(file, envir = parent.frame(), verbose = FALSE) save(..., list = character(), file = stop(&quot;&#39;file&#39; must be specified&quot;), ascii = FALSE, version = NULL, envir = parent.frame(), compress = isTRUE(!ascii), compression_level, eval.promises = TRUE, precheck = TRUE) save.image(file = &quot;.RData&quot;, version = NULL, ascii = FALSE, compress = !ascii, safe = TRUE) load 和save 函数加载或保存包含工作环境信息的数据对象，save.image 保存当前工作环境到磁盘，即保存工作空间中所有数据对象，数据格式为 .RData，即相当于 save(list = ls(all.names = TRUE), file = &quot;.RData&quot;, envir = .GlobalEnv) dump 保存数据对象 AirPassengers 到文件 AirPassengers.txt，文件内容是 R 命令，可把AirPassengers.txt看作代码文档执行，dput 保存数据对象内容到文件AirPassengers.dat，文件中不包含变量名 AirPassengers。注意到 dump 输入是一个字符串，而 dput 要求输入数据对象的名称，source 函数与 dump 对应，而 dget 与 dput对应。 # 加载数据 data(AirPassengers, package = &quot;datasets&quot;) # 将数据以R代码块的形式保存到文件 dump(&#39;AirPassengers&#39;, file = &#39;data/AirPassengers.txt&#39;) # source(file = &#39;data/AirPassengers.txt&#39;) 接下来，我们读取 AirPassengers.txt 的文件内容，可见它是一段完整的 R 代码，可以直接复制到 R 的控制台中运行，并且得到一个与原始 AirPassengers 变量一样的结果 cat(readLines(&#39;data/AirPassengers.txt&#39;), sep = &quot;\\n&quot;) #&gt; AirPassengers &lt;- #&gt; structure(c(112, 118, 132, 129, 121, 135, 148, 148, 136, 119, #&gt; 104, 118, 115, 126, 141, 135, 125, 149, 170, 170, 158, 133, 114, #&gt; 140, 145, 150, 178, 163, 172, 178, 199, 199, 184, 162, 146, 166, #&gt; 171, 180, 193, 181, 183, 218, 230, 242, 209, 191, 172, 194, 196, #&gt; 196, 236, 235, 229, 243, 264, 272, 237, 211, 180, 201, 204, 188, #&gt; 235, 227, 234, 264, 302, 293, 259, 229, 203, 229, 242, 233, 267, #&gt; 269, 270, 315, 364, 347, 312, 274, 237, 278, 284, 277, 317, 313, #&gt; 318, 374, 413, 405, 355, 306, 271, 306, 315, 301, 356, 348, 355, #&gt; 422, 465, 467, 404, 347, 305, 336, 340, 318, 362, 348, 363, 435, #&gt; 491, 505, 404, 359, 310, 337, 360, 342, 406, 396, 420, 472, 548, #&gt; 559, 463, 407, 362, 405, 417, 391, 419, 461, 472, 535, 622, 606, #&gt; 508, 461, 390, 432), .Tsp = c(1949, 1960.91666666667, 12), class = &quot;ts&quot;) dput 函数类似 dump 函数，保存数据对象到磁盘文件 # 将 R 对象保存/导出到磁盘 dput(AirPassengers, file = &#39;data/AirPassengers.dat&#39;) AirPassengers Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec 1949 112 118 132 129 121 135 148 148 136 119 104 118 1950 115 126 141 135 125 149 170 170 158 133 114 140 1951 145 150 178 163 172 178 199 199 184 162 146 166 1952 171 180 193 181 183 218 230 242 209 191 172 194 1953 196 196 236 235 229 243 264 272 237 211 180 201 1954 204 188 235 227 234 264 302 293 259 229 203 229 1955 242 233 267 269 270 315 364 347 312 274 237 278 1956 284 277 317 313 318 374 413 405 355 306 271 306 1957 315 301 356 348 355 422 465 467 404 347 305 336 1958 340 318 362 348 363 435 491 505 404 359 310 337 1959 360 342 406 396 420 472 548 559 463 407 362 405 1960 417 391 419 461 472 535 622 606 508 461 390 432 # dget 作用与 dput 相反 AirPassengers2 &lt;- dget(file = &#39;data/AirPassengers.dat&#39;) AirPassengers2 Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec 1949 112 118 132 129 121 135 148 148 136 119 104 118 1950 115 126 141 135 125 149 170 170 158 133 114 140 1951 145 150 178 163 172 178 199 199 184 162 146 166 1952 171 180 193 181 183 218 230 242 209 191 172 194 1953 196 196 236 235 229 243 264 272 237 211 180 201 1954 204 188 235 227 234 264 302 293 259 229 203 229 1955 242 233 267 269 270 315 364 347 312 274 237 278 1956 284 277 317 313 318 374 413 405 355 306 271 306 1957 315 301 356 348 355 422 465 467 404 347 305 336 1958 340 318 362 348 363 435 491 505 404 359 310 337 1959 360 342 406 396 420 472 548 559 463 407 362 405 1960 417 391 419 461 472 535 622 606 508 461 390 432 同样地，现在我们观察 dput 函数保存的文件 AirPassengers.dat 内容，和dump 函数保存的文件 AirPassengers.txt相比，就缺一个赋值变量 cat(readLines(&#39;data/AirPassengers.dat&#39;), sep = &quot;\\n&quot;) structure(c(112, 118, 132, 129, 121, 135, 148, 148, 136, 119, 104, 118, 115, 126, 141, 135, 125, 149, 170, 170, 158, 133, 114, 140, 145, 150, 178, 163, 172, 178, 199, 199, 184, 162, 146, 166, 171, 180, 193, 181, 183, 218, 230, 242, 209, 191, 172, 194, 196, 196, 236, 235, 229, 243, 264, 272, 237, 211, 180, 201, 204, 188, 235, 227, 234, 264, 302, 293, 259, 229, 203, 229, 242, 233, 267, 269, 270, 315, 364, 347, 312, 274, 237, 278, 284, 277, 317, 313, 318, 374, 413, 405, 355, 306, 271, 306, 315, 301, 356, 348, 355, 422, 465, 467, 404, 347, 305, 336, 340, 318, 362, 348, 363, 435, 491, 505, 404, 359, 310, 337, 360, 342, 406, 396, 420, 472, 548, 559, 463, 407, 362, 405, 417, 391, 419, 461, 472, 535, 622, 606, 508, 461, 390, 432), .Tsp = c(1949, 1960.91666666667, 12), class = &quot;ts&quot;) 2.8 运行环境 xfun::session_info(c(&quot;jsonlite&quot;, &quot;yaml&quot;, &quot;odbc&quot;)) #&gt; R version 3.6.1 (2019-07-05) #&gt; Platform: x86_64-pc-linux-gnu (64-bit) #&gt; Running under: Debian GNU/Linux 10 (buster) #&gt; #&gt; Locale: #&gt; LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C #&gt; LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 #&gt; LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 #&gt; LC_PAPER=en_US.UTF-8 LC_NAME=C #&gt; LC_ADDRESS=C LC_TELEPHONE=C #&gt; LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C #&gt; #&gt; Package version: #&gt; assertthat_0.2.1 backports_1.1.4 BH_1.69.0.1 #&gt; bit_1.1.14 bit64_0.9.7 blob_1.2.0 #&gt; DBI_1.0.0 digest_0.6.20 ellipsis_0.2.0.1 #&gt; glue_1.3.1 graphics_3.6.1 grDevices_3.6.1 #&gt; hms_0.5.0 jsonlite_1.6 magrittr_1.5 #&gt; methods_3.6.1 odbc_1.1.6 pkgconfig_2.0.2 #&gt; prettyunits_1.0.2 Rcpp_1.0.2 rlang_0.4.0 #&gt; stats_3.6.1 tools_3.6.1 utils_3.6.1 #&gt; vctrs_0.2.0 yaml_2.2.0 zeallot_0.1.0 参考文献 "],
["dm-base-r.html", "第 3 章 数据操作手 3.1 查看数据 3.2 数据变形 3.3 数据转换 3.4 提取子集 3.5 按列排序 3.6 数据拆分 3.7 数据合并 3.8 数据去重 3.9 数据聚合 3.10 表格统计 3.11 索引访问 3.12 多维数组 3.13 其它操作 3.14 运行环境", " 第 3 章 数据操作手 参考 Data Manipulation With R (Spector 2008) 重新捋一遍本章 本章的操作对象是 data.frame 介绍 Base R 提供的数据操作，关于采用 Base R 还是 tidyverse 做数据操作的 讨论 数据操作的动画展示参考 https://github.com/gadenbuie/tidyexplain 提供 Base R 对应的实现 什么是 Base R? Base R 指的是 R 语言/软件的核心组件，由 R Core Team 维护 Pkgs &lt;- sapply(list.files(R.home(&quot;library&quot;)), function(x) packageDescription(pkg = x, fields = &quot;Priority&quot;)) names(Pkgs[Pkgs == &quot;base&quot; &amp; !is.na(Pkgs)]) #&gt; [1] &quot;base&quot; &quot;compiler&quot; &quot;datasets&quot; &quot;graphics&quot; &quot;grDevices&quot; #&gt; [6] &quot;grid&quot; &quot;methods&quot; &quot;parallel&quot; &quot;splines&quot; &quot;stats&quot; #&gt; [11] &quot;stats4&quot; &quot;tcltk&quot; &quot;tools&quot; &quot;utils&quot; names(Pkgs[Pkgs == &quot;recommended&quot; &amp; !is.na(Pkgs)]) #&gt; character(0) 数据变形，分组统计聚合等，用以作为模型的输入，绘图的对象，操作的数据对象是数据框(data.frame)类型的，而且如果没有特别说明，文中出现的数据集都是 Base R 内置的，第三方 R 包或者来源于网上的数据集都会加以说明。 3.1 查看数据 查看属性 str(iris) #&gt; &#39;data.frame&#39;: 150 obs. of 5 variables: #&gt; $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... #&gt; $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... #&gt; $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... #&gt; $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... #&gt; $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1.. 查看部分数据集 head(iris, 5) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 1 5.1 3.5 1.4 0.2 setosa #&gt; 2 4.9 3.0 1.4 0.2 setosa #&gt; 3 4.7 3.2 1.3 0.2 setosa #&gt; 4 4.6 3.1 1.5 0.2 setosa #&gt; 5 5.0 3.6 1.4 0.2 setosa tail(iris, 5) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 146 6.7 3.0 5.2 2.3 virginica #&gt; 147 6.3 2.5 5.0 1.9 virginica #&gt; 148 6.5 3.0 5.2 2.0 virginica #&gt; 149 6.2 3.4 5.4 2.3 virginica #&gt; 150 5.9 3.0 5.1 1.8 virginica 查看文件前（后）5行 head -n 5 test.csv tail -n 5 test.csv 对象的类型，存储方式 class(iris) #&gt; [1] &quot;data.frame&quot; mode(iris) #&gt; [1] &quot;list&quot; typeof(iris) #&gt; [1] &quot;list&quot; 查看对象在R环境中所占空间的大小 object.size(iris) #&gt; 7256 bytes object.size(letters) #&gt; 1712 bytes object.size(ls) #&gt; 89904 bytes format(object.size(library), units = &quot;auto&quot;) #&gt; [1] &quot;1.8 Mb&quot; 3.2 数据变形 重复测量数据的变形 Reshape Grouped Data，将宽格式 wide 的数据框变长格式 long的，反之也行。reshape 还支持正则表达式 str(Indometh) #&gt; Classes &#39;nfnGroupedData&#39;, &#39;nfGroupedData&#39;, &#39;groupedData&#39; and &#39;data.frame&#39;: 66 obs. of 3 variables: #&gt; $ Subject: Ord.factor w/ 6 levels &quot;1&quot;&lt;&quot;4&quot;&lt;&quot;2&quot;&lt;&quot;5&quot;&lt;..: 1 1 1 1 1 1 1 1 1 .. #&gt; $ time : num 0.25 0.5 0.75 1 1.25 2 3 4 5 6 ... #&gt; $ conc : num 1.5 0.94 0.78 0.48 0.37 0.19 0.12 0.11 0.08 0.07 ... #&gt; - attr(*, &quot;formula&quot;)=Class &#39;formula&#39; language conc ~ time | Subject #&gt; .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_EmptyEnv&gt; #&gt; - attr(*, &quot;labels&quot;)=List of 2 #&gt; ..$ x: chr &quot;Time since drug administration&quot; #&gt; ..$ y: chr &quot;Indomethacin concentration&quot; #&gt; - attr(*, &quot;units&quot;)=List of 2 #&gt; ..$ x: chr &quot;(hr)&quot; #&gt; ..$ y: chr &quot;(mcg/ml)&quot; summary(Indometh) #&gt; Subject time conc #&gt; 1:11 Min. :0.250 Min. :0.0500 #&gt; 4:11 1st Qu.:0.750 1st Qu.:0.1100 #&gt; 2:11 Median :2.000 Median :0.3400 #&gt; 5:11 Mean :2.886 Mean :0.5918 #&gt; 6:11 3rd Qu.:5.000 3rd Qu.:0.8325 #&gt; 3:11 Max. :8.000 Max. :2.7200 # 长的变宽 wide &lt;- reshape(Indometh, v.names = &quot;conc&quot;, idvar = &quot;Subject&quot;, timevar = &quot;time&quot;, direction = &quot;wide&quot; ) wide[, 1:6] #&gt; Subject conc.0.25 conc.0.5 conc.0.75 conc.1 conc.1.25 #&gt; 1 1 1.50 0.94 0.78 0.48 0.37 #&gt; 12 2 2.03 1.63 0.71 0.70 0.64 #&gt; 23 3 2.72 1.49 1.16 0.80 0.80 #&gt; 34 4 1.85 1.39 1.02 0.89 0.59 #&gt; 45 5 2.05 1.04 0.81 0.39 0.30 .... # 宽的变长 reshape(wide, direction = &quot;long&quot;) #&gt; Subject time conc #&gt; 1.0.25 1 0.25 1.50 #&gt; 2.0.25 2 0.25 2.03 #&gt; 3.0.25 3 0.25 2.72 #&gt; 4.0.25 4 0.25 1.85 #&gt; 5.0.25 5 0.25 2.05 .... 宽的格式变成长的格式 https://stackoverflow.com/questions/2185252 长的格式变成宽的格式 https://stackoverflow.com/questions/5890584/ set.seed(45) dat &lt;- data.frame( name = rep(c(&quot;Orange&quot;, &quot;Apple&quot;), each=4), numbers = rep(1:4, 2), value = rnorm(8)) dat #&gt; name numbers value #&gt; 1 Orange 1 0.3407997 #&gt; 2 Orange 2 -0.7033403 #&gt; 3 Orange 3 -0.3795377 #&gt; 4 Orange 4 -0.7460474 #&gt; 5 Apple 1 -0.8981073 #&gt; 6 Apple 2 -0.3347941 #&gt; 7 Apple 3 -0.5013782 #&gt; 8 Apple 4 -0.1745357 reshape(dat, idvar = &quot;name&quot;, timevar = &quot;numbers&quot;, direction = &quot;wide&quot;) #&gt; name value.1 value.2 value.3 value.4 #&gt; 1 Orange 0.3407997 -0.7033403 -0.3795377 -0.7460474 #&gt; 5 Apple -0.8981073 -0.3347941 -0.5013782 -0.1745357 更加复杂的例子， gambia 数据集，重塑的效果是使得个体水平的长格式变为村庄水平的宽格式 # data(gambia, package = &quot;geoR&quot;) # 在线下载数据集 gambia &lt;- read.table( file = paste(&quot;http://www.leg.ufpr.br/lib/exe/fetch.php&quot;, &quot;pessoais:paulojus:mbgbook:datasets:gambia.txt&quot;, sep = &quot;/&quot; ), header = TRUE ) head(gambia) #&gt; x y pos age netuse treated green phc #&gt; 1 349631.3 1458055 1 1783 0 0 40.85 1 #&gt; 2 349631.3 1458055 0 404 1 0 40.85 1 #&gt; 3 349631.3 1458055 0 452 1 0 40.85 1 #&gt; 4 349631.3 1458055 1 566 1 0 40.85 1 #&gt; 5 349631.3 1458055 0 598 1 0 40.85 1 #&gt; 6 349631.3 1458055 1 590 1 0 40.85 1 # Building a &quot;village-level&quot; data frame ind &lt;- paste(&quot;x&quot;, gambia[, 1], &quot;y&quot;, gambia[, 2], sep = &quot;&quot;) village &lt;- gambia[!duplicated(ind), c(1:2, 7:8)] village$prev &lt;- as.vector(tapply(gambia$pos, ind, mean)) head(village) #&gt; x y green phc prev #&gt; 1 349631.3 1458055 40.85 1 0.5151515 #&gt; 34 358543.1 1460112 40.85 1 0.3015873 #&gt; 97 360308.1 1460026 40.10 0 0.4117647 #&gt; 114 363795.7 1496919 40.85 0 0.3333333 #&gt; 138 366400.5 1460248 40.85 0 0.3846154 #&gt; 164 366687.5 1463002 40.85 0 0.3888889 3.3 数据转换 transform 对数据框中的某些列做计算，取对数，将计算的结果单存一列加到数据框中 transform(iris, scale.sl = (max(Sepal.Length) - Sepal.Length) / (max(Sepal.Length) - min(Sepal.Length))) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 1 5.1 3.5 1.4 0.2 setosa #&gt; 2 4.9 3.0 1.4 0.2 setosa #&gt; 3 4.7 3.2 1.3 0.2 setosa #&gt; 4 4.6 3.1 1.5 0.2 setosa #&gt; 5 5.0 3.6 1.4 0.2 setosa .... 验证一下 scale.sl 变量的第一个值 (max(iris$Sepal.Length) - 5.1) / (max(iris$Sepal.Length) - min(iris$Sepal.Length)) #&gt; [1] 0.7777778 Warning: This is a convenience function intended for use interactively. For programming it is better to use the standard subsetting arithmetic functions, and in particular the non-standard evaluation of argument transform can have unanticipated consequences. 3.4 提取子集 subset(x, subset, select, drop = FALSE, ...) 参数 subset代表行操作，select 代表列操作，函数 subset 从数据框中提取部分数据 subset(iris, Species == &quot;virginica&quot;) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 101 6.3 3.3 6.0 2.5 virginica #&gt; 102 5.8 2.7 5.1 1.9 virginica #&gt; 103 7.1 3.0 5.9 2.1 virginica #&gt; 104 6.3 2.9 5.6 1.8 virginica #&gt; 105 6.5 3.0 5.8 2.2 virginica .... # summary(iris$Sepal.Length) mean(iris$Sepal.Length) # 且的逻辑 # subset(iris, Species == &quot;virginica&quot; &amp; Sepal.Length &gt; 5.84333) subset(iris, Species == &quot;virginica&quot; &amp; Sepal.Length &gt; mean(Sepal.Length)) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 101 6.3 3.3 6.0 2.5 virginica #&gt; 103 7.1 3.0 5.9 2.1 virginica #&gt; 104 6.3 2.9 5.6 1.8 virginica #&gt; 105 6.5 3.0 5.8 2.2 virginica #&gt; 106 7.6 3.0 6.6 2.1 virginica .... # 在行的子集范围内 subset(iris, Species %in% c(&quot;virginica&quot;, &quot;versicolor&quot;) &amp; Sepal.Length &gt; mean(Sepal.Length)) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 51 7.0 3.2 4.7 1.4 versicolor #&gt; 52 6.4 3.2 4.5 1.5 versicolor #&gt; 53 6.9 3.1 4.9 1.5 versicolor #&gt; 55 6.5 2.8 4.6 1.5 versicolor #&gt; 57 6.3 3.3 4.7 1.6 versicolor .... # 在列的子集内 先选中列 subset(iris, Sepal.Length &gt; mean(Sepal.Length), select = c(&quot;Sepal.Length&quot;, &quot;Species&quot;) ) #&gt; Sepal.Length Species #&gt; 51 7.0 versicolor #&gt; 52 6.4 versicolor #&gt; 53 6.9 versicolor #&gt; 55 6.5 versicolor #&gt; 57 6.3 versicolor .... 高级操作：加入正则表达式筛选 ## sometimes requiring a logical &#39;subset&#39; argument is a nuisance nm &lt;- rownames(state.x77) start_with_M &lt;- nm %in% grep(&quot;^M&quot;, nm, value = TRUE) subset(state.x77, start_with_M, Illiteracy:Murder) #&gt; Illiteracy Life Exp Murder #&gt; Maine 0.7 70.39 2.7 #&gt; Maryland 0.9 70.22 8.5 #&gt; Massachusetts 1.1 71.83 3.3 #&gt; Michigan 0.9 70.63 11.1 #&gt; Minnesota 0.6 72.96 2.3 #&gt; Mississippi 2.4 68.09 12.5 #&gt; Missouri 0.8 70.69 9.3 #&gt; Montana 0.6 70.56 5.0 # 简化 subset(state.x77, subset = grepl(&quot;^M&quot;, rownames(state.x77)), select = Illiteracy:Murder) #&gt; Illiteracy Life Exp Murder #&gt; Maine 0.7 70.39 2.7 #&gt; Maryland 0.9 70.22 8.5 #&gt; Massachusetts 1.1 71.83 3.3 #&gt; Michigan 0.9 70.63 11.1 #&gt; Minnesota 0.6 72.96 2.3 #&gt; Mississippi 2.4 68.09 12.5 #&gt; Missouri 0.8 70.69 9.3 #&gt; Montana 0.6 70.56 5.0 # 继续简化 subset(state.x77, grepl(&quot;^M&quot;, rownames(state.x77)), Illiteracy:Murder) #&gt; Illiteracy Life Exp Murder #&gt; Maine 0.7 70.39 2.7 #&gt; Maryland 0.9 70.22 8.5 #&gt; Massachusetts 1.1 71.83 3.3 #&gt; Michigan 0.9 70.63 11.1 #&gt; Minnesota 0.6 72.96 2.3 #&gt; Mississippi 2.4 68.09 12.5 #&gt; Missouri 0.8 70.69 9.3 #&gt; Montana 0.6 70.56 5.0 警告：这是一个为了交互使用打造的便捷函数。对于编程，最好使用标准的子集函数，如 [，特别地，参数 subset 的非标准计算(non-standard evaluation)17 可能带来意想不到的后果。 使用索引 [ iris[iris$Species == &quot;virginica&quot;, ] #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 101 6.3 3.3 6.0 2.5 virginica #&gt; 102 5.8 2.7 5.1 1.9 virginica #&gt; 103 7.1 3.0 5.9 2.1 virginica #&gt; 104 6.3 2.9 5.6 1.8 virginica #&gt; 105 6.5 3.0 5.8 2.2 virginica .... iris[iris$Species == &quot;virginica&quot; &amp; iris$Sepal.Length &gt; mean(iris$Sepal.Length), ] #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 101 6.3 3.3 6.0 2.5 virginica #&gt; 103 7.1 3.0 5.9 2.1 virginica #&gt; 104 6.3 2.9 5.6 1.8 virginica #&gt; 105 6.5 3.0 5.8 2.2 virginica #&gt; 106 7.6 3.0 6.6 2.1 virginica .... iris[ iris$Species == &quot;virginica&quot; &amp; iris$Sepal.Length &gt; mean(iris$Sepal.Length), c(&quot;Sepal.Length&quot;, &quot;Species&quot;) ] #&gt; Sepal.Length Species #&gt; 101 6.3 virginica #&gt; 103 7.1 virginica #&gt; 104 6.3 virginica #&gt; 105 6.5 virginica #&gt; 106 7.6 virginica .... 3.5 按列排序 在数据框内，根据(order)某一列或几列对行进行排序(sort)，根据鸢尾花(iris)的类别(Species)对萼片(sepal)的长度进行排序，其余的列随之变化 # 对萼片的长度排序 iris[order(iris$Species, iris$Sepal.Length), ] #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 14 4.3 3.0 1.1 0.1 setosa #&gt; 9 4.4 2.9 1.4 0.2 setosa #&gt; 39 4.4 3.0 1.3 0.2 setosa #&gt; 43 4.4 3.2 1.3 0.2 setosa #&gt; 42 4.5 2.3 1.3 0.3 setosa .... # 对花瓣的长度排序 iris[order(iris$Species, iris$Petal.Length), ] #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 23 4.6 3.6 1.0 0.2 setosa #&gt; 14 4.3 3.0 1.1 0.1 setosa #&gt; 15 5.8 4.0 1.2 0.2 setosa #&gt; 36 5.0 3.2 1.2 0.2 setosa #&gt; 3 4.7 3.2 1.3 0.2 setosa .... # 先对花瓣的宽度排序，再对花瓣的长度排序 iris[order(iris$Petal.Width, iris$Petal.Length), ] #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 14 4.3 3.0 1.1 0.1 setosa #&gt; 13 4.8 3.0 1.4 0.1 setosa #&gt; 38 4.9 3.6 1.4 0.1 setosa #&gt; 10 4.9 3.1 1.5 0.1 setosa #&gt; 33 5.2 4.1 1.5 0.1 setosa .... sort/ordered 排序， 默认是升序 dd &lt;- data.frame( b = factor(c(&quot;Hi&quot;, &quot;Med&quot;, &quot;Hi&quot;, &quot;Low&quot;), levels = c(&quot;Low&quot;, &quot;Med&quot;, &quot;Hi&quot;), ordered = TRUE ), x = c(&quot;A&quot;, &quot;D&quot;, &quot;A&quot;, &quot;C&quot;), y = c(8, 3, 9, 9), z = c(1, 1, 1, 2) ) str(dd) #&gt; &#39;data.frame&#39;: 4 obs. of 4 variables: #&gt; $ b: Ord.factor w/ 3 levels &quot;Low&quot;&lt;&quot;Med&quot;&lt;&quot;Hi&quot;: 3 2 3 1 #&gt; $ x: chr &quot;A&quot; &quot;D&quot; &quot;A&quot; &quot;C&quot; #&gt; $ y: num 8 3 9 9 #&gt; $ z: num 1 1 1 2 dd[order(-dd[,4], dd[,1]), ] #&gt; b x y z #&gt; 4 Low C 9 2 #&gt; 2 Med D 3 1 #&gt; 1 Hi A 8 1 #&gt; 3 Hi A 9 1 根据变量 z dd[order(dd$z, dd$b), ] #&gt; b x y z #&gt; 2 Med D 3 1 #&gt; 1 Hi A 8 1 #&gt; 3 Hi A 9 1 #&gt; 4 Low C 9 2 3.6 数据拆分 数据拆分通常是按找某一个分类变量分组，分完组就是计算，计算完就把结果按照原来的分组方式合并 ## Notice that assignment form is not used since a variable is being added g &lt;- airquality$Month l &lt;- split(airquality, g) # 分组 l &lt;- lapply(l, transform, Oz.Z = scale(Ozone)) # 计算：按月对 Ozone 标准化 aq2 &lt;- unsplit(l, g) # 合并 head(aq2) #&gt; Ozone Solar.R Wind Temp Month Day Oz.Z #&gt; 1 41 190 7.4 67 5 1 0.7822293 #&gt; 2 36 118 8.0 72 5 2 0.5572518 #&gt; 3 12 149 12.6 74 5 3 -0.5226399 #&gt; 4 18 313 11.5 62 5 4 -0.2526670 #&gt; 5 NA NA 14.3 56 5 5 NA #&gt; 6 28 NA 14.9 66 5 6 0.1972879 tapply 自带分组的功能，按月份 Month 对 Ozone 中心标准化，其返回一个列表 with(airquality, tapply(Ozone, Month, scale)) #&gt; $`5` #&gt; [,1] #&gt; [1,] 0.78222929 #&gt; [2,] 0.55725184 #&gt; [3,] -0.52263993 #&gt; [4,] -0.25266698 #&gt; [5,] NA #&gt; [6,] 0.19728792 #&gt; [7,] -0.02768953 #&gt; [8,] -0.20767149 .... 上面的过程等价于 do.call(&quot;rbind&quot;, lapply(split(airquality, airquality$Month), transform, Oz.Z = scale(Ozone))) #&gt; Ozone Solar.R Wind Temp Month Day Oz.Z #&gt; 5.1 41 190 7.4 67 5 1 0.782229293 #&gt; 5.2 36 118 8.0 72 5 2 0.557251841 #&gt; 5.3 12 149 12.6 74 5 3 -0.522639926 #&gt; 5.4 18 313 11.5 62 5 4 -0.252666984 #&gt; 5.5 NA NA 14.3 56 5 5 NA #&gt; 5.6 28 NA 14.9 66 5 6 0.197287919 #&gt; 5.7 23 299 8.6 65 5 7 -0.027689532 #&gt; 5.8 19 99 13.8 59 5 8 -0.207671494 #&gt; 5.9 8 19 20.1 61 5 9 -0.702621887 .... 由于上面对 Ozone 正态标准化，所以标准化后的 Oz.z 再按月分组计算方差自然每个月都是 1，而均值都是 0。 with(aq2, tapply(Oz.Z, Month, sd, na.rm = TRUE)) #&gt; 5 6 7 8 9 #&gt; 1 1 1 1 1 with(aq2, tapply(Oz.Z, Month, mean, na.rm = TRUE)) #&gt; 5 6 7 8 9 #&gt; -4.240273e-17 1.052760e-16 5.841432e-17 5.898060e-17 2.571709e-17 循着这个思路，我们可以用 tapply 实现分组计算，上面函数 sd 和 mean 完全可以用自定义的更加复杂的函数替代 cut 函数可以将连续型变量划分为分类变量 set.seed(2019) Z &lt;- stats::rnorm(10) cut(Z, breaks = -6:6) #&gt; [1] (0,1] (-1,0] (-2,-1] (0,1] (-2,-1] (0,1] (-1,0] (0,1] #&gt; [9] (-2,-1] (-1,0] #&gt; 12 Levels: (-6,-5] (-5,-4] (-4,-3] (-3,-2] (-2,-1] (-1,0] (0,1] ... (5,6] # labels = FALSE 返回每个数所落的区间位置 cut(Z, breaks = -6:6, labels = FALSE) #&gt; [1] 7 6 5 7 5 7 6 7 5 6 我们还可以指定参数 dig.lab 设置分组的精度，ordered 将分组变量看作是有序的，breaks 传递单个数时，表示分组数，而不是断点 cut(Z, breaks = 3, dig.lab = 4, ordered = TRUE) #&gt; [1] (0.06396,0.9186] (-0.7881,0.06396] (-1.643,-0.7881] #&gt; [4] (0.06396,0.9186] (-1.643,-0.7881] (0.06396,0.9186] #&gt; [7] (-0.7881,0.06396] (0.06396,0.9186] (-1.643,-0.7881] #&gt; [10] (-0.7881,0.06396] #&gt; Levels: (-1.643,-0.7881] &lt; (-0.7881,0.06396] &lt; (0.06396,0.9186] 此时，统计每组的频数，如图 3.1 # 条形图 plot(cut(Z, breaks = -6:6)) # 直方图 hist(Z, breaks = -6:6) 图 3.1: 连续型变量分组统计 在指定分组数的情况下，我们还想获取分组的断点 labs &lt;- levels(cut(Z, 3)) labs #&gt; [1] &quot;(-1.64,-0.788]&quot; &quot;(-0.788,0.064]&quot; &quot;(0.064,0.919]&quot; 用正则表达式抽取断点 cbind( lower = as.numeric(sub(&quot;\\\\((.+),.*&quot;, &quot;\\\\1&quot;, labs)), upper = as.numeric(sub(&quot;[^,]*,([^]]*)\\\\]&quot;, &quot;\\\\1&quot;, labs)) ) #&gt; lower upper #&gt; [1,] -1.640 -0.788 #&gt; [2,] -0.788 0.064 #&gt; [3,] 0.064 0.919 更多相关函数可以参考 findInterval 和 embed tabulate 和 table 有所不同，它表示排列 t(combn(8, 4, tabulate, nbins = 8)) #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #&gt; [1,] 1 1 1 1 0 0 0 0 #&gt; [2,] 1 1 1 0 1 0 0 0 #&gt; [3,] 1 1 1 0 0 1 0 0 #&gt; [4,] 1 1 1 0 0 0 1 0 #&gt; [5,] 1 1 1 0 0 0 0 1 .... 3.7 数据合并 merge 合并两个数据框 authors &lt;- data.frame( ## I(*) : use character columns of names to get sensible sort order surname = I(c(&quot;Tukey&quot;, &quot;Venables&quot;, &quot;Tierney&quot;, &quot;Ripley&quot;, &quot;McNeil&quot;)), nationality = c(&quot;US&quot;, &quot;Australia&quot;, &quot;US&quot;, &quot;UK&quot;, &quot;Australia&quot;), deceased = c(&quot;yes&quot;, rep(&quot;no&quot;, 4)) ) authorN &lt;- within(authors, { name &lt;- surname rm(surname) }) books &lt;- data.frame( name = I(c( &quot;Tukey&quot;, &quot;Venables&quot;, &quot;Tierney&quot;, &quot;Ripley&quot;, &quot;Ripley&quot;, &quot;McNeil&quot;, &quot;R Core&quot; )), title = c( &quot;Exploratory Data Analysis&quot;, &quot;Modern Applied Statistics ...&quot;, &quot;LISP-STAT&quot;, &quot;Spatial Statistics&quot;, &quot;Stochastic Simulation&quot;, &quot;Interactive Data Analysis&quot;, &quot;An Introduction to R&quot; ), other.author = c( NA, &quot;Ripley&quot;, NA, NA, NA, NA, &quot;Venables &amp; Smith&quot; ) ) authors #&gt; surname nationality deceased #&gt; 1 Tukey US yes #&gt; 2 Venables Australia no #&gt; 3 Tierney US no #&gt; 4 Ripley UK no #&gt; 5 McNeil Australia no authorN #&gt; nationality deceased name #&gt; 1 US yes Tukey #&gt; 2 Australia no Venables #&gt; 3 US no Tierney #&gt; 4 UK no Ripley #&gt; 5 Australia no McNeil books #&gt; name title other.author #&gt; 1 Tukey Exploratory Data Analysis &lt;NA&gt; #&gt; 2 Venables Modern Applied Statistics ... Ripley #&gt; 3 Tierney LISP-STAT &lt;NA&gt; #&gt; 4 Ripley Spatial Statistics &lt;NA&gt; #&gt; 5 Ripley Stochastic Simulation &lt;NA&gt; #&gt; 6 McNeil Interactive Data Analysis &lt;NA&gt; #&gt; 7 R Core An Introduction to R Venables &amp; Smith 默认找到同名的列，然后是同名的行合并，多余的没有匹配到的就丢掉 merge(authorN, books) #&gt; name nationality deceased title other.author #&gt; 1 McNeil Australia no Interactive Data Analysis &lt;NA&gt; #&gt; 2 Ripley UK no Spatial Statistics &lt;NA&gt; #&gt; 3 Ripley UK no Stochastic Simulation &lt;NA&gt; #&gt; 4 Tierney US no LISP-STAT &lt;NA&gt; #&gt; 5 Tukey US yes Exploratory Data Analysis &lt;NA&gt; #&gt; 6 Venables Australia no Modern Applied Statistics ... Ripley 还可以指定合并的列，先按照 surname 合并，留下 surname merge(authors, books, by.x = &quot;surname&quot;, by.y = &quot;name&quot;) #&gt; surname nationality deceased title other.author #&gt; 1 McNeil Australia no Interactive Data Analysis &lt;NA&gt; #&gt; 2 Ripley UK no Spatial Statistics &lt;NA&gt; #&gt; 3 Ripley UK no Stochastic Simulation &lt;NA&gt; #&gt; 4 Tierney US no LISP-STAT &lt;NA&gt; #&gt; 5 Tukey US yes Exploratory Data Analysis &lt;NA&gt; #&gt; 6 Venables Australia no Modern Applied Statistics ... Ripley 留下的是 name merge(books, authors, by.x = &quot;name&quot;, by.y = &quot;surname&quot;) #&gt; name title other.author nationality deceased #&gt; 1 McNeil Interactive Data Analysis &lt;NA&gt; Australia no #&gt; 2 Ripley Spatial Statistics &lt;NA&gt; UK no #&gt; 3 Ripley Stochastic Simulation &lt;NA&gt; UK no #&gt; 4 Tierney LISP-STAT &lt;NA&gt; US no #&gt; 5 Tukey Exploratory Data Analysis &lt;NA&gt; US yes #&gt; 6 Venables Modern Applied Statistics ... Ripley Australia no 为了比较清楚地观察几种合并的区别，这里提供对应的动画展示 https://github.com/gadenbuie/tidyexplain (inner, outer, left, right, cross) join 共5种合并方式详情请看 https://stackoverflow.com/questions/1299871 cbind 和 rbind 分别是按列和行合并数据框 3.8 数据去重 单个数值型向量去重，此时和 unique 函数作用一样 (x &lt;- c(9:20, 1:5, 3:7, 0:8)) #&gt; [1] 9 10 11 12 13 14 15 16 17 18 19 20 1 2 3 4 5 3 4 5 6 7 0 #&gt; [24] 1 2 3 4 5 6 7 8 ## extract unique elements x[!duplicated(x)] #&gt; [1] 9 10 11 12 13 14 15 16 17 18 19 20 1 2 3 4 5 6 7 0 8 unique(x) #&gt; [1] 9 10 11 12 13 14 15 16 17 18 19 20 1 2 3 4 5 6 7 0 8 数据框类型数据中，去除重复的行，这个重复可以是多个变量对应的向量 set.seed(123) df &lt;- data.frame( x = sample(0:1, 10, replace = T), y = sample(0:1, 10, replace = T), z = 1:10 ) df #&gt; x y z #&gt; 1 0 1 1 #&gt; 2 0 1 2 #&gt; 3 0 1 3 #&gt; 4 1 0 4 #&gt; 5 0 1 5 #&gt; 6 1 0 6 #&gt; 7 1 1 7 #&gt; 8 1 0 8 #&gt; 9 0 0 9 #&gt; 10 0 0 10 df[!duplicated(df[, 1:2]), ] #&gt; x y z #&gt; 1 0 1 1 #&gt; 4 1 0 4 #&gt; 7 1 1 7 #&gt; 9 0 0 9 3.9 数据聚合 分组求和 https://stackoverflow.com/questions/1660124 主要是分组统计 apropos(&quot;apply&quot;) #&gt; [1] &quot;apply&quot; &quot;dendrapply&quot; &quot;eapply&quot; &quot;kernapply&quot; &quot;lapply&quot; #&gt; [6] &quot;mapply&quot; &quot;rapply&quot; &quot;sapply&quot; &quot;tapply&quot; &quot;vapply&quot; # 分组求和 colSums colMeans max unique(iris$Species) #&gt; [1] setosa versicolor virginica #&gt; Levels: setosa versicolor virginica # 分类求和 # colSums(iris[iris$Species == &quot;setosa&quot;, -5]) # colSums(iris[iris$Species == &quot;virginica&quot;, -5]) colSums(iris[iris$Species == &quot;versicolor&quot;, -5]) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; 296.8 138.5 213.0 66.3 # apply(iris[iris$Species == &quot;setosa&quot;, -5], 2, sum) # apply(iris[iris$Species == &quot;setosa&quot;, -5], 2, mean) # apply(iris[iris$Species == &quot;setosa&quot;, -5], 2, min) # apply(iris[iris$Species == &quot;setosa&quot;, -5], 2, max) apply(iris[iris$Species == &quot;setosa&quot;, -5], 2, quantile) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; 0% 4.3 2.300 1.000 0.1 #&gt; 25% 4.8 3.200 1.400 0.2 #&gt; 50% 5.0 3.400 1.500 0.2 #&gt; 75% 5.2 3.675 1.575 0.3 #&gt; 100% 5.8 4.400 1.900 0.6 aggregate: Compute Summary Statistics of Data Subsets # 按分类变量 Species 分组求和 # aggregate(subset(iris, select = -Species), by = list(iris[, &quot;Species&quot;]), FUN = sum) aggregate(iris[, -5], list(iris[, 5]), sum) #&gt; Group.1 Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; 1 setosa 250.3 171.4 73.1 12.3 #&gt; 2 versicolor 296.8 138.5 213.0 66.3 #&gt; 3 virginica 329.4 148.7 277.6 101.3 # 先确定位置，假设有很多分类变量 ind &lt;- which(&quot;Species&quot; == colnames(iris)) # 分组统计 aggregate(iris[, -ind], list(iris[, ind]), sum) #&gt; Group.1 Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; 1 setosa 250.3 171.4 73.1 12.3 #&gt; 2 versicolor 296.8 138.5 213.0 66.3 #&gt; 3 virginica 329.4 148.7 277.6 101.3 按照 Species 划分的类别，分组计算，使用公式表示形式，右边一定是分类变量，否则会报错误或者警告，输出奇怪的结果，请读者尝试运行aggregate(Species ~ Sepal.Length, data = iris, mean)。公式法表示分组计算，~ 左手边可以做加 + 减 - 乘 * 除 / 取余 %% 等数学运算。下面以数据集 iris 为例，只对 Sepal.Length 按 Species 分组计算 aggregate(Sepal.Length ~ Species, data = iris, mean) #&gt; Species Sepal.Length #&gt; 1 setosa 5.006 #&gt; 2 versicolor 5.936 #&gt; 3 virginica 6.588 与上述分组统计结果一样的命令，在大数据集上， 与 aggregate 相比，tapply 要快很多，by 是 tapply 的包裹，处理速度差不多。读者可以构造伪随机数据集验证。 # tapply(iris$Sepal.Length, list(iris$Species), mean) with(iris, tapply(Sepal.Length, Species, mean)) #&gt; setosa versicolor virginica #&gt; 5.006 5.936 6.588 by(iris$Sepal.Length, iris$Species, mean) #&gt; iris$Species: setosa #&gt; [1] 5.006 #&gt; -------------------------------------------------------- #&gt; iris$Species: versicolor #&gt; [1] 5.936 #&gt; -------------------------------------------------------- #&gt; iris$Species: virginica #&gt; [1] 6.588 对所有变量按 Species 分组计算 aggregate(. ~ Species, data = iris, mean) #&gt; Species Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; 1 setosa 5.006 3.428 1.462 0.246 #&gt; 2 versicolor 5.936 2.770 4.260 1.326 #&gt; 3 virginica 6.588 2.974 5.552 2.026 对变量 Sepal.Length 和 Sepal.Width 求和后，按 Species 分组计算 aggregate(Sepal.Length + Sepal.Width ~ Species, data = iris, mean) #&gt; Species Sepal.Length + Sepal.Width #&gt; 1 setosa 8.434 #&gt; 2 versicolor 8.706 #&gt; 3 virginica 9.562 对多个分类变量做分组计算，在数据集 ChickWeight 中 Chick和Diet都是数字编码的分类变量，其中 Chick 是有序的因子变量，Diet 是无序的因子变量，而 Time 是数值型的变量，表示小鸡出生的天数。 # 查看数据 str(ChickWeight) #&gt; Classes &#39;nfnGroupedData&#39;, &#39;nfGroupedData&#39;, &#39;groupedData&#39; and &#39;data.frame&#39;: 578 obs. of 4 variables: #&gt; $ weight: num 42 51 59 64 76 93 106 125 149 171 ... #&gt; $ Time : num 0 2 4 6 8 10 12 14 16 18 ... #&gt; $ Chick : Ord.factor w/ 50 levels &quot;18&quot;&lt;&quot;16&quot;&lt;&quot;15&quot;&lt;..: 15 15 15 15 15 15 1.. #&gt; $ Diet : Factor w/ 4 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;: 1 1 1 1 1 1 1 1 1 1 ... #&gt; - attr(*, &quot;formula&quot;)=Class &#39;formula&#39; language weight ~ Time | Chick #&gt; .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_EmptyEnv&gt; #&gt; - attr(*, &quot;outer&quot;)=Class &#39;formula&#39; language ~Diet #&gt; .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_EmptyEnv&gt; #&gt; - attr(*, &quot;labels&quot;)=List of 2 #&gt; ..$ x: chr &quot;Time&quot; #&gt; ..$ y: chr &quot;Body weight&quot; #&gt; - attr(*, &quot;units&quot;)=List of 2 #&gt; ..$ x: chr &quot;(days)&quot; #&gt; ..$ y: chr &quot;(gm)&quot; 查看数据集ChickWeight的前几行 head(ChickWeight) #&gt; weight Time Chick Diet #&gt; 1 42 0 1 1 #&gt; 2 51 2 1 1 #&gt; 3 59 4 1 1 #&gt; 4 64 6 1 1 #&gt; 5 76 8 1 1 .... str(ChickWeight) #&gt; Classes &#39;nfnGroupedData&#39;, &#39;nfGroupedData&#39;, &#39;groupedData&#39; and &#39;data.frame&#39;: 578 obs. of 4 variables: #&gt; $ weight: num 42 51 59 64 76 93 106 125 149 171 ... #&gt; $ Time : num 0 2 4 6 8 10 12 14 16 18 ... #&gt; $ Chick : Ord.factor w/ 50 levels &quot;18&quot;&lt;&quot;16&quot;&lt;&quot;15&quot;&lt;..: 15 15 15 15 15 15 1.. #&gt; $ Diet : Factor w/ 4 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;: 1 1 1 1 1 1 1 1 1 1 ... #&gt; - attr(*, &quot;formula&quot;)=Class &#39;formula&#39; language weight ~ Time | Chick .... 对于数据集ChickWeight中的有序变量Chick，aggregate 会按照既定顺序返回分组计算的结果 aggregate(weight ~ Chick, data = ChickWeight, mean) #&gt; Chick weight #&gt; 1 18 37.00000 #&gt; 2 16 49.71429 #&gt; 3 15 60.12500 #&gt; 4 13 67.83333 #&gt; 5 9 81.16667 .... aggregate(weight ~ Diet, data = ChickWeight, mean) #&gt; Diet weight #&gt; 1 1 102.6455 #&gt; 2 2 122.6167 #&gt; 3 3 142.9500 #&gt; 4 4 135.2627 分类变量没有用数字编码，以 CO2 数据集为例，该数据集描述草植对二氧化碳的吸收情况，Plant 是具有12个水平的有序的因子变量，Type表示植物的源头分别是魁北克(Quebec)和密西西比(Mississippi)，Treatment表示冷却(chilled)和不冷却(nonchilled)两种处理方式，conc表示周围环境中二氧化碳的浓度，uptake表示植物吸收二氧化碳的速率。 # 查看数据集 head(CO2) #&gt; Plant Type Treatment conc uptake #&gt; 1 Qn1 Quebec nonchilled 95 16.0 #&gt; 2 Qn1 Quebec nonchilled 175 30.4 #&gt; 3 Qn1 Quebec nonchilled 250 34.8 #&gt; 4 Qn1 Quebec nonchilled 350 37.2 #&gt; 5 Qn1 Quebec nonchilled 500 35.3 #&gt; 6 Qn1 Quebec nonchilled 675 39.2 str(CO2) #&gt; Classes &#39;nfnGroupedData&#39;, &#39;nfGroupedData&#39;, &#39;groupedData&#39; and &#39;data.frame&#39;: 84 obs. of 5 variables: #&gt; $ Plant : Ord.factor w/ 12 levels &quot;Qn1&quot;&lt;&quot;Qn2&quot;&lt;&quot;Qn3&quot;&lt;..: 1 1 1 1 1 1 1.. #&gt; $ Type : Factor w/ 2 levels &quot;Quebec&quot;,&quot;Mississippi&quot;: 1 1 1 1 1 1 1 1 .. #&gt; $ Treatment: Factor w/ 2 levels &quot;nonchilled&quot;,&quot;chilled&quot;: 1 1 1 1 1 1 1 1 .. #&gt; $ conc : num 95 175 250 350 500 675 1000 95 175 250 ... #&gt; $ uptake : num 16 30.4 34.8 37.2 35.3 39.2 39.7 13.6 27.3 37.1 ... #&gt; - attr(*, &quot;formula&quot;)=Class &#39;formula&#39; language uptake ~ conc | Plant #&gt; .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_EmptyEnv&gt; #&gt; - attr(*, &quot;outer&quot;)=Class &#39;formula&#39; language ~Treatment * Type #&gt; .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_EmptyEnv&gt; #&gt; - attr(*, &quot;labels&quot;)=List of 2 #&gt; ..$ x: chr &quot;Ambient carbon dioxide concentration&quot; #&gt; ..$ y: chr &quot;CO2 uptake rate&quot; #&gt; - attr(*, &quot;units&quot;)=List of 2 #&gt; ..$ x: chr &quot;(uL/L)&quot; #&gt; ..$ y: chr &quot;(umol/m^2 s)&quot; 对单个变量分组统计 aggregate(uptake ~ Plant, data = CO2, mean) #&gt; Plant uptake #&gt; 1 Qn1 33.22857 #&gt; 2 Qn2 35.15714 #&gt; 3 Qn3 37.61429 #&gt; 4 Qc1 29.97143 #&gt; 5 Qc3 32.58571 #&gt; 6 Qc2 32.70000 #&gt; 7 Mn3 24.11429 #&gt; 8 Mn2 27.34286 #&gt; 9 Mn1 26.40000 #&gt; 10 Mc2 12.14286 #&gt; 11 Mc3 17.30000 #&gt; 12 Mc1 18.00000 aggregate(uptake ~ Type, data = CO2, mean) #&gt; Type uptake #&gt; 1 Quebec 33.54286 #&gt; 2 Mississippi 20.88333 aggregate(uptake ~ Treatment, data = CO2, mean) #&gt; Treatment uptake #&gt; 1 nonchilled 30.64286 #&gt; 2 chilled 23.78333 对多个变量分组统计，查看二氧化碳吸收速率uptake随类型Type和处理方式Treatment aggregate(uptake ~ Type + Treatment, data = CO2, mean) #&gt; Type Treatment uptake #&gt; 1 Quebec nonchilled 35.33333 #&gt; 2 Mississippi nonchilled 25.95238 #&gt; 3 Quebec chilled 31.75238 #&gt; 4 Mississippi chilled 15.81429 tapply(CO2$uptake, list(CO2$Type, CO2$Treatment), mean) #&gt; nonchilled chilled #&gt; Quebec 35.33333 31.75238 #&gt; Mississippi 25.95238 15.81429 by(CO2$uptake, list(CO2$Type, CO2$Treatment), mean) #&gt; : Quebec #&gt; : nonchilled #&gt; [1] 35.33333 #&gt; -------------------------------------------------------- #&gt; : Mississippi #&gt; : nonchilled #&gt; [1] 25.95238 #&gt; -------------------------------------------------------- #&gt; : Quebec #&gt; : chilled #&gt; [1] 31.75238 #&gt; -------------------------------------------------------- #&gt; : Mississippi #&gt; : chilled #&gt; [1] 15.81429 在这个例子中 tapply 和 by 的输出结果的表示形式不一样，aggregate 返回一个 data.frame 数据框，tapply 返回一个表格 table，by 返回特殊的数据类型 by。 Function by is an object-oriented wrapper for tapply applied to data frames. # 分组求和 # by(iris[, 1], INDICES = list(iris$Species), FUN = sum) # by(iris[, 2], INDICES = list(iris$Species), FUN = sum) by(iris[, 3], INDICES = list(iris$Species), FUN = sum) #&gt; : setosa #&gt; [1] 73.1 #&gt; -------------------------------------------------------- #&gt; : versicolor #&gt; [1] 213 #&gt; -------------------------------------------------------- #&gt; : virginica #&gt; [1] 277.6 by(iris[1:3], INDICES = list(iris$Species), FUN = sum) #&gt; : setosa #&gt; [1] 494.8 #&gt; -------------------------------------------------------- #&gt; : versicolor #&gt; [1] 648.3 #&gt; -------------------------------------------------------- #&gt; : virginica #&gt; [1] 755.7 by(iris[1:3], INDICES = list(iris$Species), FUN = summary) #&gt; : setosa #&gt; Sepal.Length Sepal.Width Petal.Length #&gt; Min. :4.300 Min. :2.300 Min. :1.000 #&gt; 1st Qu.:4.800 1st Qu.:3.200 1st Qu.:1.400 #&gt; Median :5.000 Median :3.400 Median :1.500 #&gt; Mean :5.006 Mean :3.428 Mean :1.462 #&gt; 3rd Qu.:5.200 3rd Qu.:3.675 3rd Qu.:1.575 #&gt; Max. :5.800 Max. :4.400 Max. :1.900 #&gt; -------------------------------------------------------- #&gt; : versicolor #&gt; Sepal.Length Sepal.Width Petal.Length #&gt; Min. :4.900 Min. :2.000 Min. :3.00 #&gt; 1st Qu.:5.600 1st Qu.:2.525 1st Qu.:4.00 #&gt; Median :5.900 Median :2.800 Median :4.35 #&gt; Mean :5.936 Mean :2.770 Mean :4.26 #&gt; 3rd Qu.:6.300 3rd Qu.:3.000 3rd Qu.:4.60 #&gt; Max. :7.000 Max. :3.400 Max. :5.10 #&gt; -------------------------------------------------------- #&gt; : virginica #&gt; Sepal.Length Sepal.Width Petal.Length #&gt; Min. :4.900 Min. :2.200 Min. :4.500 #&gt; 1st Qu.:6.225 1st Qu.:2.800 1st Qu.:5.100 #&gt; Median :6.500 Median :3.000 Median :5.550 #&gt; Mean :6.588 Mean :2.974 Mean :5.552 #&gt; 3rd Qu.:6.900 3rd Qu.:3.175 3rd Qu.:5.875 #&gt; Max. :7.900 Max. :3.800 Max. :6.900 by(iris, INDICES = list(iris$Species), FUN = summary) #&gt; : setosa #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; Min. :4.300 Min. :2.300 Min. :1.000 Min. :0.100 #&gt; 1st Qu.:4.800 1st Qu.:3.200 1st Qu.:1.400 1st Qu.:0.200 #&gt; Median :5.000 Median :3.400 Median :1.500 Median :0.200 #&gt; Mean :5.006 Mean :3.428 Mean :1.462 Mean :0.246 #&gt; 3rd Qu.:5.200 3rd Qu.:3.675 3rd Qu.:1.575 3rd Qu.:0.300 #&gt; Max. :5.800 Max. :4.400 Max. :1.900 Max. :0.600 #&gt; Species #&gt; setosa :50 #&gt; versicolor: 0 #&gt; virginica : 0 #&gt; #&gt; #&gt; #&gt; -------------------------------------------------------- #&gt; : versicolor #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; Min. :4.900 Min. :2.000 Min. :3.00 Min. :1.000 #&gt; 1st Qu.:5.600 1st Qu.:2.525 1st Qu.:4.00 1st Qu.:1.200 #&gt; Median :5.900 Median :2.800 Median :4.35 Median :1.300 #&gt; Mean :5.936 Mean :2.770 Mean :4.26 Mean :1.326 #&gt; 3rd Qu.:6.300 3rd Qu.:3.000 3rd Qu.:4.60 3rd Qu.:1.500 #&gt; Max. :7.000 Max. :3.400 Max. :5.10 Max. :1.800 #&gt; Species #&gt; setosa : 0 #&gt; versicolor:50 #&gt; virginica : 0 #&gt; #&gt; #&gt; #&gt; -------------------------------------------------------- #&gt; : virginica #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; Min. :4.900 Min. :2.200 Min. :4.500 Min. :1.400 #&gt; 1st Qu.:6.225 1st Qu.:2.800 1st Qu.:5.100 1st Qu.:1.800 #&gt; Median :6.500 Median :3.000 Median :5.550 Median :2.000 #&gt; Mean :6.588 Mean :2.974 Mean :5.552 Mean :2.026 #&gt; 3rd Qu.:6.900 3rd Qu.:3.175 3rd Qu.:5.875 3rd Qu.:2.300 #&gt; Max. :7.900 Max. :3.800 Max. :6.900 Max. :2.500 #&gt; Species #&gt; setosa : 0 #&gt; versicolor: 0 #&gt; virginica :50 #&gt; #&gt; #&gt; Group Averages Over Level Combinations of Factors 分组平均 str(warpbreaks) #&gt; &#39;data.frame&#39;: 54 obs. of 3 variables: #&gt; $ breaks : num 26 30 54 25 70 52 51 26 67 18 ... #&gt; $ wool : Factor w/ 2 levels &quot;A&quot;,&quot;B&quot;: 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ tension: Factor w/ 3 levels &quot;L&quot;,&quot;M&quot;,&quot;H&quot;: 1 1 1 1 1 1 1 1 1 2 ... head(warpbreaks) #&gt; breaks wool tension #&gt; 1 26 A L #&gt; 2 30 A L #&gt; 3 54 A L #&gt; 4 25 A L #&gt; 5 70 A L #&gt; 6 52 A L ave(warpbreaks$breaks, warpbreaks$wool) #&gt; [1] 31.03704 31.03704 31.03704 31.03704 31.03704 31.03704 31.03704 #&gt; [8] 31.03704 31.03704 31.03704 31.03704 31.03704 31.03704 31.03704 #&gt; [15] 31.03704 31.03704 31.03704 31.03704 31.03704 31.03704 31.03704 #&gt; [22] 31.03704 31.03704 31.03704 31.03704 31.03704 31.03704 25.25926 #&gt; [29] 25.25926 25.25926 25.25926 25.25926 25.25926 25.25926 25.25926 #&gt; [36] 25.25926 25.25926 25.25926 25.25926 25.25926 25.25926 25.25926 #&gt; [43] 25.25926 25.25926 25.25926 25.25926 25.25926 25.25926 25.25926 #&gt; [50] 25.25926 25.25926 25.25926 25.25926 25.25926 with(warpbreaks, ave(breaks, tension, FUN = function(x) mean(x, trim = 0.1))) #&gt; [1] 35.6875 35.6875 35.6875 35.6875 35.6875 35.6875 35.6875 35.6875 #&gt; [9] 35.6875 26.3125 26.3125 26.3125 26.3125 26.3125 26.3125 26.3125 #&gt; [17] 26.3125 26.3125 21.0625 21.0625 21.0625 21.0625 21.0625 21.0625 #&gt; [25] 21.0625 21.0625 21.0625 35.6875 35.6875 35.6875 35.6875 35.6875 #&gt; [33] 35.6875 35.6875 35.6875 35.6875 26.3125 26.3125 26.3125 26.3125 #&gt; [41] 26.3125 26.3125 26.3125 26.3125 26.3125 21.0625 21.0625 21.0625 #&gt; [49] 21.0625 21.0625 21.0625 21.0625 21.0625 21.0625 # 分组求和 with(warpbreaks, ave(breaks, tension, FUN = function(x) sum(x))) #&gt; [1] 655 655 655 655 655 655 655 655 655 475 475 475 475 475 475 475 475 #&gt; [18] 475 390 390 390 390 390 390 390 390 390 655 655 655 655 655 655 655 #&gt; [35] 655 655 475 475 475 475 475 475 475 475 475 390 390 390 390 390 390 #&gt; [52] 390 390 390 # 分组求和 with(iris, ave(Sepal.Length, Species, FUN = function(x) sum(x))) #&gt; [1] 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 #&gt; [12] 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 #&gt; [23] 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 #&gt; [34] 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 #&gt; [45] 250.3 250.3 250.3 250.3 250.3 250.3 296.8 296.8 296.8 296.8 296.8 #&gt; [56] 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 #&gt; [67] 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 #&gt; [78] 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 #&gt; [89] 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 #&gt; [100] 296.8 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 #&gt; [111] 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 #&gt; [122] 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 #&gt; [133] 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 #&gt; [144] 329.4 329.4 329.4 329.4 329.4 329.4 329.4 3.10 表格统计 介绍操作表格的 table, addmargins, prop.table, xtabs, margin.table, ftabe 等函数 table 多个分类变量分组计数统计 介绍 warpbreaks 和 airquality 纽约空气质量监测数据集 二维的数据框 UCBAdmissions 1973 年加州大学伯克利分校的院系录取数据集 3维的列联表 Titanic 4维的列联表数据 泰坦尼克号幸存者数据集 with(warpbreaks, table(wool, tension)) #&gt; tension #&gt; wool L M H #&gt; A 9 9 9 #&gt; B 9 9 9 以 iris 数据集为例，table 的第一个参数是自己制造的第二个分类变量，原始分类变量是 Species with(iris, table(Sepal.check = Sepal.Length &gt; 7, Species)) #&gt; Species #&gt; Sepal.check setosa versicolor virginica #&gt; FALSE 50 50 38 #&gt; TRUE 0 0 12 with(iris, table(Sepal.check = Sepal.Length &gt; mean(Sepal.Length), Species)) #&gt; Species #&gt; Sepal.check setosa versicolor virginica #&gt; FALSE 50 24 6 #&gt; TRUE 0 26 44 以 airquality 数据集为例，看看月份中臭氧含量比较高的几天 aiq.tab &lt;- with(airquality, table(Oz.high = Ozone &gt; 80, Month)) aiq.tab #&gt; Month #&gt; Oz.high 5 6 7 8 9 #&gt; FALSE 25 9 20 19 27 #&gt; TRUE 1 0 6 7 2 对表格按行和列求和，即求表格的边际，查看总体情况 addmargins(aiq.tab, 1:2) #&gt; Month #&gt; Oz.high 5 6 7 8 9 Sum #&gt; FALSE 25 9 20 19 27 100 #&gt; TRUE 1 0 6 7 2 16 #&gt; Sum 26 9 26 26 29 116 臭氧含量超 80 的天数在每个月的占比，addmargins 的第二个参数 1 表示对列求和 aiq.prop &lt;- prop.table(aiq.tab, 2) aiq.prop #&gt; Month #&gt; Oz.high 5 6 7 8 9 #&gt; FALSE 0.96153846 1.00000000 0.76923077 0.73076923 0.93103448 #&gt; TRUE 0.03846154 0.00000000 0.23076923 0.26923077 0.06896552 aiq.marprop &lt;- addmargins(aiq.prop, 1) aiq.marprop #&gt; Month #&gt; Oz.high 5 6 7 8 9 #&gt; FALSE 0.96153846 1.00000000 0.76923077 0.73076923 0.93103448 #&gt; TRUE 0.03846154 0.00000000 0.23076923 0.26923077 0.06896552 #&gt; Sum 1.00000000 1.00000000 1.00000000 1.00000000 1.00000000 转换成百分比，将小数四舍五入转化为百分数，保留两位小数点 round(100 * aiq.marprop, 2) #&gt; Month #&gt; Oz.high 5 6 7 8 9 #&gt; FALSE 96.15 100.00 76.92 73.08 93.10 #&gt; TRUE 3.85 0.00 23.08 26.92 6.90 #&gt; Sum 100.00 100.00 100.00 100.00 100.00 pairs(airquality, panel = panel.smooth, main = &quot;airquality data&quot;) 以 UCBAdmissions 数据集为例，使用 xtabs 函数把数据组织成列联表，先查看数据的内容 UCBAdmissions #&gt; , , Dept = A #&gt; #&gt; Gender #&gt; Admit Male Female #&gt; Admitted 512 89 #&gt; Rejected 313 19 .... UCBA2DF &lt;- as.data.frame(UCBAdmissions) UCBA2DF #&gt; Admit Gender Dept Freq #&gt; 1 Admitted Male A 512 #&gt; 2 Rejected Male A 313 #&gt; 3 Admitted Female A 89 #&gt; 4 Rejected Female A 19 #&gt; 5 Admitted Male B 353 .... 接着将 UCBA2DF 数据集转化为表格的形式 UCBA2DF.tab &lt;- xtabs(Freq ~ Gender + Admit + Dept, data = UCBA2DF) ftable(UCBA2DF.tab) #&gt; Dept A B C D E F #&gt; Gender Admit #&gt; Male Admitted 512 353 120 138 53 22 #&gt; Rejected 313 207 205 279 138 351 #&gt; Female Admitted 89 17 202 131 94 24 #&gt; Rejected 19 8 391 244 299 317 将录取性别和院系进行对比 prop.table(margin.table(UCBA2DF.tab, c(1, 3)), 1) #&gt; Dept #&gt; Gender A B C D E F #&gt; Male 0.30657748 0.20810108 0.12077295 0.15496098 0.07097733 0.13861018 #&gt; Female 0.05885559 0.01362398 0.32316076 0.20435967 0.21416894 0.18583106 男生倾向于申请院系 A 和 B，女生倾向于申请院系 C 到 F，院系 A 和 B 是最容易录取的。 3.11 索引访问 which 与引用 [ 性能比较，在区间 \\([0,1]\\) 上生成 10 万个服从均匀分布的随机数，随机抽取其中\\(\\frac{1}{4}\\)。 n &lt;- 100000 x &lt;- runif(n) i &lt;- logical(n) i[sample(n, n / 4)] &lt;- TRUE microbenchmark::microbenchmark(x[i], x[which(i)], times = 1000) 使用 subset 函数与 [ 比较 3.12 多维数组 多维数组的行列是怎么定义的 ?array 轴的概念，画个图表示数组 array(1:27, c(3, 3, 3)) #&gt; , , 1 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 1 4 7 #&gt; [2,] 2 5 8 #&gt; [3,] 3 6 9 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 10 13 16 #&gt; [2,] 11 14 17 #&gt; [3,] 12 15 18 #&gt; #&gt; , , 3 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 19 22 25 #&gt; [2,] 20 23 26 #&gt; [3,] 21 24 27 垂直于Z轴的平面去截三维立方体，3 代表 z 轴，得到三个截面（二维矩阵） asplit(array(1:27, c(3, 3, 3)), 3) #&gt; [[1]] #&gt; [,1] [,2] [,3] #&gt; [1,] 1 4 7 #&gt; [2,] 2 5 8 #&gt; [3,] 3 6 9 #&gt; #&gt; [[2]] #&gt; [,1] [,2] [,3] #&gt; [1,] 10 13 16 #&gt; [2,] 11 14 17 #&gt; [3,] 12 15 18 #&gt; #&gt; [[3]] #&gt; [,1] [,2] [,3] #&gt; [1,] 19 22 25 #&gt; [2,] 20 23 26 #&gt; [3,] 21 24 27 对每个二维矩阵按列求和 lapply(asplit(array(1:27, c(3, 3, 3)), 3), apply, 2, sum) #&gt; [[1]] #&gt; [1] 6 15 24 #&gt; #&gt; [[2]] #&gt; [1] 33 42 51 #&gt; #&gt; [[3]] #&gt; [1] 60 69 78 asplit 和 lapply 组合处理多维数组的计算问题，多维数组18 三维数组的矩阵运算 abind 包提供更多的数组操作，如合并，替换 3.13 其它操作 成对的数据操作有 list 与 unlist、stack 与 unstack、class 与 unclass、attach 与 detach 以及 with 和 within，它们在数据操作过程中有时会起到一定的补充作用。 3.13.1 列表属性 # 创建列表 list(...) pairlist(...) # 转化列表 as.list(x, ...) ## S3 method for class &#39;environment&#39; as.list(x, all.names = FALSE, sorted = FALSE, ...) as.pairlist(x) # 检查列表 is.list(x) is.pairlist(x) alist(...) list 函数用来构造、转化和检查 R 列表对象。下面创建一个临时列表对象 tmp ，它包含两个元素 A 和 B，两个元素都是向量，前者是数值型，后者是字符型 (tmp &lt;- list(A = c(1, 2, 3), B = c(&quot;a&quot;, &quot;b&quot;))) #&gt; $A #&gt; [1] 1 2 3 #&gt; #&gt; $B #&gt; [1] &quot;a&quot; &quot;b&quot; unlist(x, recursive = TRUE, use.names = TRUE) unlist 函数将给定的列表对象 x 简化为原子向量 (atomic vector)，我们发现简化之后变成一个字符型向量 unlist(tmp) #&gt; A1 A2 A3 B1 B2 #&gt; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;a&quot; &quot;b&quot; unlist(tmp, use.names = FALSE) #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;a&quot; &quot;b&quot; unlist 的逆操作是 relist 3.13.2 堆叠向量 stack(x, ...) ## Default S3 method: stack(x, drop = FALSE, ...) ## S3 method for class &#39;data.frame&#39; stack(x, select, drop = FALSE, ...) unstack(x, ...) ## Default S3 method: unstack(x, form, ...) ## S3 method for class &#39;data.frame&#39; unstack(x, form, ...) stack 与 unstack 将多个向量堆在一起组成一个向量 # 查看数据集 PlantGrowth class(PlantGrowth) #&gt; [1] &quot;data.frame&quot; head(PlantGrowth) #&gt; weight group #&gt; 1 4.17 ctrl #&gt; 2 5.58 ctrl #&gt; 3 5.18 ctrl #&gt; 4 6.11 ctrl #&gt; 5 4.50 ctrl #&gt; 6 4.61 ctrl # 检查默认的公式 formula(PlantGrowth) #&gt; weight ~ group # 根据公式解除堆叠 # 下面等价于 unstack(PlantGrowth, form = weight ~ group) (pg &lt;- unstack(PlantGrowth)) #&gt; ctrl trt1 trt2 #&gt; 1 4.17 4.81 6.31 #&gt; 2 5.58 4.17 5.12 #&gt; 3 5.18 4.41 5.54 #&gt; 4 6.11 3.59 5.50 #&gt; 5 4.50 5.87 5.37 #&gt; 6 4.61 3.83 5.29 #&gt; 7 5.17 6.03 4.92 #&gt; 8 4.53 4.89 6.15 #&gt; 9 5.33 4.32 5.80 #&gt; 10 5.14 4.69 5.26 现在再将变量 pg 堆叠起来，还可以指定要堆叠的列 stack(pg) #&gt; values ind #&gt; 1 4.17 ctrl #&gt; 2 5.58 ctrl #&gt; 3 5.18 ctrl #&gt; 4 6.11 ctrl #&gt; 5 4.50 ctrl .... stack(pg, select = -ctrl) #&gt; values ind #&gt; 1 4.81 trt1 #&gt; 2 4.17 trt1 #&gt; 3 4.41 trt1 #&gt; 4 3.59 trt1 #&gt; 5 5.87 trt1 .... 形式上和 reshape 有一些相似之处，数据框可以由长变宽或由宽变长 3.13.3 属性转化 class(x) class(x) &lt;- value unclass(x) inherits(x, what, which = FALSE) oldClass(x) oldClass(x) &lt;- value class 和 unclass 函数用来查看、设置类属性和取消类属性，常用于面向对象的编程设计中 class(iris) #&gt; [1] &quot;data.frame&quot; class(iris$Species) #&gt; [1] &quot;factor&quot; unclass(iris$Species) #&gt; [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #&gt; [36] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 #&gt; [71] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 #&gt; [106] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 #&gt; [141] 3 3 3 3 3 3 3 3 3 3 #&gt; attr(,&quot;levels&quot;) .... 3.13.4 绑定环境 attach(what, pos = 2L, name = deparse(substitute(what), backtick = FALSE), warn.conflicts = TRUE ) detach(name, pos = 2L, unload = FALSE, character.only = FALSE, force = FALSE ) attach 和 detach 是否绑定数据框的列名，不推荐操作，推荐使用 with attach(iris) head(Species) #&gt; [1] setosa setosa setosa setosa setosa setosa #&gt; Levels: setosa versicolor virginica detach(iris) 3.13.5 数据环境 with(data, expr, ...) within(data, expr, ...) ## S3 method for class &#39;list&#39; within(data, expr, keepAttrs = TRUE, ...) data 参数 data 用来构造表达式计算的环境。其默认值可以是一个环境，列表，数据框。在 within 函数中 data 参数只能是列表或数据框。 expr 参数 expr 包含要计算的表达式。在 within 中通常包含一个复合表达式，比如 { a &lt;- somefun() b &lt;- otherfun() ... rm(unused1, temp) } with 和 within 计算一组表达式，计算的环境是由数据构造的，后者可以修改原始的数据 with(mtcars, mpg[cyl == 8 &amp; disp &gt; 350]) #&gt; [1] 18.7 14.3 10.4 10.4 14.7 19.2 15.8 和下面计算的结果一样，但是更加简洁漂亮 mtcars$mpg[mtcars$cyl == 8 &amp; mtcars$disp &gt; 350] #&gt; [1] 18.7 14.3 10.4 10.4 14.7 19.2 15.8 within 函数可以修改原数据环境中的多个变量，比如删除、修改和添加等 # 原数据集 airquality head(airquality) #&gt; Ozone Solar.R Wind Temp Month Day #&gt; 1 41 190 7.4 67 5 1 #&gt; 2 36 118 8.0 72 5 2 #&gt; 3 12 149 12.6 74 5 3 #&gt; 4 18 313 11.5 62 5 4 #&gt; 5 NA NA 14.3 56 5 5 #&gt; 6 28 NA 14.9 66 5 6 aq &lt;- within(airquality, { lOzone &lt;- log(Ozone) # 取对数 Month &lt;- factor(month.abb[Month]) # 字符串型转因子型 cTemp &lt;- round((Temp - 32) * 5 / 9, 1) # 从华氏温度到摄氏温度转化 S.cT &lt;- Solar.R / cTemp # 使用新创建的变量 rm(Day, Temp) }) # 修改后的数据集 head(aq) #&gt; Ozone Solar.R Wind Month S.cT cTemp lOzone #&gt; 1 41 190 7.4 May 9.793814 19.4 3.713572 #&gt; 2 36 118 8.0 May 5.315315 22.2 3.583519 #&gt; 3 12 149 12.6 May 6.394850 23.3 2.484907 #&gt; 4 18 313 11.5 May 18.742515 16.7 2.890372 #&gt; 5 NA NA 14.3 May NA 13.3 NA #&gt; 6 28 NA 14.9 May NA 18.9 3.332205 下面再举一个复杂的绘图例子，这个例子来自 boxplot 函数 with(ToothGrowth, { boxplot(len ~ dose, boxwex = 0.25, at = 1:3 - 0.2, subset = (supp == &quot;VC&quot;), col = &quot;#4285f4&quot;, main = &quot;Guinea Pigs&#39; Tooth Growth&quot;, xlab = &quot;Vitamin C dose mg&quot;, ylab = &quot;tooth length&quot;, ylim = c(0, 35) ) boxplot(len ~ dose, add = TRUE, boxwex = 0.25, at = 1:3 + 0.2, subset = supp == &quot;OJ&quot;, col = &quot;#EA4335&quot; ) legend(2, 9, c(&quot;Ascorbic acid&quot;, &quot;Orange juice&quot;), fill = c(&quot;#4285f4&quot;, &quot;#EA4335&quot;) ) }) 将 boxplot 函数的 subset 参数单独提出来，调用数据子集选择函数 subset ，这里 with 中只包含一个表达式，所以也可以不用大括号 with( subset(ToothGrowth, supp == &quot;VC&quot;), boxplot(len ~ dose, boxwex = 0.25, at = 1:3 - 0.2, col = &quot;#4285f4&quot;, main = &quot;Guinea Pigs&#39; Tooth Growth&quot;, xlab = &quot;Vitamin C dose mg&quot;, ylab = &quot;tooth length&quot;, ylim = c(0, 35) ) ) with( subset(ToothGrowth, supp == &quot;OJ&quot;), boxplot(len ~ dose, add = TRUE, boxwex = 0.25, at = 1:3 + 0.2, col = &quot;#EA4335&quot; ) ) legend(2, 9, c(&quot;Ascorbic acid&quot;, &quot;Orange juice&quot;), fill = c(&quot;#4285f4&quot;, &quot;#EA4335&quot;) ) 3.14 运行环境 xfun::session_info() #&gt; R version 3.6.1 (2019-07-05) #&gt; Platform: x86_64-pc-linux-gnu (64-bit) #&gt; Running under: Debian GNU/Linux 10 (buster) #&gt; #&gt; Locale: #&gt; LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C #&gt; LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 #&gt; LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 #&gt; LC_PAPER=en_US.UTF-8 LC_NAME=C #&gt; LC_ADDRESS=C LC_TELEPHONE=C #&gt; LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C #&gt; #&gt; Package version: #&gt; base64enc_0.1.3 bookdown_0.12 codetools_0.2-16 compiler_3.6.1 #&gt; curl_4.0 digest_0.6.20 evaluate_0.14 glue_1.3.1 #&gt; graphics_3.6.1 grDevices_3.6.1 highr_0.8 htmltools_0.3.6 #&gt; jsonlite_1.6 knitr_1.23 magrittr_1.5 markdown_1.0 #&gt; methods_3.6.1 mime_0.7 Rcpp_1.0.2 rmarkdown_1.14 #&gt; stats_3.6.1 stringi_1.4.3 stringr_1.4.0 tinytex_0.14 #&gt; tools_3.6.1 utils_3.6.1 xfun_0.8 yaml_2.2.0 参考文献 "],
["dm-dplyr.html", "第 4 章 净土化操作 4.1 常用操作 4.2 高频问题 4.3 管道操作 4.4 运行环境", " 第 4 章 净土化操作 常用操作和高频问题需要合并进之前的 data-manipulation，本章只介绍向量化计算 以 dplyr 为核心的 tidyverse 风数据操作 管道风操作 在不同规模的数据集上，Base R，dplyr 和 data.table 的处理性能应该属于低、中、高档搭配的情形 更加高级的数据变形操作，特别是数据类型的一致性，方便后续的可视化和建模，引入 tidyverse，数据处理或者叫特征工程 Base R vs data.table vs dplyr 它们各有优点，所以都加以介绍 参考 Jozef Hajnala 博文。 关于 tidyverse 提供的数据操作不要移动到 Base R 对应的章节，这二者已经越行越远，本章主要讲并行或分布式数据操作工具，如 SparkR sparklyr 针对大数据集上的操 Base R 的数据操作的一致性问题参见统计之都帖子 https://d.cosx.org/d/420763 Malcolm Barrett 以幻灯片的形式呈现 dplyr 和 purrr 的基础用法 Charlotte Wickham 的课程 A introduction to purrr purrr-tutorial 关于引用 quotation 相比于 SQL， dplyr 在数据库操作的不足，这是一些比较难的部分 https://dbi.r-dbi.org/articles/dbi-1#sec:open-issues 函数式编程 Functional Programming Languages 用于数据处理 rpivotTable 动态数据透视表 fuzzyjoin Join tables together on inexact matching dtplyr dtplyr is the data.table backend for dplyr. It provides S3 methods for data.table objects so that dplyr works the way you expect. bplyr basic dplyr and tidyr functionality without the tidyverse dependencies SqlRender 基于 Java 语言，借助 rJava 包支持参数化的 SQL 语句，并且可以将一种 SQL 语句（如 Microsoft SQL Server）转化为多种SQL语句（如Oracle, PostgreSQL, Amazon RedShift, Impala, IBM Netezza, Google BigQuery, Microsoft PDW, and SQLite） fastmap 实现键值存储，提供新的数据结构 Roaring bitmaps Bitsets, also called bitmaps, are commonly used as fast data structures. library(tidyverse) 数据操作的语法 第一代 Base R 数据操作已在第 3 章详细介绍 第二代 reshape （退休）使用函数 melt 和 cast 重构(restructure)和聚合(aggregate)数据 reshape2 （退休）是 reshape 的继任者，功能和 reshape 类似，提供两个函数 melt 和 cast 聚合数据，因此不再介绍 reshape，而鉴于 reshape2 还在活跃使用中，故而以它为例介绍 melt 和 cast 函数 plyr （退休）统一拆分(split)，计算(apply)，合并(combine)的数据处理流，由 dplyr（用于data.frame） 和 purrr （用于 list）继任 第三代 dplyr 操作数据的语法及其扩展 sparklyr 给 dplyr 提供 Spark 接口支持 dbplyr 给 dplyr 提供 DBI 数据库接口支持 dtplyr 给 dplyr 提供 data.table 支持 tidyr 提供 spread 和 gather 两个函数清洗数据 Garrett Grolemund 在 RStudio 主要从事教育教学，参考 Materials for the Tidyverse Train-the-trainer workshop 和 The Tidyverse Cookbook Dirk Eddelbuettel 的 Getting Started in R – Tinyverse Edition 4.1 常用操作 dplyr 由 Hadley Wickham 主要由开发和维护，是Rstudio公司开源的用于数据处理的一大利器，该包号称“数据操作的语法”，与 ggplot2 对应，也就是说数据处理那一套已经建立完整的和SQL一样的功能。它们都遵循同样的处理逻辑，只不过一个用SQL写，一个用R语言写，处理效率差不多，R语言写的 SQL 会被翻译为 SQL 语句，再传至数据库查询，当然它也支持内存内的数据操作。目前 dplyr 以 dbplyr 为后端支持的数据库有：MySQL、PostgreSQL，SQLite等，完整的支持列表请看 这里，连接特定数据库，都是基于 DBI，DBI 即 Database Interface， 是使用C/C++开发的底层数据库接口，是一个统一的关系型数据库连接框架，需要根据不同的具体的数据库进行实例化，才可使用。 dplyr 常用的函数是6个： arrange 排序 filter 过滤 select 选择 mutate 变换 summarise 汇总 group_by 分组 以 GGplot2 自带的钻石数据集diamonds为例介绍 4.1.1 查看 除了直接打印数据集的前几行，tibble 包还提供 glimpse 函数查看数据集，而 Base R 默认查看方式是调用 str 函数 diamonds #&gt; # A tibble: 53,940 x 10 #&gt; carat cut color clarity depth table price x y z #&gt; &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 #&gt; 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31 #&gt; 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31 #&gt; 4 0.290 Premium I VS2 62.4 58 334 4.2 4.23 2.63 #&gt; 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75 #&gt; 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 #&gt; # … with 5.393e+04 more rows glimpse(diamonds) #&gt; Observations: 53,940 #&gt; Variables: 10 #&gt; $ carat &lt;dbl&gt; 0.23, 0.21, 0.23, 0.29, 0.31, 0.24, 0.24, 0.26, 0.22, 0.… #&gt; $ cut &lt;ord&gt; Ideal, Premium, Good, Premium, Good, Very Good, Very Goo… #&gt; $ color &lt;ord&gt; E, E, E, I, J, J, I, H, E, H, J, J, F, J, E, E, I, J, J,… #&gt; $ clarity &lt;ord&gt; SI2, SI1, VS1, VS2, SI2, VVS2, VVS1, SI1, VS2, VS1, SI1,… #&gt; $ depth &lt;dbl&gt; 61.5, 59.8, 56.9, 62.4, 63.3, 62.8, 62.3, 61.9, 65.1, 59… #&gt; $ table &lt;dbl&gt; 55, 61, 65, 58, 58, 57, 57, 55, 61, 61, 55, 56, 61, 54, … #&gt; $ price &lt;int&gt; 326, 326, 327, 334, 335, 336, 336, 337, 337, 338, 339, 3… #&gt; $ x &lt;dbl&gt; 3.95, 3.89, 4.05, 4.20, 4.34, 3.94, 3.95, 4.07, 3.87, 4.… #&gt; $ y &lt;dbl&gt; 3.98, 3.84, 4.07, 4.23, 4.35, 3.96, 3.98, 4.11, 3.78, 4.… #&gt; $ z &lt;dbl&gt; 2.43, 2.31, 2.31, 2.63, 2.75, 2.48, 2.47, 2.53, 2.49, 2.… 表 4.1: dplyr 定义的数据对象类型 类型 含义 int 整型 integer dbl （单）双精度浮点类型 chr 字符（串）类型 dttm data-time 类型 lgl 布尔类型 fctr 因子类型 factor date 日期类型 表 4.1 中 dttm 和 date 类型代指 lubridate 包指定的日期对象 POSIXct、 POSIXlt、 Date、 chron、 yearmon、 yearqtr、 zoo、 zooreg、 timeDate、 xts、 its、 ti、 jul、 timeSeries 和 fts。 4.1.2 筛选 4.1.3 排序 4.1.4 聚合 4.1.5 合并 4.1.6 重塑 4.1.7 变换 4.1.8 去重 数据去重在 dplyr 中的实现19。 set.seed(123) df &lt;- data.frame( x = sample(0:1, 10, replace = T), y = sample(0:1, 10, replace = T), z = 1:10 ) df #&gt; x y z #&gt; 1 0 1 1 #&gt; 2 0 1 2 #&gt; 3 0 1 3 #&gt; 4 1 0 4 #&gt; 5 0 1 5 #&gt; 6 1 0 6 #&gt; 7 1 1 7 #&gt; 8 1 0 8 #&gt; 9 0 0 9 #&gt; 10 0 0 10 df %&gt;% group_by(x, y) %&gt;% filter(row_number(z) == 1) #&gt; # A tibble: 4 x 3 #&gt; # Groups: x, y [4] #&gt; x y z #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 0 1 1 #&gt; 2 1 0 4 #&gt; 3 1 1 7 #&gt; 4 0 0 9 4.2 高频问题 常用的数据操作包含 创建空的数据框或者说初始化一个数据框， 按指定的列对数据框排序， 选择特定的一些列，复杂情况是可能需要正则表达式从列名或者值中筛选 合并两个数据框，分为 (inner outer left right) 四种情况 4.2.1 初始化数据框 创建空的数据框，就是不包含任何行、记录[^create-an-empty-data-frame] empty_df &lt;- data.frame( Doubles = double(), Ints = integer(), Factors = factor(), Logicals = logical(), Characters = character(), stringsAsFactors = FALSE ) str(empty_df) #&gt; &#39;data.frame&#39;: 0 obs. of 5 variables: #&gt; $ Doubles : num #&gt; $ Ints : int #&gt; $ Factors : Factor w/ 0 levels: #&gt; $ Logicals : logi #&gt; $ Characters: chr 如果数据框 df 包含数据，现在要依据它创建一个空的数据框 empty_df = df[FALSE,] 还可以使用 structure 构造一个数据框，并且我们发现它的效率更高 s &lt;- function() structure(list( Date = as.Date(character()), File = character(), User = character() ), class = &quot;data.frame&quot; ) d &lt;- function() data.frame( Date = as.Date(character()), File = character(), User = character(), stringsAsFactors = FALSE ) # microbenchmark::microbenchmark(s(), d()) 4.2.2 移除缺失记录 只要行中包含缺失值，我们就把这样的行移除出去 airquality[complete.cases(airquality), ] #&gt; Ozone Solar.R Wind Temp Month Day #&gt; 1 41 190 7.4 67 5 1 #&gt; 2 36 118 8.0 72 5 2 #&gt; 3 12 149 12.6 74 5 3 #&gt; 4 18 313 11.5 62 5 4 #&gt; 7 23 299 8.6 65 5 7 #&gt; 8 19 99 13.8 59 5 8 #&gt; 9 8 19 20.1 61 5 9 #&gt; 12 16 256 9.7 69 5 12 #&gt; 13 11 290 9.2 66 5 13 .... 4.2.3 数据类型转化 str(PlantGrowth) #&gt; &#39;data.frame&#39;: 30 obs. of 2 variables: #&gt; $ weight: num 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ... #&gt; $ group : Factor w/ 3 levels &quot;ctrl&quot;,&quot;trt1&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... bob &lt;- PlantGrowth i &lt;- sapply(bob, is.factor) bob[i] &lt;- lapply(bob[i], as.character) str(bob) #&gt; &#39;data.frame&#39;: 30 obs. of 2 variables: #&gt; $ weight: num 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ... #&gt; $ group : chr &quot;ctrl&quot; &quot;ctrl&quot; &quot;ctrl&quot; &quot;ctrl&quot; ... 4.2.4 跨列分组求和 输入是一个数据框 data.frame，按照其中某一变量分组，然后计算任意数量的变量的行和和列和。 空气质量数据集 airquality 按月份 Month 分组，然后求取满足条件的列的和 Reduce(rbind, lapply(unique(airquality$Month), function(gv) { subdta &lt;- subset(airquality, subset = Month == gv) data.frame( Colsum = as.numeric( colSums(subdta[, grepl(&quot;[mM]&quot;, names(airquality))], na.rm = TRUE) ), Month = gv ) })) #&gt; Colsum Month #&gt; 1 2032 5 #&gt; 2 155 5 #&gt; 3 2373 6 #&gt; 4 180 6 #&gt; 5 2601 7 #&gt; 6 217 7 #&gt; 7 2603 8 #&gt; 8 248 8 #&gt; 9 2307 9 #&gt; 10 270 9 什么是函数式编程，R 语言环境下的函数式编程是如何操作的 4.3 管道操作 Stefan Milton Bache 开发了 magrittr 包实现管道操作，增加代码的可读性和维护性，但是这个 R 包的名字取的太奇葩，因为 记不住，它其实是一个复杂的法语发音，中式英语就叫它马格里特吧！这下应该好记多了吧！ 我要查看是否需要新添加一个 R 包依赖，假设该 R 包是 reticulate 没有出现在 DESCRIPTION 文件中，但是可能已经被其中某（个）些 R 包依赖了 &quot;reticulate&quot; %in% sort(unique(unlist(tools::package_dependencies(desc::desc_get_deps()$package, recursive = TRUE)))) #&gt; [1] FALSE 安装 pkg 的依赖 pkg &lt;- c( &quot;bookdown&quot;, &quot;e1071&quot;, &quot;formatR&quot;, &quot;lme4&quot;, &quot;mvtnorm&quot;, &quot;prettydoc&quot;, &quot;psych&quot;, &quot;reticulate&quot;, &quot;rstan&quot;, &quot;rstanarm&quot;, &quot;rticles&quot;, &quot;svglite&quot;, &quot;TMB&quot;, &quot;glmmTMB&quot; ) # 获取 pkg 的所有依赖 dep_pkg &lt;- tools::package_dependencies(pkg, recursive = TRUE) # 将列表 list 合并为向量 vector merge_pkg &lt;- Reduce(&quot;c&quot;, dep_pkg, accumulate = FALSE) # 所有未安装的 R 包 miss_pkg &lt;- setdiff(unique(merge_pkg), unique(.packages(TRUE))) # 除了 pkg 外，未安装的 R 包，安装 pkg 的依赖 sort(setdiff(miss_pkg, pkg)) #&gt; [1] &quot;foreign&quot; &quot;mnormt&quot; 转化为管道操作，增加可读性，[^pipe-r] 再举一个关于数据模拟的例子 模拟 0-1 序列， set.seed(2019) binom_sample &lt;- function(n) { sum(sample(x = c(0,1), size = n, prob = c(0.8, 0.2), replace = TRUE))/n } # 频率估计概率 one_prob &lt;- sapply(10^(seq(8)), binom_sample) # 估计的误差 one_abs &lt;- abs(one_prob - 0.2) one_abs #&gt; [1] 1.000e-01 1.000e-02 1.100e-02 4.400e-03 1.460e-03 3.980e-04 4.700e-06 #&gt; [8] 9.552e-05 似然估计 4.4 运行环境 xfun::session_info(&#39;tidyverse&#39;) #&gt; R version 3.6.1 (2019-07-05) #&gt; Platform: x86_64-pc-linux-gnu (64-bit) #&gt; Running under: Debian GNU/Linux 10 (buster) #&gt; #&gt; Locale: #&gt; LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C #&gt; LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 #&gt; LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 #&gt; LC_PAPER=en_US.UTF-8 LC_NAME=C #&gt; LC_ADDRESS=C LC_TELEPHONE=C #&gt; LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C #&gt; #&gt; Package version: #&gt; askpass_1.1 assertthat_0.2.1 backports_1.1.4 #&gt; base64enc_0.1.3 BH_1.69.0.1 broom_0.5.2 #&gt; callr_3.3.1 cellranger_1.1.0 cli_1.1.0 #&gt; clipr_0.7.0 colorspace_1.4.1 crayon_1.3.4 #&gt; curl_4.0 DBI_1.0.0 dbplyr_1.4.2 #&gt; digest_0.6.20 dplyr_0.8.3 ellipsis_0.2.0.1 #&gt; evaluate_0.14 fansi_0.4.0 forcats_0.4.0 #&gt; fs_1.3.1 generics_0.0.2 ggplot2_3.2.0 #&gt; glue_1.3.1 graphics_3.6.1 grDevices_3.6.1 #&gt; grid_3.6.1 gtable_0.3.0 haven_2.1.1 #&gt; highr_0.8 hms_0.5.0 htmltools_0.3.6 #&gt; httr_1.4.0 jsonlite_1.6 knitr_1.23 #&gt; labeling_0.3 lattice_0.20.38 lazyeval_0.2.2 #&gt; lubridate_1.7.4 magrittr_1.5 markdown_1.0 #&gt; MASS_7.3.51.4 Matrix_1.2.17 methods_3.6.1 #&gt; mgcv_1.8.28 mime_0.7 modelr_0.1.4 #&gt; munsell_0.5.0 nlme_3.1.140 openssl_1.4.1 #&gt; pillar_1.4.2 pkgconfig_2.0.2 plogr_0.2.0 #&gt; plyr_1.8.4 prettyunits_1.0.2 processx_3.4.1 #&gt; progress_1.2.2 ps_1.3.0 purrr_0.3.2 #&gt; R6_2.4.0 RColorBrewer_1.1.2 Rcpp_1.0.2 #&gt; readr_1.3.1 readxl_1.3.1 rematch_1.0.1 #&gt; reprex_0.3.0 reshape2_1.4.3 rlang_0.4.0 #&gt; rmarkdown_1.14 rstudioapi_0.10 rvest_0.3.4 #&gt; scales_1.0.0 selectr_0.4.1 splines_3.6.1 #&gt; stats_3.6.1 stringi_1.4.3 stringr_1.4.0 #&gt; sys_3.2 tibble_2.1.3 tidyr_0.8.3 #&gt; tidyselect_0.2.5 tidyverse_1.2.1 tinytex_0.14 #&gt; tools_3.6.1 utf8_1.1.4 utils_3.6.1 #&gt; vctrs_0.2.0 viridisLite_0.3.0 whisker_0.3.2 #&gt; withr_2.1.2 xfun_0.8 xml2_1.2.0 #&gt; yaml_2.2.0 zeallot_0.1.0 "],
["dc-string-manipulation.html", "第 5 章 字符串操作 5.1 字符数统计 5.2 字符串翻译 5.3 字符串连接 5.4 字符串拆分 5.5 字符串匹配 5.6 字符串查询 5.7 字符串替换 5.8 字符串提取 5.9 其它操作 5.10 运行环境", " 第 5 章 字符串操作 字符和字符串类型的数据值得单独拿出来讲，不仅因为内容多，而且比较难，应用范围最广，特别是面对文本类型的数据时，几乎是避不开的！R 的前身是 S，S 的前身是一些 Fortran 和 C 子程序，最早在贝尔实验室是用于文本分析领域，因此在 R 基础包中提供了丰富的字符串处理函数，你可以在R控制台中执行如下一行命令查看 help.search(keyword = &quot;character&quot;, package = &quot;base&quot;) 本章主要介绍 R 内置的字符串操作函数 5.1 字符数统计 nchar 函数统计字符串向量中每个元素的字符个数，注意与函数length 的差别，它统计向量中元素的个数，即向量的长度。 nchar(c(&quot;Hello&quot;, &quot;world&quot;, &quot;!&quot;)) #&gt; [1] 5 5 1 R.version.string #&gt; [1] &quot;R version 3.6.1 (2019-07-05)&quot; nchar(R.version.string) #&gt; [1] 28 deparse(base::mean) #&gt; [1] &quot;function (x, ...) &quot; &quot;UseMethod(\\&quot;mean\\&quot;)&quot; nchar(deparse(base::mean)) #&gt; [1] 18 17 一些特殊的情况 nchar(&quot;&quot;) #&gt; [1] 0 nchar(NULL) #&gt; integer(0) nchar(0) #&gt; [1] 1 pi #&gt; [1] 3.141593 nchar(pi) #&gt; [1] 16 exp(1) #&gt; [1] 2.718282 nchar(exp(1)) #&gt; [1] 16 nchar(NA) #&gt; [1] NA 5.2 字符串翻译 tolower 将字符串或字符串向量中含有的大写字母全都转化为小写， toupper 函数正好与之相反. tolower(c(&quot;HELLO&quot;, &quot;Hello, R&quot;, &quot;hello&quot;)) #&gt; [1] &quot;hello&quot; &quot;hello, r&quot; &quot;hello&quot; toupper(c(&quot;HELLO&quot;, &quot;Hello, R&quot;, &quot;hello&quot;)) #&gt; [1] &quot;HELLO&quot; &quot;HELLO, R&quot; &quot;HELLO&quot; 5.3 字符串连接 paste 函数设置参数 sep 作为连接符，设置参数 collapse 可以将字符串拼接后连成一个字符串 paste(&quot;A&quot;, &quot;B&quot;, sep = &quot;&quot;) #&gt; [1] &quot;AB&quot; paste(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), 1:3, sep = &quot;-&quot;) #&gt; [1] &quot;A-1&quot; &quot;B-2&quot; &quot;C-3&quot; paste(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), 1:3, sep = &quot;-&quot;, collapse = &quot;;&quot;) #&gt; [1] &quot;A-1;B-2;C-3&quot; paste0 相当于 sep 设为空，没有连接符 paste0(&quot;A&quot;, &quot;B&quot;) #&gt; [1] &quot;AB&quot; paste0(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), 1:3) #&gt; [1] &quot;A1&quot; &quot;B2&quot; &quot;C3&quot; paste0(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), 1:3, collapse = &quot;;&quot;) #&gt; [1] &quot;A1;B2;C3&quot; 5.4 字符串拆分 strsplit(x, split, fixed = FALSE, perl = FALSE, useBytes = FALSE) strsplit 函数用于字符串拆分，参数 x 是被拆分的字符串向量，其每个元素都会被拆分，而参数 split 表示拆分的位置，可以用正则表达式来描述位置，拆分的结果是一个列表。 参数 fixed 默认设置 fixed = FALSE 表示正则表达式匹配，而 fixed = TRUE 表示正则表达式的精确匹配或者按文本字符的字面意思匹配，即按普通文本匹配。我们知道按普通文本匹配速度快。 当启用 perl = TRUE 时，由 PCRE_use_JIT 控制细节。perl 参数的设置与 Perl 软件版本有关，如果正则表达式很长，除了正确设置正则表达式，使用 perl = TRUE 可以提高运算速度 参数 useBytes 设置是否按照逐个字节地进行匹配，默认设置为 FALSE，即按照字符而不是字节进行匹配 x &lt;- c(as = &quot;asfef&quot;, qu = &quot;qwerty&quot;, &quot;yuiop[&quot;, &quot;b&quot;, &quot;stuff.blah.yech&quot;) # 按字母 e 拆分字符串向量 x strsplit(x, &quot;e&quot;) #&gt; $as #&gt; [1] &quot;asf&quot; &quot;f&quot; #&gt; #&gt; $qu #&gt; [1] &quot;qw&quot; &quot;rty&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;yuiop[&quot; #&gt; #&gt; [[4]] #&gt; [1] &quot;b&quot; #&gt; #&gt; [[5]] #&gt; [1] &quot;stuff.blah.y&quot; &quot;ch&quot; 参数 split 支持通过正则表达式的方式指明拆分位置 # 默认将点号 . 看作一个正则表达式，它是一个元字符，匹配任意字符 strsplit(&quot;a.b.c&quot;, &quot;.&quot;) #&gt; [[1]] #&gt; [1] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; # 这才是按点号拆分 strsplit(&quot;a.b.c&quot;, &quot;.&quot;, fixed = TRUE) #&gt; [[1]] #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; # 或者 strsplit(&quot;a.b.c&quot;, &quot;[.]&quot;) #&gt; [[1]] #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; # 或者转义点号，去掉元字符的特殊意义 strsplit(&quot;a.b.c&quot;, &quot;\\\\.&quot;) #&gt; [[1]] #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; 这里介绍一个将字符串逆序的函数 str_rev str_rev &lt;- function(x) sapply(lapply(strsplit(x, NULL), rev), paste, collapse = &quot;&quot;) str_rev(c(&quot;abc&quot;, &quot;Statistics&quot;)) #&gt; [1] &quot;cba&quot; &quot;scitsitatS&quot; 为了加深理解，再举几个例子 # 最后一个空字符没有产生 strsplit(paste(c(&quot;&quot;, &quot;a&quot;, &quot;&quot;), collapse=&quot;#&quot;), split=&quot;#&quot;) #&gt; [[1]] #&gt; [1] &quot;&quot; &quot;a&quot; # 空字符只有有定义的时候才会产生 strsplit(&quot;&quot;, &quot; &quot;) #&gt; [[1]] #&gt; character(0) strsplit(&quot; &quot;, &quot; &quot;) #&gt; [[1]] #&gt; [1] &quot;&quot; 5.5 字符串匹配 agrep 和 agrepl 函数做近似（模糊）匹配 (Approximate Matching or Fuzzy Matching) ，对于匹配，考虑到参数 pattern 在参数 x 中匹配时，允许参数值x存在最小可能的插入、删除和替换，这种修改叫做Levenshtein 编辑距离，max.distance 控制其细节 agrep(pattern, x, max.distance = 0.1, costs = NULL, ignore.case = FALSE, value = FALSE, fixed = TRUE, useBytes = FALSE) agrepl(pattern, x, max.distance = 0.1, costs = NULL, ignore.case = FALSE, fixed = TRUE, useBytes = FALSE) agrep 函数返回 pattern 在 x 中匹配到的一个位置向量，agrepl 返回一个逻辑向量，这一点类似 grep 和 grepl 这对函数，下面举例子说明 agrep(&quot;lasy&quot;, &quot;1 lazy 2&quot;) #&gt; [1] 1 # sub = 0 表示匹配时不考虑替换 agrep(&quot;lasy&quot;, c(&quot; 1 lazy 2&quot;, &quot;1 lasy 2&quot;), max = list(sub = 0)) #&gt; [1] 2 # 默认设置下，匹配时区分大小写 agrep(&quot;laysy&quot;, c(&quot;1 lazy&quot;, &quot;1&quot;, &quot;1 LAZY&quot;), max = 2) #&gt; [1] 1 # 返回匹配到值，而不是位置下标，类似 grep(..., value = TRUE) 的返回值 agrep(&quot;laysy&quot;, c(&quot;1 lazy&quot;, &quot;1&quot;, &quot;1 LAZY&quot;), max = 2, value = TRUE) #&gt; [1] &quot;1 lazy&quot; # 不区分大小写 agrep(&quot;laysy&quot;, c(&quot;1 lazy&quot;, &quot;1&quot;, &quot;1 LAZY&quot;), max = 2, ignore.case = TRUE) #&gt; [1] 1 3 startsWith(x, prefix) endsWith(x, suffix) startsWith 和 endsWith 函数用来匹配字符串的前缀和后缀，返回值是一个逻辑向量，参数 prefix 和 suffix 不要包含特殊的正则表达式字符，如点号.，举例子 # 字符串向量 search() #&gt; [1] &quot;.GlobalEnv&quot; &quot;package:stats&quot; &quot;package:graphics&quot; #&gt; [4] &quot;package:grDevices&quot; &quot;package:utils&quot; &quot;package:datasets&quot; #&gt; [7] &quot;package:methods&quot; &quot;Autoloads&quot; &quot;package:base&quot; # 匹配以 package: 开头的字符串 startsWith(search(), &quot;package:&quot;) #&gt; [1] FALSE TRUE TRUE TRUE TRUE TRUE TRUE FALSE TRUE # 或者 grepl(&quot;^package:&quot;, search()) #&gt; [1] FALSE TRUE TRUE TRUE TRUE TRUE TRUE FALSE TRUE 当前目录下，列出扩展名为 .Rmd 的文件 # list.files(path = &quot;.&quot;, pattern = &quot;\\\\.Rmd$&quot;) # 而不是 endsWith(list.files(), &quot;\\\\.Rmd&quot;) endsWith(list.files(), &quot;.Rmd&quot;) #&gt; [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE #&gt; [12] FALSE FALSE FALSE FALSE TRUE FALSE TRUE FALSE FALSE FALSE FALSE #&gt; [23] TRUE FALSE FALSE FALSE TRUE FALSE FALSE FALSE TRUE FALSE FALSE #&gt; [34] FALSE TRUE FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE FALSE #&gt; [45] TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE #&gt; [56] FALSE FALSE FALSE FALSE FALSE # 或者 grepl(&quot;\\\\.Rmd$&quot;, list.files()) #&gt; [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE #&gt; [12] FALSE FALSE FALSE FALSE TRUE FALSE TRUE FALSE FALSE FALSE FALSE #&gt; [23] TRUE FALSE FALSE FALSE TRUE FALSE FALSE FALSE TRUE FALSE FALSE #&gt; [34] FALSE TRUE FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE FALSE #&gt; [45] TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE #&gt; [56] FALSE FALSE FALSE FALSE FALSE 部分匹配(Partial String Matching) match(x, table, nomatch = NA_integer_, incomparables = NULL) x %in% table charmatch(x, table, nomatch = NA_integer_) pmatch(x, table, nomatch = NA_integer_, duplicates.ok = FALSE) 这几个 match 函数的返回值都是一个向量，每个元素是参数x在参数table中第一次匹配到的位置，charmatch 与 pmatch(x, table, nomatch = NA_integer_, duplicates.ok = TRUE) 类似，所以 pmatch 在默认 duplicates.ok = FALSE 的情况下，若x在第二个参数table中有多次匹配就会返回 NA，因此，实际上 pmatch 只允许在第二个参数中匹配一次 match(&quot;xx&quot;, c(&quot;abc&quot;, &quot;xx&quot;, &quot;xxx&quot;, &quot;xx&quot;)) #&gt; [1] 2 1:10 %in% c(1,3,5,9) #&gt; [1] TRUE FALSE TRUE FALSE TRUE FALSE FALSE FALSE TRUE FALSE # charmatch 就比较奇怪，规则太多 charmatch(&quot;&quot;, &quot;&quot;) # returns 1 #&gt; [1] 1 # 多个精确匹配到，或者多个部分匹配到，则返回 0 charmatch(&quot;m&quot;, c(&quot;mean&quot;, &quot;median&quot;, &quot;mode&quot;, &quot;quantile&quot;)) # returns 0 #&gt; [1] 0 # med 只在table参数值的第二个位置部分匹配到，所以返回2 charmatch(&quot;med&quot;, c(&quot;mean&quot;, &quot;median&quot;, &quot;mode&quot;, &quot;quantile&quot;)) # returns 2 #&gt; [1] 2 charmatch(&quot;xx&quot;, &quot;xx&quot;) #&gt; [1] 1 charmatch(&quot;xx&quot;, &quot;xxa&quot;) #&gt; [1] 1 charmatch(&quot;xx&quot;, &quot;axx&quot;) #&gt; [1] NA # 注意比较与 charmatch 的不同 pmatch(&quot;&quot;, &quot;&quot;) # returns NA #&gt; [1] NA pmatch(&quot;m&quot;, c(&quot;mean&quot;, &quot;median&quot;, &quot;mode&quot;)) # returns NA #&gt; [1] NA pmatch(&quot;med&quot;, c(&quot;mean&quot;, &quot;median&quot;, &quot;mode&quot;)) # returns 2 #&gt; [1] 2 5.6 字符串查询 grep(pattern, x, ignore.case = FALSE, perl = FALSE, value = FALSE, fixed = FALSE, useBytes = FALSE, invert = FALSE ) grepl(pattern, x, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE ) grep 和 grepl 是一对字符串查询函数，查看字符串向量 x 中是否包含正则表达式 pattern 描述的内容 ignore.case: TRUE 表示忽略大小写，FALSE 表示匹配的时候区分大小写 fixed = TRUE 表示启用 literal regular expression 字面正则表达式，默认情况下fixed = FALSE grep 函数返回匹配到的字符串向量x的元素的下标，如果 value=TRUE 则返回下标对应的值 grepl 函数返回一个逻辑向量，检查字符串向量x中的每个元素是否匹配到，匹配到返回 TRUE，没有匹配到返回 FALSE # 返回下标位置 grep(&quot;[a-z]&quot;, letters) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #&gt; [24] 24 25 26 # 返回查询到的值 grep(&quot;[a-z]&quot;, letters, value = TRUE) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; #&gt; [18] &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; 继续举例子 grep(x = c(&quot;apple&quot;, &quot;banana&quot;), pattern = &quot;a&quot;) #&gt; [1] 1 2 grep(x = c(&quot;apple&quot;, &quot;banana&quot;), pattern = &quot;b&quot;) #&gt; [1] 2 grep(x = c(&quot;apple&quot;, &quot;banana&quot;), pattern = &quot;a&quot;, value = TRUE) #&gt; [1] &quot;apple&quot; &quot;banana&quot; grep(x = c(&quot;apple&quot;, &quot;banana&quot;), pattern = &quot;b&quot;, value = TRUE) #&gt; [1] &quot;banana&quot; 关于 grepl 函数的使用例子 grepl(x = c(&quot;apple&quot;, &quot;banana&quot;), pattern = &quot;a&quot;) #&gt; [1] TRUE TRUE grepl(x = c(&quot;apple&quot;, &quot;banana&quot;), pattern = &quot;b&quot;) #&gt; [1] FALSE TRUE R 语言是用字符串来表示正则表达式的，但是正则表达式不是字符串，字符串的构造类似算术表达式 在 R 里面分别表示 a\\\\b 和 a\\b writeLines(c(&quot;a\\\\\\\\b&quot;, &quot;a\\\\b&quot;)) #&gt; a\\\\b #&gt; a\\b 下面在 R 里面分别匹配字符串 a\\\\b 和 a\\b 中的 \\\\ 和 \\ # 匹配字符串中的一个反斜杠 grep(x = c(&quot;a\\\\\\\\b&quot;, &quot;a\\\\b&quot;), pattern = &quot;\\\\&quot;, value = TRUE, fixed = TRUE) #&gt; [1] &quot;a\\\\\\\\b&quot; &quot;a\\\\b&quot; grep(x = c(&quot;a\\\\\\\\b&quot;, &quot;a\\\\b&quot;), pattern = &quot;\\\\\\\\&quot;, value = TRUE, fixed = FALSE) #&gt; [1] &quot;a\\\\\\\\b&quot; &quot;a\\\\b&quot; # 匹配字符串中的两个反斜杠 grep(x = c(&quot;a\\\\\\\\b&quot;, &quot;a\\\\b&quot;), pattern = &quot;\\\\\\\\&quot;, value = TRUE, fixed = TRUE) #&gt; [1] &quot;a\\\\\\\\b&quot; grep(x = c(&quot;a\\\\\\\\b&quot;, &quot;a\\\\b&quot;), pattern = &quot;\\\\\\\\\\\\\\\\&quot;, value = TRUE, fixed = FALSE) #&gt; [1] &quot;a\\\\\\\\b&quot; # 匹配字符串中的两个反斜杠 \\\\ grepl(x = &quot;a\\\\\\\\b&quot;, pattern = &quot;\\\\\\\\\\\\\\\\&quot;, fixed = FALSE) #&gt; [1] TRUE grepl(x = &quot;a\\\\\\\\b&quot;, pattern = &quot;\\\\\\\\\\\\\\\\&quot;, fixed = TRUE) #&gt; [1] FALSE grepl(x = &quot;a\\\\\\\\b&quot;, pattern = &quot;\\\\\\\\&quot;, fixed = TRUE) #&gt; [1] TRUE regexpr(pattern, text, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE ) gregexpr(pattern, text, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE ) regexec(pattern, text, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE ) 当启用 perl=TRUE 时， 函数 regexpr 和 gregexpr 支持 Python 环境下的命名捕获(named captures)，但是不支持长向量的输入。如果一个分组被命名了，如 (?&lt;first&gt;[A-Z][a-z]+) 那么匹配到的位置按命名返回。函数 sub 不支持命名反向引用 (Named backreferences) 函数 regmatches 用来提取函数regexpr, gregexpr 和 regexec 匹配到的子字符串 useBytes = FALSE 匹配位置和长度默认是按照字符级别来的，如果 useBytes = TRUE 则是按照逐个字节的匹配结果 如果使用到了 命名捕获 则会返回更多的属性 “capture.start”，“capture.length” 和 “capture.names”，分别表示捕获的起始位置、捕获的长度和捕获的命名。 regexpr 函数返回一个整型向量，第一次匹配的初始位置，-1 表示没有匹配到，返回的属性 match.length 表示匹配的字符数量，是一个整型向量，向量长度是匹配的文本的长度，-1 表示没有匹配到 text &lt;- c(&quot;Hellow, Adam!&quot;, &quot;Hi, Adam!&quot;, &quot;How are you, Adam.&quot;) regexpr(&quot;Adam&quot;, text) #&gt; [1] 9 5 14 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 4 4 4 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE txt &lt;- c( &quot;The&quot;, &quot;licenses&quot;, &quot;for&quot;, &quot;most&quot;, &quot;software&quot;, &quot;are&quot;, &quot;designed&quot;, &quot;to&quot;, &quot;take&quot;, &quot;away&quot;, &quot;your&quot;, &quot;freedom&quot;, &quot;to&quot;, &quot;share&quot;, &quot;and&quot;, &quot;change&quot;, &quot;it.&quot;, &quot;&quot;, &quot;By&quot;, &quot;contrast,&quot;, &quot;the&quot;, &quot;GNU&quot;, &quot;General&quot;, &quot;Public&quot;, &quot;License&quot;, &quot;is&quot;, &quot;intended&quot;, &quot;to&quot;, &quot;guarantee&quot;, &quot;your&quot;, &quot;freedom&quot;, &quot;to&quot;, &quot;share&quot;, &quot;and&quot;, &quot;change&quot;, &quot;free&quot;, &quot;software&quot;, &quot;--&quot;, &quot;to&quot;, &quot;make&quot;, &quot;sure&quot;, &quot;the&quot;, &quot;software&quot;, &quot;is&quot;, &quot;free&quot;, &quot;for&quot;, &quot;all&quot;, &quot;its&quot;, &quot;users&quot; ) # gregexpr(&quot;en&quot;, txt) regexpr(&quot;en&quot;, txt) #&gt; [1] -1 4 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 2 #&gt; [24] -1 4 -1 4 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 #&gt; [47] -1 -1 -1 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] -1 2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 2 #&gt; [24] -1 2 -1 2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 #&gt; [47] -1 -1 -1 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE gregexpr 函数返回一个列表，返回列表的长度与字符串向量的长度一样，列表中每个元素的形式与 regexpr 的返回值一样, except that the starting positions of every (disjoint) match are given. gregexpr(&quot;Adam&quot;, text) #&gt; [[1]] #&gt; [1] 9 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 4 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE #&gt; #&gt; [[2]] #&gt; [1] 5 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 4 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE #&gt; #&gt; [[3]] #&gt; [1] 14 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 4 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE regexec 函数返回一个列表，类似函数gregexpr的返回结果，长度与字符串向量的长度一样，如果没有匹配到就返回 -1，匹配到了就返回一个匹配的初值位置的整型序列，所有子字符串与括号分组的正则表达式的子表达式对应，属性 “match.length” 是一个表示匹配的长度的向量，如果是 -1 表示没有匹配到。位置、长度和属性的解释与 regexpr 一致 regexec(&quot;Adam&quot;, text) #&gt; [[1]] #&gt; [1] 9 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 4 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE #&gt; #&gt; [[2]] #&gt; [1] 5 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 4 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE #&gt; #&gt; [[3]] #&gt; [1] 14 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 4 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE 由于资源限制（特别是 PCRE）导致的匹配失败，会视为没有匹配，通常伴随一个警告 下面这个将链接分解的例子由 Luke Tierney 提供20 x &lt;- &quot;http://stat.umn.edu:80/xyz&quot; m &lt;- regexec(&quot;^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*)&quot;, x) m #&gt; [[1]] #&gt; [1] 1 1 1 8 20 21 23 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 26 7 4 12 3 2 4 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE 这里 x 是一个字符串，所以函数 regexec 返回的列表长度为1，正则表达式 ^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*) 括号分组匹配到了7次，第一次匹配整个字符串，所以起始位置是1，而匹配长度是26，即整个字符串的长度，读者可以调用函数 nchar(x) 算一下，如果你愿意手动数一下也可以哈！余下不一一介绍，可以根据返回结果和图5.1一起看，最后还可以调用regmatches函数抽取匹配到的结果 regmatches(x, m) #&gt; [[1]] #&gt; [1] &quot;http://stat.umn.edu:80/xyz&quot; &quot;http://&quot; #&gt; [3] &quot;http&quot; &quot;stat.umn.edu&quot; #&gt; [5] &quot;:80&quot; &quot;80&quot; #&gt; [7] &quot;/xyz&quot; 我们可以在 https://regex101.com/ 上测试表达式，如图5.1所示，表达式 ^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*) 包含7个组，每个组的匹配结果见图的右下角，这样我们不难理解，函数 regmatches 返回的第列表中，第3个位置是传输协议 protocol http ，第4个位置是主机 host stat.umn.edu， 第6个位置是端口 port 80 ，第7个位置是路径 path /xyz，所以函数 regmatches 的作用就是根据函数 regexec 匹配的结果抽取子字符串。 图 5.1: 正则表达式匹配结果 进一步，我们可以用 regmatches 函数抽取 URL 的部分内容，如前面提到的传输协议，主机等 URL_parts &lt;- function(x) { m &lt;- regexec(&quot;^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*)&quot;, x) parts &lt;- do.call( rbind, lapply(regmatches(x, m), `[`, c(3L, 4L, 6L, 7L)) # 3,4,6,7是索引位置 ) colnames(parts) &lt;- c(&quot;protocol&quot;, &quot;host&quot;, &quot;port&quot;, &quot;path&quot;) parts } URL_parts(x) #&gt; protocol host port path #&gt; [1,] &quot;http&quot; &quot;stat.umn.edu&quot; &quot;80&quot; &quot;/xyz&quot; 目前还没有 gregexec 函数，但是可以模拟一个，首先用 gregexpr 函数返回匹配的位置，regmatches 抽取相应的值，然后用 regexec 作用到每一个提取的值，做再一次匹配和值的抽取，实现了全部的匹配。另一个例子 ## There is no gregexec() yet, but one can emulate it by running ## regexec() on the regmatches obtained via gregexpr(). E.g.: pattern &lt;- &quot;([[:alpha:]]+)([[:digit:]]+)&quot; s &lt;- &quot;Test: A1 BC23 DEF456&quot; gregexpr(pattern, s) #&gt; [[1]] #&gt; [1] 7 10 15 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 2 4 6 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE regmatches(s, gregexpr(pattern, s)) #&gt; [[1]] #&gt; [1] &quot;A1&quot; &quot;BC23&quot; &quot;DEF456&quot; lapply( regmatches(s, gregexpr(pattern, s)), function(e) regmatches(e, regexec(pattern, e)) ) #&gt; [[1]] #&gt; [[1]][[1]] #&gt; [1] &quot;A1&quot; &quot;A&quot; &quot;1&quot; #&gt; #&gt; [[1]][[2]] #&gt; [1] &quot;BC23&quot; &quot;BC&quot; &quot;23&quot; #&gt; #&gt; [[1]][[3]] #&gt; [1] &quot;DEF456&quot; &quot;DEF&quot; &quot;456&quot; 5.7 字符串替换 chartr 支持正则表达式的替换，chartr 是对应字符的替换操作 x &lt;- &quot;MiXeD cAsE 123&quot; # 将字符 iXs 替换为 why chartr(&quot;iXs&quot;, &quot;why&quot;, x) #&gt; [1] &quot;MwheD cAyE 123&quot; # 将字符串 a-cX 中的字符挨个对应地替换为 D-Fw chartr(&quot;a-cX&quot;, &quot;D-Fw&quot;, x) #&gt; [1] &quot;MiweD FAsE 123&quot; 两个 *sub 函数的区别：sub 替换第一次匹配到的结果，gsub 替换所有匹配的结果 sub(&quot; .*&quot;, &quot;&quot;, extSoftVersion()[&quot;PCRE&quot;]) #&gt; PCRE #&gt; &quot;8.39&quot; 参数 replacement 的值是正则表达式，其包含反向引用的用法， \\\\1 即引用表达式 ([ab]) gsub(pattern = &quot;([ab])&quot;, replacement = &quot;\\\\1_\\\\1_&quot;, x = &quot;abc and ABC&quot;) #&gt; [1] &quot;a_a_b_b_c a_a_nd ABC&quot; 5.8 字符串提取 substr(x, start, stop) substring(text, first, last = 1000000L) substr 和 substring 函数通过位置进行字符串的拆分和提取，它们本身不使用正则表达式，结合其他正则表达式函数regexpr, gregexpr 和 regexec，可以很方便地从大量文本中提取所需的信息。作用类似之前提到的 regmatches 函数 参数设置基本相同 x/text 是要拆分的字符串向量 start/first 截取的起始位置向量 stop/last 截取的终止位置向量 返回值有差别 substr 返回的字串个数等于第一个参数 x 的长度 substring 返回字串个数等于三个参数中最长向量长度，短向量循环使用。 x &lt;- &quot;123456789&quot; substr(x, c(2, 4), c(4, 5, 8)) #&gt; [1] &quot;234&quot; substring(x, c(2, 4), c(4, 5, 8)) #&gt; [1] &quot;234&quot; &quot;45&quot; &quot;2345678&quot; substr(&quot;abcdef&quot;, 2, 4) #&gt; [1] &quot;bcd&quot; substring(&quot;abcdef&quot;, 1:6, 1:6) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; 因为 x 的向量长度为1，所以 substr 获得的结果只有1个字串，即第2和第3个参数向量只用了第一个组合：起始位置2，终止位置4。而 substring 的语句三个参数中最长的向量为 c(4,5,8)，执行时按短向量循环使用的规则第一个参数事实上就是c(x,x,x)，第二个参数就成了c(2,4,2)，最终截取的字串起始位置组合为：2-4, 4-5和2-8。 x &lt;- c(&quot;123456789&quot;, &quot;abcdefghijklmnopq&quot;) substr(x, c(2, 4), c(4, 5, 8)) #&gt; [1] &quot;234&quot; &quot;de&quot; substring(x, c(2, 4), c(4, 5, 8)) #&gt; [1] &quot;234&quot; &quot;de&quot; &quot;2345678&quot; 5.9 其它操作 5.9.1 strwrap strwrap(x, width = 0.9 * getOption(&quot;width&quot;), indent = 0, exdent = 0, prefix = &quot;&quot;, simplify = TRUE, initial = prefix) 该函数把一个字符串当成一个段落的文字（不管字符串中是否有换行符），按照段落的格式（缩进和长度）和断字方式进行分行，每一行是结果中的一个字符串。 # 读取一段文本 x &lt;- paste(readLines(file.path(R.home(&quot;doc&quot;), &quot;THANKS&quot;)), collapse = &quot;\\n&quot;) ## 将文本拆分为段落，且移除前三段 x &lt;- unlist(strsplit(x, &quot;\\n[ \\t\\n]*\\n&quot;))[-(1:3)] # 每一段换两行 x &lt;- paste(x, collapse = &quot;\\n\\n&quot;) # 每一行的宽度设定为60个字符 writeLines(strwrap(x, width = 60)) #&gt; J. D. Beasley, David J. Best, Richard Brent, Kevin Buhr, #&gt; Michael A. Covington, Bill Cleveland, Robert Cleveland,, G. #&gt; W. Cran, C. G. Ding, Ulrich Drepper, Paul Eggert, J. O. #&gt; Evans, David M. Gay, H. Frick, G. W. Hill, Richard H. #&gt; Jones, Eric Grosse, Shelby Haberman, Bruno Haible, John #&gt; Hartigan, Andrew Harvey, Trevor Hastie, Min Long Lam, #&gt; George Marsaglia, K. J. Martin, Gordon Matzigkeit, C. R. #&gt; Mckenzie, Jean McRae, Cyrus Mehta, Fionn Murtagh, John C. #&gt; Nash, Finbarr O&#39;Sullivan, R. E. Odeh, William Patefield, #&gt; Nitin Patel, Alan Richardson, D. E. Roberts, Patrick #&gt; Royston, Russell Lenth, Ming-Jen Shyu, Richard C. #&gt; Singleton, S. G. Springer, Supoj Sutanthavibul, Irma #&gt; Terpenning, G. E. Thomas, Rob Tibshirani, Wai Wan Tsang, #&gt; Berwin Turlach, Gary V. Vaughan, Michael Wichura, Jingbo #&gt; Wang, M. A. Wong, and the Free Software Foundation (for #&gt; autoconf code and utilities). See also files under #&gt; src/extras. #&gt; #&gt; Many more, too numerous to mention here, have contributed #&gt; by sending bug reports and suggesting various improvements. .... # 每一段的段首缩进5个字符 writeLines(strwrap(x, width = 60, indent = 5)) #&gt; J. D. Beasley, David J. Best, Richard Brent, Kevin #&gt; Buhr, Michael A. Covington, Bill Cleveland, Robert #&gt; Cleveland,, G. W. Cran, C. G. Ding, Ulrich Drepper, Paul #&gt; Eggert, J. O. Evans, David M. Gay, H. Frick, G. W. Hill, #&gt; Richard H. Jones, Eric Grosse, Shelby Haberman, Bruno #&gt; Haible, John Hartigan, Andrew Harvey, Trevor Hastie, Min #&gt; Long Lam, George Marsaglia, K. J. Martin, Gordon #&gt; Matzigkeit, C. R. Mckenzie, Jean McRae, Cyrus Mehta, Fionn #&gt; Murtagh, John C. Nash, Finbarr O&#39;Sullivan, R. E. Odeh, #&gt; William Patefield, Nitin Patel, Alan Richardson, D. E. #&gt; Roberts, Patrick Royston, Russell Lenth, Ming-Jen Shyu, #&gt; Richard C. Singleton, S. G. Springer, Supoj Sutanthavibul, #&gt; Irma Terpenning, G. E. Thomas, Rob Tibshirani, Wai Wan #&gt; Tsang, Berwin Turlach, Gary V. Vaughan, Michael Wichura, #&gt; Jingbo Wang, M. A. Wong, and the Free Software Foundation #&gt; (for autoconf code and utilities). See also files under #&gt; src/extras. #&gt; #&gt; Many more, too numerous to mention here, have #&gt; contributed by sending bug reports and suggesting various .... # 除了段首，每一段的余下诸行都缩进5个字符 writeLines(strwrap(x, width = 60, exdent = 5)) #&gt; J. D. Beasley, David J. Best, Richard Brent, Kevin Buhr, #&gt; Michael A. Covington, Bill Cleveland, Robert #&gt; Cleveland,, G. W. Cran, C. G. Ding, Ulrich Drepper, #&gt; Paul Eggert, J. O. Evans, David M. Gay, H. Frick, G. #&gt; W. Hill, Richard H. Jones, Eric Grosse, Shelby #&gt; Haberman, Bruno Haible, John Hartigan, Andrew Harvey, #&gt; Trevor Hastie, Min Long Lam, George Marsaglia, K. J. #&gt; Martin, Gordon Matzigkeit, C. R. Mckenzie, Jean McRae, #&gt; Cyrus Mehta, Fionn Murtagh, John C. Nash, Finbarr #&gt; O&#39;Sullivan, R. E. Odeh, William Patefield, Nitin #&gt; Patel, Alan Richardson, D. E. Roberts, Patrick #&gt; Royston, Russell Lenth, Ming-Jen Shyu, Richard C. #&gt; Singleton, S. G. Springer, Supoj Sutanthavibul, Irma #&gt; Terpenning, G. E. Thomas, Rob Tibshirani, Wai Wan #&gt; Tsang, Berwin Turlach, Gary V. Vaughan, Michael #&gt; Wichura, Jingbo Wang, M. A. Wong, and the Free #&gt; Software Foundation (for autoconf code and utilities). #&gt; See also files under src/extras. #&gt; #&gt; Many more, too numerous to mention here, have contributed .... # 在输出的每一行前面添加前缀 writeLines(strwrap(x, prefix = &quot;THANKS&gt; &quot;)) #&gt; THANKS&gt; J. D. Beasley, David J. Best, Richard Brent, Kevin Buhr, #&gt; THANKS&gt; Michael A. Covington, Bill Cleveland, Robert Cleveland,, #&gt; THANKS&gt; G. W. Cran, C. G. Ding, Ulrich Drepper, Paul Eggert, J. O. #&gt; THANKS&gt; Evans, David M. Gay, H. Frick, G. W. Hill, Richard H. #&gt; THANKS&gt; Jones, Eric Grosse, Shelby Haberman, Bruno Haible, John #&gt; THANKS&gt; Hartigan, Andrew Harvey, Trevor Hastie, Min Long Lam, #&gt; THANKS&gt; George Marsaglia, K. J. Martin, Gordon Matzigkeit, C. R. #&gt; THANKS&gt; Mckenzie, Jean McRae, Cyrus Mehta, Fionn Murtagh, John C. #&gt; THANKS&gt; Nash, Finbarr O&#39;Sullivan, R. E. Odeh, William Patefield, #&gt; THANKS&gt; Nitin Patel, Alan Richardson, D. E. Roberts, Patrick #&gt; THANKS&gt; Royston, Russell Lenth, Ming-Jen Shyu, Richard C. #&gt; THANKS&gt; Singleton, S. G. Springer, Supoj Sutanthavibul, Irma #&gt; THANKS&gt; Terpenning, G. E. Thomas, Rob Tibshirani, Wai Wan Tsang, #&gt; THANKS&gt; Berwin Turlach, Gary V. Vaughan, Michael Wichura, Jingbo #&gt; THANKS&gt; Wang, M. A. Wong, and the Free Software Foundation (for #&gt; THANKS&gt; autoconf code and utilities). See also files under #&gt; THANKS&gt; src/extras. #&gt; THANKS&gt; #&gt; THANKS&gt; Many more, too numerous to mention here, have contributed #&gt; THANKS&gt; by sending bug reports and suggesting various .... 再举一个烧脑的例子 x &lt;- paste(sapply( sample(10, 100, replace = TRUE), # 从1-10个数字中有放回的随机抽取100个数 function(x) substring(&quot;aaaaaaaaaa&quot;, 1, x) ), collapse = &quot; &quot;) sapply( 10:40, function(m) c(target = m, actual = max(nchar(strwrap(x, m)))) ) #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] #&gt; target 10 11 12 13 14 15 16 17 18 19 20 21 #&gt; actual 10 10 11 12 13 14 15 16 17 18 19 20 #&gt; [,13] [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] #&gt; target 22 23 24 25 26 27 28 29 30 31 32 #&gt; actual 21 22 23 24 25 26 27 28 29 30 31 #&gt; [,24] [,25] [,26] [,27] [,28] [,29] [,30] [,31] #&gt; target 33 34 35 36 37 38 39 40 #&gt; actual 32 33 34 35 36 36 38 39 5.9.2 strtrim strtrim(x, width) strtrim 函数将字符串x修剪到特定的显示宽度，返回的字符串向量的长度等于字符串向量 x 的长度，如果 width 的参数值（它是一个整型向量）的长度小于 x 的，就循环补齐。 strtrim(c(&quot;abcdef&quot;, &quot;abcdef&quot;, &quot;abcdef&quot;), c(1, 5, 10)) #&gt; [1] &quot;a&quot; &quot;abcde&quot; &quot;abcdef&quot; 5.9.3 strrep strrep(x, times) 以给定的次数重复字符串向量中每个元素的个数，并连接字符串的各个副本 strrep(&quot;ABC&quot;, 2) #&gt; [1] &quot;ABCABC&quot; strrep(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), 1 : 3) #&gt; [1] &quot;A&quot; &quot;BB&quot; &quot;CCC&quot; # 创建一个字符串向量，指定每个元素中空格的数量 strrep(&quot; &quot;, 1 : 5) #&gt; [1] &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; 5.9.4 trimws trimws(x, which = c(&quot;both&quot;, &quot;left&quot;, &quot;right&quot;), whitespace = &quot;[ \\t\\r\\n]&quot;) trimws 函数用于移除字符串中的空格，这种空格可以来自制表符、回车符和换行符，位置可以位于字符串的开头或者结尾，which 参数指定空格的大致位置。举例如下 x &lt;- &quot; Some text. &quot; x #&gt; [1] &quot; Some text. &quot; trimws(x) #&gt; [1] &quot;Some text.&quot; trimws(x, &quot;l&quot;) #&gt; [1] &quot;Some text. &quot; trimws(x, &quot;r&quot;) #&gt; [1] &quot; Some text.&quot; 5.10 运行环境 xfun::session_info() #&gt; R version 3.6.1 (2019-07-05) #&gt; Platform: x86_64-pc-linux-gnu (64-bit) #&gt; Running under: Debian GNU/Linux 10 (buster) #&gt; #&gt; Locale: #&gt; LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C #&gt; LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 #&gt; LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 #&gt; LC_PAPER=en_US.UTF-8 LC_NAME=C #&gt; LC_ADDRESS=C LC_TELEPHONE=C #&gt; LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C #&gt; #&gt; Package version: #&gt; base64enc_0.1.3 bookdown_0.12 codetools_0.2-16 compiler_3.6.1 #&gt; curl_4.0 digest_0.6.20 evaluate_0.14 glue_1.3.1 #&gt; graphics_3.6.1 grDevices_3.6.1 highr_0.8 htmltools_0.3.6 #&gt; jsonlite_1.6 knitr_1.23 magrittr_1.5 markdown_1.0 #&gt; methods_3.6.1 mime_0.7 Rcpp_1.0.2 rmarkdown_1.14 #&gt; stats_3.6.1 stringi_1.4.3 stringr_1.4.0 tinytex_0.14 #&gt; tools_3.6.1 utils_3.6.1 xfun_0.8 yaml_2.2.0 "],
["dc-regular-expressions.html", "第 6 章 正则表达式 6.1 字符常量 6.2 软件环境 6.3 基本概念 6.4 字符串匹配 6.5 级联表达式 6.6 反向引用 6.7 命名捕捉 6.8 表达式注释", " 第 6 章 正则表达式 维基百科关于 正则表达式的描述， 学习正则表达式 R 内置的三种匹配模式 fixed = TRUE: 字面意思匹配 exact matching. perl = TRUE: 使用 Perl 正则表达式. fixed = FALSE, perl = FALSE: 使用 POSIX 1003.2 extended 正则表达式 (默认设置). 不要拘泥于一种解决方案，比如清理数据中正则表达式有 Base R 提供的一套，stringr 又一套，提高效率的工具 RStudio 插件 regexplain 和辅助创建正则表达式 RVerbalExpressions 包 有几个名词需要单独拎出来解释的 literal character strings 字面字符串 metacharacters 元字符 extended regular expressions 在下文中约定翻译为默认正则表达式 character class 字符集 [abc] Perl-like regular expressions Perl 风格的正则表达式 以下所述，都不考虑函数中参数 perl=TRUE 的情况，R 语言中提供了扩展的（默认的）和 Perl 风格 的两套正则表达式。作为入门，我们这里只关注前者，启用 Perl 正则表达式只需在函数如 grep 中将选项 perl = TRUE 即可，并将后者统一命名为 Perl 正则表达式21。 正则表达式 (regular expression，简称 regexp)， 函数 regexpr 和 gregexpr 的名称就好理解了，在控制台输入 ?regex 查看 R 支持的正则表达式，这个文档看上百八十回也不过分。R 内支持正则表达式的函数有 grep、grepl、sub、gsub、regexpr、gregexpr 、 regexec 和 strsplit。函数 apropos，browseEnv，help.search，list.files 和 ls 是通过函数 grep 来使用正则表达式的，它们全都使用 extended regular expressions grep(pattern, x, ignore.case = FALSE, perl = FALSE, value = FALSE, fixed = FALSE, useBytes = FALSE, invert = FALSE) 匹配模式 pattern 的内容 可以用函数 cat 打印出来，注意反斜杠进入 R 字符串中时，需要用两个，反斜杠 \\ 本身是转义符，否则会报错。 cat(&quot;\\\\&quot;) # \\ 反斜杠是转义字符 #&gt; \\ cat(&quot;\\\\.&quot;) #&gt; \\. cat(&quot;\\\\\\n&quot;) # 注意 \\n 表示换行 #&gt; \\ 6.1 字符常量 单引号 ' 双引号 \" 和反引号 ` 三种类型的引用 (quotes) 是 R 语法的一部分22，此外反斜杠 \\ 用来转义下面的字符 表 6.1: 字符常量表 字符常量 含义 \\n 换行 newline \\r 回车 carriage return \\t 制表符 tab \\b 退格 backspace \\a 警报（铃）alert (bell) \\f 换页 form feed \\v 垂直制表符 vertical tab \\\\ 反斜杠 backslash \\ \\' 单引号 ASCII apostrophe ' \\\" 双引号 ASCII quotation mark \" \\` 反引号或沉音符 ASCII grave accent (backtick) ` \\nnn 八进制 character with given octal code (1, 2 or 3 digits) \\xnn 十六进制 character with given hex code (1 or 2 hex digits) \\unnnn Unicode character with given code (1–4 hex digits) \\Unnnnnnnn Unicode character with given code (1–8 hex digits) 6.2 软件环境 R 内置的正则表达式实现是基于 PCRE ICU TRE iconv 等第三方库，搞清楚自己使用的版本信息是重要的，一些字符集的解释与区域环境有关，如 [:alnum:] 和 [:alpha:]等，所以获取当前的区域设置也很重要 # find a suitable coding for the current locale localeToCharset(locale = Sys.getlocale(&quot;LC_CTYPE&quot;)) #&gt; [1] &quot;UTF-8&quot; &quot;ISO8859-1&quot; # 软件版本信息 extSoftVersion() #&gt; zlib #&gt; &quot;1.2.11&quot; #&gt; bzlib #&gt; &quot;1.0.6, 6-Sept-2010&quot; #&gt; xz #&gt; &quot;5.2.4&quot; #&gt; PCRE #&gt; &quot;8.39 2016-06-14&quot; #&gt; ICU #&gt; &quot;63.1&quot; #&gt; TRE #&gt; &quot;TRE 0.8.0 R_fixes (BSD)&quot; #&gt; iconv #&gt; &quot;glibc 2.28&quot; #&gt; readline #&gt; &quot;7.0&quot; #&gt; BLAS #&gt; &quot;/usr/lib/x86_64-linux-gnu/blas/libblas.so.3.8.0&quot; # 区域及其编码信息 l10n_info() #&gt; $MBCS #&gt; [1] TRUE #&gt; #&gt; $`UTF-8` #&gt; [1] TRUE #&gt; #&gt; $`Latin-1` #&gt; [1] FALSE # 表示数字、货币的细节 Sys.localeconv() #&gt; decimal_point thousands_sep grouping int_curr_symbol #&gt; &quot;.&quot; &quot;&quot; &quot;&quot; &quot;USD &quot; #&gt; currency_symbol mon_decimal_point mon_thousands_sep mon_grouping #&gt; &quot;$&quot; &quot;.&quot; &quot;,&quot; &quot;\\003\\003&quot; #&gt; positive_sign negative_sign int_frac_digits frac_digits #&gt; &quot;&quot; &quot;-&quot; &quot;2&quot; &quot;2&quot; #&gt; p_cs_precedes p_sep_by_space n_cs_precedes n_sep_by_space #&gt; &quot;1&quot; &quot;0&quot; &quot;1&quot; &quot;0&quot; #&gt; p_sign_posn n_sign_posn #&gt; &quot;1&quot; &quot;1&quot; # PCRE 启用的配置选项 pcre_config() #&gt; UTF-8 Unicode properties JIT #&gt; TRUE TRUE TRUE #&gt; stack #&gt; TRUE # 比较全的字符信息 stringi::stri_info() #&gt; $Unicode.version #&gt; [1] &quot;11.0&quot; #&gt; #&gt; $ICU.version #&gt; [1] &quot;63.1&quot; #&gt; #&gt; $Locale #&gt; $Locale$Language #&gt; [1] &quot;en&quot; #&gt; #&gt; $Locale$Country #&gt; [1] &quot;US&quot; #&gt; #&gt; $Locale$Variant #&gt; [1] &quot;&quot; #&gt; #&gt; $Locale$Name #&gt; [1] &quot;en_US&quot; #&gt; #&gt; #&gt; $Charset.internal #&gt; [1] &quot;UTF-8&quot; &quot;UTF-16&quot; #&gt; #&gt; $Charset.native #&gt; $Charset.native$Name.friendly #&gt; [1] &quot;UTF-8&quot; #&gt; #&gt; $Charset.native$Name.ICU #&gt; [1] &quot;UTF-8&quot; #&gt; #&gt; $Charset.native$Name.UTR22 #&gt; [1] NA #&gt; #&gt; $Charset.native$Name.IBM #&gt; [1] &quot;ibm-1208&quot; #&gt; #&gt; $Charset.native$Name.WINDOWS #&gt; [1] &quot;windows-65001&quot; #&gt; #&gt; $Charset.native$Name.JAVA #&gt; [1] &quot;UTF-8&quot; #&gt; #&gt; $Charset.native$Name.IANA #&gt; [1] &quot;UTF-8&quot; #&gt; #&gt; $Charset.native$Name.MIME #&gt; [1] &quot;UTF-8&quot; #&gt; #&gt; $Charset.native$ASCII.subset #&gt; [1] TRUE #&gt; #&gt; $Charset.native$Unicode.1to1 #&gt; [1] NA #&gt; #&gt; $Charset.native$CharSize.8bit #&gt; [1] FALSE #&gt; #&gt; $Charset.native$CharSize.min #&gt; [1] 1 #&gt; #&gt; $Charset.native$CharSize.max #&gt; [1] 3 #&gt; #&gt; #&gt; $ICU.system #&gt; [1] TRUE #&gt; #&gt; $ICU.UTF8 #&gt; [1] TRUE 需要临时改变区域环境设置，配合特殊的画图和文本输出要求。 # 获取当前默认的区域设置 Sys.getlocale() foo &lt;- Sys.getlocale() # 恢复默认的区域设置 Sys.setlocale(&quot;LC_ALL&quot;, locale = foo) 6.3 基本概念 正则表达式的构造方式类似算术表达式，通过各种操作组合子（更小的）表达式，整个表达式匹配一个或多个字符23。大多数字符，包括所有的字母和数字，是匹配自身的正则表达式。元字符 . \\ | ( ) [ { ^ $ * + ? 需要转义才能表达其自身的含义，转义的方式是在元字符前面添加反斜杠，如要表达点号 . 需要使用 \\.。要注意，它们是否有特殊意义取决于所在的内容。 一个字符集 (character class) 是用一对中括号[]括起来的字符列表，用来匹配列表中的任意单个字符，除非列表中的第一个字符是 ^，它用来匹配不在这个列表中的字符。 [0123456789] 用来匹配任意单个数字，[^abc] 用来匹配除字符 a,b,c 以外的任意字符。字符范围 (character ranges) 可以通过第一个和最后一个字符指定， 中间用连字符 (hyphen) 连接， 由于这种解释依赖于区域和具体实现，所以指定字符范围的使用方式最好避免。唯一可移植（便携，通用）的方式是作为字符集，在列表中列出所有的 ASCII 字母， [ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz]. 预定义的一些字符类，它们的解释依赖于当前的语言区域，下面是 POSIX locale 环境下的解释 [:alnum:] 表示 [:alpha:] 和 [:digit:]，含义是 [0-9A-Za-z]，但是前者与区域和字符集无关，后者依赖于当前的区域设置和字符编码。要注意在这些字符集名 class names 中，中括号 [] 是符号名的一部分，是必须要包含的。在字符集中，大多数元字符失去它们特殊的意义。 [:alpha:] 表示 [:lower:] 和 [:upper:] [:blank:] 表示 空格 space 制表符 tab [:cntrl:] 表示控制符，在 ASCII 字符集里里，这些字符有八进制代码，从 000 到 037，和 177(DEL)。 [:digit:] 表示数字 0,1,2,3,4,5,6,7,8,9 [:graph:] 表示 [:alnum:] 和 [:punct:]. [:lower:] 表示当前区域下的小写字母 [:print:] 表示可打印的字符 [:alnum:], [:punct:] 和空格. [:punct:] 表示标点字符 ! &quot; # $ % &amp; &#39; ( ) * + , - . / : ; &lt; = &gt; ? @ [ \\ ] ^ _ ` { | } ~` [:space:] 表示空格字符： 水平制表符 tab， 换行符 newline，垂直制表符 vertical tab，换页符 form feed，回车符 carriage return，空格符 space [:xdigit:] 表示 16 进制数字 0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f. 要包含字面的 ] 就把它放在列表的开头，类似地，要包含字面 ^，除了开头可以放在任意位置。要包含字面 - 把它放在开头或者结尾。只有 ^ - \\ ] 在字符集内是有特殊的含义 点号 . 匹配任意单个字符，\\w 匹配一个词 word 字符(是[[:alnum:]_]的同义词，一个扩展) ，而 \\W 是 \\w 取反，意味着 [^[:alnum:]_]。 \\d, \\s, \\D 和 \\S 表示数字和空格类和它们的取反 脱字符 caret ^ 和美元符号 $ 是元字符，分别匹配一行的开头和结尾。符号 \\&lt; 和 \\&gt; 分别匹配一个词的开头和结尾的空字符串。\\b 匹配词边缘的空字符串，\\B 匹配不在词边缘的空字符串。 词 word 的解释依赖于区域和实现。 6.4 字符串匹配 默认的匹配方式是贪婪的，会使用尽可能多的匹配次数，这个可以变为最小的匹配次数，通过在其之后添加 ?，一个正则表达式可能跟着重复量词，下面的限定符都是限定在它前面的正则表达式 表 6.2: 贪婪匹配限定符 符号 描述 ? 匹配至多 1 次 * 匹配 0 次或多次 + 匹配至少 1 次 {n} 匹配 n 次 {n,} 匹配至少 n 次 {n,m} 匹配至少 n 次，至多 m 次 6.5 级联表达式 Regular expressions may be concatenated; the resulting regular expression matches any string formed by concatenating the substrings that match the concatenated subexpressions. 正则表达式可以是级联 concatenation 的，是不是在讲一个正则表达式里面嵌套一个正则表达式？ 两个正则表达式可以通过中缀符号 | 联合，用两个子表达式的任意一个去匹配字符串，例如 abba | cde 要么匹配字符串 abba 要么匹配字符串 cde，要注意在字符集内，即 abba|cde，二选一的匹配不凑效，因为中缀符 | 有它的字面意思。 重复匹配 Repetition 的优先级高于级联，级联高于 | 。 整个子表达式可以括号括起来覆盖这些优先级规则。 6.6 反向引用 反向引用 \\N 这里 N 可取 1,2,…,9 匹配被之前第 N 个括起来的子表达式匹配的子字符串，例子见 COS 论坛 https://d.cosx.org/d/420570/5 6.7 命名捕捉 模式 (?:...) 包住的字符就是括号分组，但是不做反向查找。模式 (?&lt;=...) 和 (?&lt;!...) 都是反向查找，它们不允许跟限制符，在 ... 也不允许出现 \\C。表 6.3 展示四个反向引用 表 6.3: 环顾四周查找 符号 描述 ?= 正向肯定查找 ?! 正向否定查找 ?&lt;= 反向肯定查找 ?&lt;! 反向否定查找 函数 regexpr 和 gregexpr 支持命名捕捉 (named capture). 如果一个组被命名了，如 (?&lt;first&gt;[A-Z][a-z]+) 那么，匹配的位置是按名字返回。 下面举个例子说明，从字符串向量 notables 中获得了三组匹配 name.rex 是一段正则表达式，描述的模式是人名 ## named capture notables &lt;- c(&quot; Ben Franklin and Jefferson Davis&quot;, &quot;\\tMillard Fillmore&quot;) # name groups &#39;first&#39; and &#39;last&#39; name.rex &lt;- &quot;(?&lt;first&gt;[[:upper:]][[:lower:]]+) (?&lt;last&gt;[[:upper:]][[:lower:]]+)&quot; parsed &lt;- regexpr(name.rex, notables, perl = TRUE) parsed #&gt; [1] 3 2 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 12 16 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE #&gt; attr(,&quot;capture.start&quot;) #&gt; first last #&gt; [1,] 3 7 #&gt; [2,] 2 10 #&gt; attr(,&quot;capture.length&quot;) #&gt; first last #&gt; [1,] 3 8 #&gt; [2,] 7 8 #&gt; attr(,&quot;capture.names&quot;) #&gt; [1] &quot;first&quot; &quot;last&quot; notables 是一个长度为2的字符串向量，所以获得两组匹配，捕捉到匹配开始的位置 capture.start 和匹配的长度 capture.length 都是两组，按列来看，字符 B 出现在字符串 Ben Franklin and Jefferson Davis 的第三个位置，匹配的长度 Ben 是三个字符，长度是 3，如图 6.1 所示，需要注意的是一定要设置 perl = TRUE 才能使用命名捕捉功能，函数 sub 不支持命名反向引用 Named backreferences 图 6.1: 命名捕捉 Atomic grouping 原子分组, possessive qualifiers 占有限定 and conditional 条件 and recursive 递归等模式超出介绍的范围，不在此处详述，感兴趣的读者可参考，此外，插播一条漫画 6.2 图 6.2: 正则表达式漫画 正则表达式的直观解释 https://github.com/gadenbuie/regexplain 6.8 表达式注释 The sequence (?# marks the start of a comment which continues up to the next closing parenthesis. Nested parentheses are not permitted. The characters that make up a comment play no part at all in the pattern matching. If the extended option is set, an unescaped # character outside a character class introduces a comment that continues up to the next newline character in the pattern. "],
["dv-plot.html", "第 7 章 绘图素材库 7.1 基本要素 7.2 统计图形 7.3 运行环境", " 第 7 章 绘图素材库 作为知识介绍，本章所有数据都来源于基础 R 包，即安装 R 软件后自带的数据集，图库在以 base R 中的数据集介绍完后，以相应真实数据扩展为案列，结合统计意义和探索性数据分析介绍各种常见统计图形 数据可视化是一种重要的数据分析手段， R 提供了两套图形系统，分别是 graphics 包提供的基础绘图系统和 grid 包提供的栅格绘图系统，后者主要以两个 R 包为大家所熟知，一个是 lattice 包，另一个是 ggplot2 包。 Base 图形系统的扩展包 basetheme 可以设置主题，prettyB 和 gridGraphics 为了方便记忆函数 par 的各个参数，Paul Murrell 整理了一份 助记符，此外，LaTeX 宏包 geometry 对版面设置有很多专业的说明 7.1 基本要素 7.1.1 点线 点和线是最常见的画图元素，在 plot 函数中，分别用参数 pch 和 lty 来设定类型，点的大小、线的宽度分别用参数 cex 和 lwd 来指定，颜色由参数 col 设置。参数 type 不同的值设置如下，p 显示点，l 绘制线，b 同时绘制空心点，并用线连接，c 只有线，o 在线上绘制点，s 和 S 点线连接绘制阶梯图，h 绘制类似直方图一样的垂线，最后 n 表示什么也不画。 点 points 、线 grid 背景线 abline lines rug 刻度线（线段segments、箭头arrows）、 ## -------- Showing all the extra &amp; some char graphics symbols --------- pchShow &lt;- function(extras = c(&quot;*&quot;, &quot;.&quot;, &quot;o&quot;, &quot;O&quot;, &quot;0&quot;, &quot;+&quot;, &quot;-&quot;, &quot;|&quot;, &quot;%&quot;, &quot;#&quot;), cex = 2, ## good for both .Device==&quot;postscript&quot; and &quot;x11&quot; col = &quot;red3&quot;, bg = &quot;gold&quot;, coltext = &quot;brown&quot;, cextext = 1.2, main = paste( &quot;plot symbols : points (... pch = *, cex =&quot;, cex, &quot;)&quot; )) { nex &lt;- length(extras) np &lt;- 26 + nex ipch &lt;- 0:(np - 1) k &lt;- floor(sqrt(np)) dd &lt;- c(-1, 1) / 2 rx &lt;- dd + range(ix &lt;- ipch %/% k) ry &lt;- dd + range(iy &lt;- 3 + (k - 1) - ipch %% k) pch &lt;- as.list(ipch) # list with integers &amp; strings if (nex &gt; 0) pch[26 + 1:nex] &lt;- as.list(extras) plot(rx, ry, type = &quot;n&quot;, axes = FALSE, xlab = &quot;&quot;, ylab = &quot;&quot;, main = main) abline(v = ix, h = iy, col = &quot;lightgray&quot;, lty = &quot;dotted&quot;) for (i in 1:np) { pc &lt;- pch[[i]] ## &#39;col&#39; symbols with a &#39;bg&#39;-colored interior (where available) : points(ix[i], iy[i], pch = pc, col = col, bg = bg, cex = cex) if (cextext &gt; 0) { text(ix[i] - 0.3, iy[i], pc, col = coltext, cex = cextext) } } } pchShow() 图 7.1: 不同的 pch 参数值 ## ------------ test code for various pch specifications ------------- # Try this in various font families (including Hershey) # and locales. Use sign = -1 asserts we want Latin-1. # Standard cases in a MBCS locale will not plot the top half. TestChars &lt;- function(sign = 1, font = 1, ...) { MB &lt;- l10n_info()$MBCS r &lt;- if (font == 5) { sign &lt;- 1 c(32:126, 160:254) } else if (MB) 32:126 else 32:255 if (sign == -1) r &lt;- c(32:126, 160:255) par(pty = &quot;s&quot;) plot(c(-1, 16), c(-1, 16), type = &quot;n&quot;, xlab = &quot;&quot;, ylab = &quot;&quot;, xaxs = &quot;i&quot;, yaxs = &quot;i&quot;, main = sprintf(&quot;sign = %d, font = %d&quot;, sign, font) ) grid(17, 17, lty = 1) mtext(paste(&quot;MBCS:&quot;, MB)) for (i in r) try(points(i %% 16, i %/% 16, pch = sign * i, font = font, ...)) } TestChars() try(TestChars(sign = -1)) TestChars(font = 5) # Euro might be at 160 (0+10*16). # macOS has apple at 240 (0+15*16). try(TestChars(-1, font = 2)) # bold 图 7.2: pch 支持的字符 x &lt;- 0:12 y &lt;- sin(pi / 5 * x) par(mfrow = c(3, 3), mar = .1 + c(2, 2, 3, 1)) for (tp in c(&quot;p&quot;, &quot;l&quot;, &quot;b&quot;, &quot;c&quot;, &quot;o&quot;, &quot;h&quot;, &quot;s&quot;, &quot;S&quot;, &quot;n&quot;)) { plot(y ~ x, type = tp, main = paste0(&quot;plot(*, type = \\&quot;&quot;, tp, &quot;\\&quot;)&quot;)) if (tp == &quot;S&quot;) { lines(x, y, type = &quot;s&quot;, col = &quot;red&quot;, lty = 2) mtext(&quot;lines(*, type = \\&quot;s\\&quot;, ...)&quot;, col = &quot;red&quot;, cex = 0.8) } } 图 7.3: 不同的 type 参数值 颜色 col 连续型和离散型 线帽/端和字体的样式 # 合并为一个图 三条粗横线 横线上三种字形 plot(c(1, 20), c(1, 20), type = &quot;n&quot;, ann = FALSE) lines(x = c(5, 15), y = c(5, 5), lwd = 15, lend = &quot;round&quot;) text(10, 5, &quot;Hello, Helvetica&quot;, cex = 1.5, family = &quot;sans&quot;, pos = 1, offset = 1.5) text(5, 5, &quot;sans&quot;, cex = 1.5, family = &quot;sans&quot;, pos = 2, offset = .5) text(15, 5, &quot;lend = round&quot;, pos = 4, offset = .5) lines(x = c(5, 15), y = c(10, 10), lwd = 15, lend = &quot;butt&quot;) text(10, 10, &quot;Hello, Helvetica&quot;, cex = 1.5, family = &quot;mono&quot;, pos = 1, offset = 1.5) text(5, 10, &quot;mono&quot;, cex = 1.5, family = &quot;mono&quot;, pos = 2, offset = .5) text(15, 10, &quot;lend = butt&quot;, pos = 4, offset = .5) lines(x = c(5, 15), y = c(15, 15), lwd = 15, lend = &quot;square&quot;) text(10, 15, &quot;Hello, Helvetica&quot;, cex = 1.5, family = &quot;serif&quot;, pos = 1, offset = 1.5) text(5, 15, &quot;serif&quot;, cex = 1.5, family = &quot;serif&quot;, pos = 2, offset = .5) text(15, 15, &quot;lend = square&quot;, pos = 4, offset = .5) 图 7.4: 不同的线端样式 lend：线端的样式，可用一个整数或字符串指定： 0 或 “round” 圆形（默认） 1 或 “butt” 对接形 2 或 “square” 方形 7.1.2 区域 矩形，多边形，曲线交汇出来的区域 面（矩形rect，多边形polygon）、路径 polypath 面/多边形 rect 颜色填充 # From the manual ch.col &lt;- c( &quot;rainbow(n, start=.7, end=.1)&quot;, &quot;heat.colors(n)&quot;, &quot;terrain.colors(n)&quot;, &quot;topo.colors(n)&quot;, &quot;cm.colors(n)&quot; ) # 选择颜色 n &lt;- 16 nt &lt;- length(ch.col) i &lt;- 1:n j &lt;- n / nt d &lt;- j / 6 dy &lt;- 2 * d plot(i, i + d, type = &quot;n&quot;, yaxt = &quot;n&quot;, ylab = &quot;&quot;, xlab = &quot;&quot;, main = paste(&quot;color palettes; n=&quot;, n) ) for (k in 1:nt) { rect(i - .5, (k - 1) * j + dy, i + .4, k * j, col = eval(parse(text = ch.col[k])) ) # 咬人的函数/字符串解析为/转函数 text(2 * j, k * j + dy / 4, ch.col[k]) } 图 7.5: rect 函数画长方形 clip(x1, x2, y1, y2) 在用户坐标中设置剪切区域 x &lt;- rnorm(1000) hist(x, xlim = c(-4, 4)) usr &lt;- par(&quot;usr&quot;) clip(usr[1], -2, usr[3], usr[4]) hist(x, col = &quot;red&quot;, add = TRUE) clip(2, usr[2], usr[3], usr[4]) hist(x, col = &quot;blue&quot;, add = TRUE) do.call(&quot;clip&quot;, as.list(usr)) # reset to plot region my.col &lt;- function(f, g, xmin, xmax, col, N = 200, xlab = &quot;&quot;, ylab = &quot;&quot;, main = &quot;&quot;) { x &lt;- seq(xmin, xmax, length = N) fx &lt;- f(x) gx &lt;- g(x) plot(0, 0, type = &quot;n&quot;, xlim = c(xmin, xmax), ylim = c(min(fx, gx), max(fx, gx)), xlab = xlab, ylab = ylab, main = main ) polygon(c(x, rev(x)), c(fx, rev(gx)), col = &quot;#EA4335&quot;, border = 0 ) lines(x, fx, lwd = 3, col = &quot;#34A853&quot;) lines(x, gx, lwd = 3, col = &quot;#4285f4&quot;) } my.col(function(x) x^2, function(x) x^2 + 10 * sin(x), -6, 6, main = &quot;The \\&quot;polygon\\&quot; function&quot; ) 图 7.6: 区域重叠 polygon 函数 各种符号 7.7 plot(0, 0, xlim = c(1, 5), ylim = c(-.5, 4), axes = F, xlab = &quot;&quot;, ylab = &quot;&quot; ) for (i in 0:4) { for (j in 1:5) { n &lt;- 5 * i + j points(j, i, pch = n, cex = 3 ) text(j, i - .3, as.character(n)) } } 图 7.7: cex 支持的符号 点、线、多边形和圆聚集在图 7.8 中 # https://jeroen.github.io/uros2018/#23 plot.new() plot.window(xlim = c(0, 100), ylim = c(0, 100)) polygon(c(10, 40, 80), c(10, 80, 40), col = &quot;hotpink&quot;) text(40, 90, labels = &quot;My drawing&quot;, col = &quot;navyblue&quot;, cex = 3) symbols(c(70, 80, 90), c(20, 50, 80), circles = c(10, 20, 10), bg = c(&quot;#4285f4&quot;, &quot;#EA4335&quot;, &quot;red&quot;), add = TRUE, lty = &quot;dashed&quot; ) 图 7.8: 多边形和符号元素 在介绍各种统计图形之前，先介绍几个绘图函数 plot 和 text 还有 par 参数设置， 作为最简单的开始，尽量依次介绍其中的每个参数的含义并附上图形对比。 y &lt;- x &lt;- 1:4 plot(x, y, ann = F, col = &quot;blue&quot;, pch = 16) text(x, y, labels = c(&quot;1st&quot;, &quot;2nd&quot;, &quot;3rd&quot;, &quot;4th&quot;), col = &quot;red&quot;, pos = c(3, 4, 4, 1), offset = 0.6 ) ahat &lt;- &quot;sigma&quot; # title(substitute(hat(a) == ahat, list(ahat = ahat))) title(bquote(hat(a) == .(ahat))) 图 7.9: pos 位置参数 其中 labels， pos 都是向量化的参数 7.1.3 参考线 矩形网格线是用做背景参考线的，常常是淡灰色的细密虚线，plot 函数的 panel.first 参数和 grid 函数常用来画这种参考线 # modified from https://yihui.name/cn/2018/02/cohen-s-d/ n &lt;- 30 # 样本量（只是一个例子） x &lt;- seq(0, 12, 0.01) par(mar = c(4, 4, 0.2, 0.1)) plot(x / sqrt(n), 2 * (1 - pt(x, n - 1)), xlab = expression(d = x / sqrt(n)), type = &quot;l&quot;, panel.first = grid() ) abline(v = c(0.01, 0.2, 0.5, 0.8, 1.2, 2), lty = 2) 图 7.10: 添加背景参考线 7.1.4 坐标轴 图形控制参数默认设置下 par 通常的一幅图形，改变坐标轴标签是很简单的 x &lt;- 1:100 y &lt;- runif(100, -2, 2) plot(x, y) plot(x, y, xlab = &quot;Index&quot;, ylab = &quot;Uniform draws&quot;) 改变坐标轴标签和标题 op &lt;- par(no.readonly = TRUE) # 保存默认的 par 设置 par(cex.lab = 1.5, cex.axis = 1.3) plot(x, y, xlab = &quot;Index&quot;, ylab = &quot;Uniform draws&quot;) # 设置更大的坐标轴标签内容 par(mar = c(6, 6, 3, 3), cex.axis = 1.5, cex.lab = 2) plot(x, y, xlab = &quot;Index&quot;, ylab = &quot;Uniform draws&quot;) 使用 axis 函数可以更加精细地控制坐标轴 par(op) # 恢复默认的 par 设置 plot(x, y, xaxt = &quot;n&quot;) # 去掉 x 轴 axis(side = 1, at = c(5, 50, 100)) # 添加指定的刻度标签 指定刻度标签的内容 plot(x, y, yaxt = &quot;n&quot;) axis(side = 2, at = c(-2, 0, 2), labels = c(&quot;Small&quot;, &quot;Medium&quot;, &quot;Big&quot;)) 控制刻度线和轴线和刻度标签 plot(x, y) axis(side = 3, at = c(5, 25, 75), lwd = 4, lwd.ticks = 2, col.ticks = &quot;red&quot;) 还可以把 box 移除，绘图区域的边框去掉，只保留坐标轴 plot(x, y, bty = &quot;n&quot;, xaxt = &quot;n&quot;, yaxt = &quot;n&quot;) axis(side = 1, at = seq(0, 100, 20), lwd = 3) axis(side = 2, at = seq(-2, 2, 2), lwd = 3) # 双Y轴 N &lt;- 200 x &lt;- seq(-4, 4, length = N) y1 &lt;- sin(x) y2 &lt;- cos(x) op &lt;- par(mar = c(5, 4, 4, 4)) # Add some space in the right margin # The default is c(5,4,4,2) + .1 xlim &lt;- range(x) ylim &lt;- c(-1.1, 1.1) plot(x, y1, col = &quot;blue&quot;, type = &quot;l&quot;, xlim = xlim, ylim = ylim, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;, main = &quot;Title&quot; ) axis(1) axis(2, col = &quot;blue&quot;) par(new = TRUE) plot(x, y2, col = &quot;red&quot;, type = &quot;l&quot;, xlim = xlim, ylim = ylim, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;, main = &quot;&quot; ) axis(4, col = &quot;red&quot;) mtext(&quot;First Y axis&quot;, 2, line = 2, col = &quot;blue&quot;, cex = 1.2) mtext(&quot;Second Y axis&quot;, 4, line = 2, col = &quot;red&quot;, cex = 1.2) # 1,2,3,4 分别代表下左上右四个位置 图 7.11: 两个 Y 轴 调整坐标轴标签的距离 ## Changing default gap between labels: plot(c(0, 100), c(0, 50), type = &quot;n&quot;, axes = FALSE, ann = FALSE) title(quote(&quot;axis(1, .., gap.axis = f),&quot; ~ ~ f &gt;= 0)) axis(2, at = 5 * (0:10), las = 1, gap.axis = 1 / 4) gaps &lt;- c(4, 2, 1, 1 / 2, 1 / 4, 0.1, 0) chG &lt;- paste0( ifelse(gaps == 1, &quot;default: &quot;, &quot;&quot;), &quot;gap.axis=&quot;, formatC(gaps) ) jj &lt;- seq_along(gaps) linG &lt;- -2.5 * (jj - 1) for (j in jj) { isD &lt;- gaps[j] == 1 # is default axis(1, at = 5 * (0:20), gap.axis = gaps[j], padj = -1, line = linG[j], col.axis = if (isD) &quot;forest green&quot; else 1, font.axis = 1 + isD ) } mtext(chG, side = 1, padj = -1, line = linG - 1 / 2, cex = 3 / 4, col = ifelse(gaps == 1, &quot;forest green&quot;, &quot;blue3&quot;) ) ## now shrink the window (in x- and y-direction) and observe the axis labels drawn 图 7.12: gap.axis用法 旋转坐标轴标签 # Rotated axis labels in R plots # https://menugget.blogspot.com/2014/08/rotated-axis-labels-in-r-plots.html # Example data tmin &lt;- as.Date(&quot;2000-01-01&quot;) tmax &lt;- as.Date(&quot;2001-01-01&quot;) tlab &lt;- seq(tmin, tmax, by = &quot;month&quot;) lab &lt;- format(tlab, format = &quot;%Y-%b&quot;) set.seed(111) x &lt;- seq(tmin, tmax, length.out = 100) y &lt;- cumsum(rnorm(100)) # Plot # png(&quot;plot_w_rotated_axis_labels.png&quot;, height = 3, # width = 6, units = &quot;in&quot;, res = 300) op &lt;- par(mar = c(6, 4, 1, 1)) plot(x, y, t = &quot;l&quot;, xaxt = &quot;n&quot;, xlab = &quot;&quot;) axis(1, at = tlab, labels = FALSE) text( x = tlab, y = par()$usr[3] - 0.1 * (par()$usr[4] - par()$usr[3]), labels = lab, srt = 45, adj = 1, xpd = TRUE ) par(op) # dev.off() 旋转坐标抽标签的例子来自手册《R FAQ》的第7章第27个问题 (Hornik 2018)，在基础图形中，旋转坐标轴标签需要 text() 而不是 mtext()，因为后者不支持par(\"srt\") ## Increase bottom margin to make room for rotated labels par(mar = c(5, 4, .5, 2) + 0.1) ## Create plot with no x axis and no x axis label plot(1:8, xaxt = &quot;n&quot;, xlab = &quot;&quot;) ## Set up x axis with tick marks alone axis(1, labels = FALSE) ## Create some text labels labels &lt;- paste(&quot;Label&quot;, 1:8, sep = &quot; &quot;) ## Plot x axis labels at default tick marks text(1:8, par(&quot;usr&quot;)[3] - 0.5, srt = 45, adj = 1, labels = labels, xpd = TRUE ) ## Plot x axis label at line 6 (of 7) mtext(side = 1, text = &quot;X Axis Label&quot;, line = 4) 图 7.13: 旋转坐标轴标签 srt = 45 表示文本旋转角度， xpd = TRUE 允许文本越出绘图区域，adj = 1 to place the right end of text at the tick marks；You can adjust the value of the 0.5 offset as required to move the axis labels up or down relative to the x axis. 详细地参考 (Murrell 2003) 7.1.5 刻度线 通过 par 或 axis 函数实现刻度线的精细操作，tcl 控制刻度线的长度，正值让刻度画在绘图区域内，负值正好相反，画在外面，mgp 参数有三个值，第一个值控制绘图区域和坐标轴标题之间的行数，第二个是绘图区域与坐标轴标签的行数，第三个绘图区域与轴线的行数，行数表示间距 par(tcl = 0.4, mgp = c(1.5, 0, 0)) plot(x, y) # 又一个例子 par(op) plot(x, y, xaxt = &quot;n&quot;, yaxt = &quot;n&quot;, xlab = &quot;&quot;, ylab = &quot;&quot;) axis(side = 1, at = seq(5, 95, 30), tcl = 0.4, lwd.ticks = 3, mgp = c(0, 0.5, 0)) mtext(side = 1, text = &quot;X axis&quot;, line = 1.5) # mtext 设置坐标轴标签 axis(side = 2, at = seq(-2, 2, 2), tcl = 0.3, lwd.ticks = 3, col.ticks = &quot;orange&quot;, mgp = c(0, 0, 2)) mtext(side = 2, text = &quot;Numbers taken randomly&quot;, line = 2.2) 7.1.6 标题 添加多个标题 N &lt;- 200 x &lt;- runif(N, -4, 4) y &lt;- sin(x) + .5 * rnorm(N) plot(x, y, xlab = &quot;&quot;, ylab = &quot;&quot;, main = &quot;&quot;) mtext(&quot;Subtitle&quot;, 3, line = .8) mtext(&quot;Title&quot;, 3, line = 2, cex = 1.5) mtext(&quot;X axis&quot;, 1, line = 2.5, cex = 1.5) mtext(&quot;X axis subtitle&quot;, 1, line = 3.7) 图 7.14: 图标题/子标题 x轴标题/子标题 7.1.7 注释 数学符号注释，图7.15 自定义坐标轴 (Murrell and Ihaka 2000)。 # 自定义坐标轴 plot(c(1, 1e6), c(-pi, pi), type = &quot;n&quot;, axes = FALSE, ann = FALSE, log = &quot;x&quot; ) axis(1, at = c(1, 1e2, 1e4, 1e6), labels = expression(1, 10^2, 10^4, 10^6) ) axis(2, at = c(-pi, -pi / 2, 0, pi / 2, pi), labels = expression(-pi, -pi / 2, 0, pi / 2, pi) ) text(1e3, 0, expression(italic(&quot;Customized Axes&quot;))) box() 图 7.15: 创建自定义的坐标轴和刻度标签 在标题中添加数学公式 x &lt;- seq(-5, 5, length = 200) y &lt;- sqrt(1 + x^2) plot(y ~ x, type = &quot;l&quot;, ylab = expression(sqrt(1 + x^2)) ) title(main = expression( &quot;graph of the function f&quot;(x) == sqrt(1 + x^2) )) 图 7.16: 标题含有数学公式 修改参数使用 substitute 函数批量生成 x &lt;- seq(-5, 5, length = 200) for (i in 1:4) { # 画四个图 y &lt;- sqrt(i + x^2) plot(y ~ x, type = &quot;l&quot;, ylim = c(0, 6), ylab = substitute( expression(sqrt(i + x^2)), list(i = i) ) ) title(main = substitute( &quot;graph of the function f&quot;(x) == sqrt(i + x^2), list(i = i) )) } 图 7.17: 批量生成函数图形 基础绘图函数，如 plot 标签 xlab 支持 Unicode 代码表示的希腊字母，常用字母表备查，公式环境下，也可以用在绘图中 表 7.1: 希腊字母表 希腊字母 LaTeX 代码 Unicode 代码 希腊字母 LaTeX 代码 Unicode 代码 \\(\\alpha\\) \\alpha \\u03B1 \\(\\mu\\) \\mu \\u03BC \\(\\beta\\) \\beta \\u03B2 \\(\\nu\\) \\nu \\u03BD \\(\\gamma\\) \\gamma \\u03B3 \\(\\xi\\) \\xi \\u03BE \\(\\delta\\) \\delta \\u03B4 \\(\\varphi\\) \\varphi \\u03C6 \\(\\epsilon\\) \\epsilon \\u03B5 \\(\\pi\\) \\pi \\u03C0 \\(\\zeta\\) \\zeta \\u03B6 \\(\\rho\\) \\rho \\u03C1 \\(\\eta\\) \\eta \\u03B7 \\(\\upsilon\\) \\upsilon \\u03C5 \\(\\theta\\) \\theta \\u03B8 \\(\\phi\\) \\phi \\u03C6 \\(\\iota\\) \\iota \\u03B9 \\(\\chi\\) \\chi \\u03C7 \\(\\kappa\\) \\kappa \\u03BA \\(\\psi\\) \\psi \\u03C8 \\(\\lambda\\) \\lambda \\u03BB \\(\\omega\\) \\omega \\u03C9 \\(\\sigma\\) \\sigma \\u03C3 \\(\\tau\\) \\tau \\u03C4 表 7.2: 数字上下标 上标数字 LaTeX 代码 Unicode 代码 下标数字 LaTeX 代码 Unicode 代码 \\({}^0\\) {}^0 \\u2070 \\({}_0\\) {}_0 \\u2080 \\({}^1\\) {}^1 \\u00B9 \\({}_1\\) {}_1 \\u2081 \\({}^2\\) {}^2 \\u00B2 \\({}_2\\) {}_2 \\u2082 \\({}^3\\) {}^3 \\u00B2 \\({}_3\\) {}_3 \\u2083 \\({}^4\\) {}^4 \\u2074 \\({}_4\\) {}_4 \\u2084 \\({}^5\\) {}^5 \\u2075 \\({}_5\\) {}_5 \\u2085 \\({}^6\\) {}^6 \\u2076 \\({}_6\\) {}_6 \\u2086 \\({}^7\\) {}^7 \\u2077 \\({}_7\\) {}_7 \\u2087 \\({}^8\\) {}^8 \\u2078 \\({}_8\\) {}_8 \\u2088 \\({}^9\\) {}^9 \\u2079 \\({}_9\\) {}_9 \\u2089 \\({}^n\\) {}^n \\u207F \\({}_n\\) {}_n - 其它字母，请查看 Unicode 字母表 7.1.8 图例 x &lt;- seq(-6, 6, length = 200) y &lt;- sin(x) z &lt;- cos(x) plot(y ~ x, type = &quot;l&quot;, lwd = 3, ylab = &quot;&quot;, xlab = &quot;angle&quot;, main = &quot;Trigonometric functions&quot; ) abline(h = 0, lty = 3) abline(v = 0, lty = 3) lines(z ~ x, type = &quot;l&quot;, lwd = 3, col = &quot;red&quot;) legend(-6, -1, yjust = 0, c(&quot;Sine&quot;, &quot;Cosine&quot;), lwd = 3, lty = 1, col = c(par(&quot;fg&quot;), &quot;red&quot;) ) 图 7.18: 三角函数添加图例 xmin &lt;- par(&quot;usr&quot;)[1] xmax &lt;- par(&quot;usr&quot;)[2] ymin &lt;- par(&quot;usr&quot;)[3] ymax &lt;- par(&quot;usr&quot;)[4] plot(y ~ x, type = &quot;l&quot;, lwd = 3, ylab = &quot;&quot;, xlab = &quot;angle&quot;, main = &quot;Trigonometric functions&quot; ) abline(h = 0, lty = 3) abline(v = 0, lty = 3) lines(z ~ x, type = &quot;l&quot;, lwd = 3, col = &quot;red&quot;) legend(&quot;bottomleft&quot;, c(&quot;Sine&quot;, &quot;Cosine&quot;), lwd = 3, lty = 1, col = c(par(&quot;fg&quot;), &quot;red&quot;) ) 图 7.19: 设置图例的位置 plot(y ~ x, type = &quot;l&quot;, lwd = 3, ylab = &quot;&quot;, xlab = &quot;angle&quot;, main = &quot;Trigonometric functions&quot; ) abline(h = 0, lty = 3) abline(v = 0, lty = 3) lines(z ~ x, type = &quot;l&quot;, lwd = 3, col = &quot;red&quot;) legend(&quot;bottomleft&quot;, c(&quot;Sine&quot;, &quot;Cosine&quot;), inset = c(.03, .03), lwd = 3, lty = 1, col = c(par(&quot;fg&quot;), &quot;red&quot;) ) 图 7.20: insert 函数微调图例位置 op &lt;- par(no.readonly = TRUE) plot(y ~ x, type = &quot;l&quot;, lwd = 3, ylab = &quot;&quot;, xlab = &quot;angle&quot;, main = &quot;Trigonometric functions&quot; ) abline(h = 0, lty = 3) abline(v = 0, lty = 3) lines(z ~ x, type = &quot;l&quot;, lwd = 3, col = &quot;red&quot;) par(xpd = TRUE) # Do not clip to the drawing area 关键一行/允许出界 lambda &lt;- .025 legend(par(&quot;usr&quot;)[1], (1 + lambda) * par(&quot;usr&quot;)[4] - lambda * par(&quot;usr&quot;)[3], c(&quot;Sine&quot;, &quot;Cosine&quot;), xjust = 0, yjust = 0, lwd = 3, lty = 1, col = c(par(&quot;fg&quot;), &quot;red&quot;) ) par(op) 图 7.21: 将图例放在绘图区域外面 Hmisc 包的 labcurve 函数可以在曲线上放置名称，而不是遥远的图例上 7.1.9 边空 line 第一行 N &lt;- 200 x &lt;- runif(N, -4, 4) y &lt;- sin(x) + .5 * rnorm(N) plot(x, y, xlab = &quot;&quot;, ylab = &quot;&quot;, main = paste( &quot;The \\&quot;mtext\\&quot; function&quot;, paste(rep(&quot; &quot;, 60), collapse = &quot;&quot;) ) ) for (i in seq(from = 0, to = 1, by = 1)) { mtext(paste(&quot;Line&quot;, i), 3, line = i) } 图 7.22: 外边空在图的边缘添加文字 par # 多图排列/分屏 page 47 # 最常用的是 par mfrow mfcol分别按行/列放置图形 op &lt;- par( mfrow = c(2, 2), oma = c(0, 0, 4, 0) # Outer margins ) for (i in 1:4) { plot(runif(20), runif(20), main = paste(&quot;random plot (&quot;, i, &quot;)&quot;, sep = &quot;&quot;) ) } par(op) mtext(&quot;Four plots, without enough room for this title&quot;, side = 3, font = 2, cex = 1.5, col = &quot;red&quot; ) # 总/大标题放不下 图 7.23: 多图排列共享一个大标题 par 的 oma 用来设置外边空的大小，默认情形下没有外边空的 par()$oma #&gt; [1] 0 0 0 0 我们可以自己设置外边空 op &lt;- par( mfrow = c(2, 2), oma = c(0, 0, 3, 0) # Outer margins ) for (i in 1:4) { plot(runif(20), runif(20), main = paste(&quot;random plot (&quot;, i, &quot;)&quot;, sep = &quot;&quot;) ) } par(op) mtext(&quot;Four plots, with some room for this title&quot;, side = 3, line = 1.5, font = 1, cex = 1.5, col = &quot;red&quot; ) 图 7.24: 设置外边空放置大标题 除了内边空还有外边空，内外边空用来放注释说明 op &lt;- par(no.readonly = TRUE) par(oma = c(2, 2, 2, 2)) plot(1, 1, type = &quot;n&quot;, xlab = &quot;&quot;, ylab = &quot;&quot;, xaxt = &quot;n&quot;, yaxt = &quot;n&quot;) for (side in 1:4) { inner &lt;- round(par()$mar[side], 0) - 1 for (line in 0:inner) { mtext(text = paste0(&quot;Inner line &quot;, line), side = side, line = line) } outer &lt;- round(par()$oma[side], 0) - 1 for (line in 0:inner) { mtext(text = paste0(&quot;Outer line &quot;, line), side = side, line = line, outer = TRUE) } } 外边空可以用来放图例 set.seed(1234) x &lt;- runif(10) y &lt;- runif(10) cols &lt;- rep(hcl.colors(5), each = 2) op &lt;- par(oma = c(2, 2, 0, 4), mar = c(3, 3, 2, 0), mfrow = c(2, 2), pch = 16) for (i in 1:4) { plot(x, y, col = cols, ylab = &quot;&quot;, xlab = &quot;&quot;) } mtext(text = &quot;A common x-axis label&quot;, side = 1, line = 0, outer = TRUE) mtext(text = &quot;A common y-axis label&quot;, side = 2, line = 0, outer = TRUE) legend( x = 1, y = 1.2, legend = LETTERS[1:5], col = unique(cols), pch = 16, bty = &quot;n&quot;, xpd = NA ) par(op) 坐标轴标签 xlab 和 ylab 的内容很长的时候需要内边空 par(cex.lab = 1.7) plot(1, 1, ylab = &quot;A very very long axis title\\nthat need special care&quot;, xlab = &quot;&quot;, type = &quot;n&quot; ) # 增加内边空的大小 par(mar = c(5, 7, 4, 2)) plot(1, 1, ylab = &quot;A very very long axis title\\nthat need special care&quot;, xlab = &quot;&quot;, type = &quot;n&quot; ) 有时候，仅仅增加内边空还不够，坐标轴标签内容甚至可以出现在绘图区域外面，设置 outer = TRUE par(oma = c(0, 4, 0, 0)) plot(1, 1, ylab = &quot;&quot;, xlab = &quot;&quot;, type = &quot;n&quot;) mtext( text = &quot;A very very long axis title\\nthat need special care&quot;, side = 2, line = 0, outer = TRUE, cex = 1.7 ) op &lt;- par( mfrow = c(2, 2), oma = c(0, 0, 3, 0), mar = c(3, 3, 4, 1) + .1 # Margins ) for (i in 1:4) { plot(runif(20), runif(20), xlab = &quot;&quot;, ylab = &quot;&quot;, main = paste(&quot;random plot (&quot;, i, &quot;)&quot;, sep = &quot;&quot;) ) } par(op) mtext(&quot;Title&quot;, side = 3, line = 1.5, font = 2, cex = 2, col = &quot;red&quot; ) 图 7.25: 设置每个子图的边空 mar 7.1.10 图层 覆盖图形 add = T or par(new=TRUE) plot(runif(5), runif(5), xlim = c(0, 1), ylim = c(0, 1) ) points(runif(5), runif(5), col = &quot;#EA4335&quot;, pch = 16, cex = 3 ) lines(runif(5), runif(5), col = &quot;red&quot;) segments(runif(5), runif(5), runif(5), runif(5), col = &quot;blue&quot; ) title(main = &quot;Overlaying points, segments, lines...&quot;) 图 7.26: 添加图层 7.1.11 布局 layout 函数布局， 绘制复杂组合图形 op &lt;- par(oma = c(0, 0, 3, 0)) layout(matrix(c( 1, 1, 1, 2, 3, 4, 2, 3, 4 ), nr = 3, byrow = TRUE)) hist(rnorm(n), col = &quot;light blue&quot;) hist(rnorm(n), col = &quot;light blue&quot;) hist(rnorm(n), col = &quot;light blue&quot;) hist(rnorm(n), col = &quot;light blue&quot;) mtext(&quot;The \\&quot;layout\\&quot; function&quot;, side = 3, outer = TRUE, font = 2, cex = 1.2 ) 图 7.27: 更加复杂的组合图形 7.1.12 组合 par 之 fig 参数很神奇，使得多个图可以叠加在一起，它接受一个数值向量c(x1, x2, y1, y2) ，是图形设备显示区域中的绘图区域的(NDC, normalized device coordinates)坐标。 plot(1:12, type = &quot;b&quot;, main = &quot;&#39;fg&#39; : axes, ticks and box in gray&quot;, fg = gray(0.7), bty = &quot;7&quot;, sub = R.version.string ) par(fig = c(1, 6, 5, 10) / 10, new = T) plot(6:10, type = &quot;b&quot;, main = &quot;&quot;, fg = gray(0.7), bty = &quot;7&quot;, xlab = R.version.string ) 图 7.28: 多图叠加 fig 参数控制图形的位置，用来绘制组合图形 n &lt;- 1000 x &lt;- rt(n, df = 10) hist(x, col = &quot;light blue&quot;, probability = &quot;TRUE&quot;, main = &quot;&quot;, ylim = c(0, 1.2 * max(density(x)$y)) ) lines(density(x), col = &quot;red&quot;, lwd = 3 ) op &lt;- par( fig = c(.02, .4, .5, .98), new = TRUE ) qqnorm(x, xlab = &quot;&quot;, ylab = &quot;&quot;, main = &quot;&quot;, axes = FALSE ) qqline(x, col = &quot;red&quot;, lwd = 2) box(lwd = 2) par(op) 图 7.29: 组合图形 7.1.13 分屏 split.screen 分屏组合 random.plot &lt;- function() { N &lt;- 200 f &lt;- sample( list( rnorm, function(x) { rt(x, df = 2) }, rlnorm, runif ), 1 ) [[1]] x &lt;- f(N) hist(x, col = &quot;lightblue&quot;, main = &quot;&quot;, xlab = &quot;&quot;, ylab = &quot;&quot;, axes = F) axis(1) } op &lt;- par(bg = &quot;white&quot;, mar = c(2.5, 2, 1, 2)) split.screen(c(2, 1)) #&gt; [1] 1 2 split.screen(c(1, 3), screen = 2) #&gt; [1] 3 4 5 screen(1) random.plot() # screen(2); random.plot() # Screen 2 was split into three screens: 3, 4, 5 screen(3) random.plot() screen(4) random.plot() screen(5) random.plot() close.screen(all = TRUE) par(op) 图 7.30: 分屏 7.1.14 交互 辅助绘图 identify locator 7.2 统计图形 按图的类型划分，最后在小结部分给出各图适用的数据类型 根据数据类型划分： 对于一元数据，可用什么图来描述；多元数据呢，连续数据和离散数据（分类数据） 先找一个不重不漏的划分，指导原则是根据数据类型选择图，根据探索到的数据中的规律，选择图 其它 assocplot fourfoldplot sunflowerplot 7.2.1 条形图 条形图 简单条形图 data(diamonds, package = &quot;ggplot2&quot;) # 加载数据 par(mar = c(2, 5, 1, 1)) barCenters &lt;- barplot(table(diamonds$cut), col = &quot;lightblue&quot;, axes = FALSE, axisnames = FALSE, horiz = TRUE, border = &quot;white&quot; ) text( y = barCenters, x = par(&quot;usr&quot;)[3], adj = 1, labels = names(table(diamonds$cut)), xpd = TRUE ) axis(1, labels = seq(0, 25000, by = 5000), at = seq(0, 25000, by = 5000), las = 1, col = &quot;gray&quot; ) grid() 图 7.31: 条形图 简单柱形图 set.seed(123456) barPois &lt;- table(stats::rpois(1000, lambda = 5)) plot(barPois, col = &quot;lightblue&quot;, type = &quot;h&quot;, lwd = 10, main = &quot;&quot;) box(col = &quot;gray&quot;) 图 7.32: 柱形图 复合条形图 par(mar = c(4.1, 2.1, 0.5, 4.5)) barplot(VADeaths, border = &quot;white&quot;, horiz = FALSE, col = hcl.colors(5), legend.text = rownames(VADeaths), xpd = TRUE, beside = TRUE, cex.names = 0.9, args.legend = list( x = &quot;right&quot;, border = &quot;white&quot;, title = &quot;Age&quot;, box.col = NA, horiz = FALSE, inset = c(-.2, 0), xpd = TRUE ), panel.first = grid(nx = 0, ny = 7) ) 图 7.33: 复合条形图 堆积条形图 par(mar = c(4.1, 2.1, 0.5, 4.5)) barplot(VADeaths, border = &quot;white&quot;, horiz = FALSE, col = hcl.colors(5), legend.text = rownames(VADeaths), xpd = TRUE, beside = FALSE, cex.names = 0.9, args.legend = list( x = &quot;right&quot;, border = &quot;white&quot;, title = &quot;Age&quot;, box.col = NA, horiz = FALSE, inset = c(-.2, 0), xpd = TRUE ), panel.first = grid(nx = 0, ny = 4) ) 图 7.34: 堆积条形图 堆积条形图 spineplot 简单条形图 barplot( data = BOD, demand ~ Time, ylim = c(0, 20), border = &quot;white&quot;, horiz = FALSE, col = hcl.colors(1) ) pg_mean &lt;- aggregate(weight ~ group, data = PlantGrowth, mean) barplot( data = pg_mean, weight ~ group, border = &quot;white&quot;, horiz = FALSE, col = hcl.colors(3) ) Titanic 数据集是 table 数据类型 简单条形图 复合条形图 barplot(Freq ~ Class + Survived, data = Titanic, subset = Age == &quot;Adult&quot; &amp; Sex == &quot;Male&quot;, beside = TRUE, border = &quot;white&quot;, horiz = FALSE, col = hcl.colors(4), args.legend = list( border = &quot;white&quot;, title = &quot;Class&quot;, box.col = NA, horiz = FALSE, xpd = TRUE ), ylab = &quot;# {passengers}&quot;, legend = TRUE ) 堆积条形图 barplot(Freq ~ Class + Survived, data = Titanic, subset = Age == &quot;Adult&quot; &amp; Sex == &quot;Male&quot;, border = &quot;white&quot;, horiz = FALSE, col = hcl.colors(4), args.legend = list( border = &quot;white&quot;, title = &quot;Class&quot;, box.col = NA, horiz = FALSE, xpd = TRUE ), ylab = &quot;# {passengers}&quot;, legend = TRUE ) 7.2.2 直方图 set.seed(1234) n &lt;- 2^24 x &lt;- runif(n, 0, 1) delta &lt;- 0.01 len &lt;- diff(c(0, which(x &lt; delta), n + 1)) - 1 ylim &lt;- seq(0, 1800, by = 300) xlim &lt;- seq(0, 100, by = 20) p &lt;- hist(len[len &lt; 101], breaks = -1:100 + 0.5, plot = FALSE) plot(p, ann = FALSE, axes = FALSE, col = &quot;lightblue&quot;, border = &quot;white&quot;, main = &quot;&quot;) axis(1, labels = xlim, at = xlim, las = 1) # x 轴 axis(2, labels = ylim, at = ylim, las = 0) # y 轴 box(col = &quot;gray&quot;) 图 7.35: 直方图 with(faithful, plot(eruptions ~ waiting, pch = 16)) with(faithful, hist(waiting, main = &quot;Time between Old Faithful eruptions&quot;, xlab = &quot;Minutes&quot;, ylab = &quot;&quot;, cex.main = 1.5, cex.lab = 1.5, cex.axis = 1.4 )) with(data = faithful, { hist(eruptions, seq(1.6, 5.2, 0.2), prob = TRUE, main = &quot;&quot;, col = &quot;lightblue&quot;, border = &quot;white&quot; ) lines(density(eruptions, bw = 0.1), col = &quot;#EA4335&quot;) rug(eruptions, col = &quot;#EA4335&quot;) # 添加数据点 }) 图 7.36: 老忠实泉间歇性喷水的时间间隔分布 hist(longley$Unemployed, probability = TRUE, col = &quot;light blue&quot;, main = &quot;&quot; ) # 添加密度估计 lines(density(longley$Unemployed), col = &quot;red&quot;, lwd = 3 ) 图 7.37: 概率密度分布 直方图有很多花样的，添加阴影线，angle 控制倾斜的角度 # hist(longley$Unemployed, density = 1, angle = 45) # hist(longley$Unemployed, density = 3, angle = 15) # hist(longley$Unemployed, density = 1, angle = 15) hist(longley$Unemployed, density = 3, angle = 45, main = &quot;&quot;) 图 7.38: density 数值越大阴影线越密 7.2.3 密度图 data(galaxies, package = &quot;MASS&quot;) galaxies &lt;- galaxies / 1000 # Bandwidth Selection by Pilot Estimation of Derivatives c(MASS::width.SJ(galaxies, method = &quot;dpi&quot;), MASS::width.SJ(galaxies)) #&gt; [1] 3.256151 2.566423 plot( x = c(5, 40), y = c(0, 0.2), type = &quot;n&quot;, bty = &quot;l&quot;, xlab = &quot;velocity of galaxy (km/s)&quot;, ylab = &quot;density&quot; ) rug(galaxies) lines(density(galaxies, width = 3.25, n = 200), col = &quot;blue&quot;, lty = 1) lines(density(galaxies, width = 2.56, n = 200), col = &quot;red&quot;, lty = 3) x &lt;- seq(from = 110, to = 174, by = 0.5) y1 &lt;- dnorm(x, mean = 145, sd = 9) y2 &lt;- dnorm(x, mean = 138, sd = 8) plot(x, y1, type = &quot;l&quot;, lwd = 2, col = &quot;red&quot;, main = &quot;Systolic Blood Pressure Before and After Treatment&quot;, xlab = &quot;Systolic Blood Pressure (mmHg)&quot;, ylab = &quot;Frequency&quot;, yaxt = &quot;n&quot;, xlim = c(110, 175), ylim = c(0, 0.05) ) lines(x, y2) polygon(c(110, x, 175), c(0, y2, 0), col = &quot;firebrick3&quot;, border = &quot;white&quot; ) polygon(c(117, x, 175), c(0, y1, 0), col = &quot;dodgerblue4&quot;, border = &quot;white&quot; ) ylab &lt;- c(seq(from = 0, to = 175, by = 25)) y &lt;- c(seq(from = 0, to = 0.05, length.out = 8)) axis(2, at = y, labels = ylab, las = 1) text(x = 120, y = 0.045, &quot;- Pre-Treatment BP&quot;, col = &quot;dodgerblue4&quot;, cex = 0.9) text(x = 120, y = 0.04, &quot; - Post-Treatment BP&quot;, col = &quot;firebrick3&quot;, cex = 0.9) points(109, 0.0445, pch = 15, col = &quot;dodgerblue4&quot;) points(109, 0.0395, pch = 15, col = &quot;firebrick3&quot;) days &lt;- abs(rnorm(1000, 80, 125)) plot(density(days, from = 0), main = &quot;Density plot&quot;, xlab = &quot;Number of days since trial started&quot; ) plot(density(days, from = 0, to = 180, adjust = 0.2), main = &quot;Density plot - Up to 180 days (86% of data)&quot;, xlab = &quot;Number of days since trial started&quot; ) library(survival) surv.days &lt;- Surv(days) surv.fit &lt;- survfit(surv.days ~ 1) plot(surv.fit, main = &quot;Kaplan-Meier estimate with 95% confidence bounds (86% of data)&quot;, xlab = &quot;Days since trial started&quot;, xlim = c(0, 180), ylab = &quot;Survival function&quot; ) grid(20, 10, lwd = 2) 7.2.4 经验图 with(data = faithful, { long &lt;- eruptions[eruptions &gt; 3] plot(ecdf(long), do.points = FALSE, verticals = TRUE, main = &quot;&quot;) x &lt;- seq(3, 5.4, 0.01) lines(x, pnorm(x, mean = mean(long), sd = sqrt(var(long))), lty = 3) }) 图 7.39: 累积经验分布图 7.2.5 QQ 图 with(data = faithful, { long &lt;- eruptions[eruptions &gt; 3] par(pty = &quot;s&quot;) # arrange for a square figure region qqnorm(long, main = &quot;&quot;) qqline(long) }) 7.2.6 时序图 时序图最适合用来描述股价走势 matplot(time(EuStockMarkets), EuStockMarkets, main = &quot;&quot;, xlab = &quot;Date&quot;, ylab = &quot;closing prices&quot;, pch = 17, type = &quot;l&quot;, col = 1:4 ) legend(&quot;topleft&quot;, colnames(EuStockMarkets), pch = 17, lty = 1, col = 1:4) 图 7.40: 1991–1998年间主要欧洲股票市场日闭市价格指数图 德国 DAX (Ibis), Switzerland SMI, 法国 CAC 和 英国 FTSE 7.2.7 饼图 clockwise 参数 pie.sales &lt;- c(0.12, 0.3, 0.26, 0.16, 0.04, 0.12) names(pie.sales) &lt;- c( &quot;Blueberry&quot;, &quot;Cherry&quot;, &quot;Apple&quot;, &quot;Boston Cream&quot;, &quot;Other&quot;, &quot;Vanilla Cream&quot; ) pie(pie.sales, clockwise = TRUE, main = &quot;&quot;) segments(0, 0, 0, 1, col = &quot;red&quot;, lwd = 2) text(0, 1, &quot;init.angle = 90&quot;, col = &quot;red&quot;) 7.2.8 茎叶图 stem(longley$Unemployed) #&gt; #&gt; The decimal point is 2 digit(s) to the right of the | #&gt; #&gt; 1 | 99 #&gt; 2 | 134899 #&gt; 3 | 46789 #&gt; 4 | 078 7.2.9 散点图 在一维空间上，绘制散点图，其实是在看散点的疏密程度随坐标轴的变化 stripchart(longley$Unemployed, method = &quot;jitter&quot;, jitter = 0.1, pch = 16, col = &quot;lightblue&quot;) stripchart(longley$Unemployed, method = &quot;overplot&quot;, pch = 16, col = &quot;lightblue&quot;) 图 7.41: 一维散点图 气泡图是二维散点图的一种变体，气泡的大小可以用来描述第三个变量，下面以数据集 topo 为例展示气泡图 # 加载数据集 data(topo, package = &quot;MASS&quot;) # 查看数据集 str(topo) #&gt; &#39;data.frame&#39;: 52 obs. of 3 variables: #&gt; $ x: num 0.3 1.4 2.4 3.6 5.7 1.6 2.9 3.4 3.4 4.8 ... #&gt; $ y: num 6.1 6.2 6.1 6.2 6.2 5.2 5.1 5.3 5.7 5.6 ... #&gt; $ z: int 870 793 755 690 800 800 730 728 710 780 ... topo 是空间地形数据集，包含有52行3列，数据点是310平方英尺范围内的海拔高度数据，x 坐标每单位50英尺，y 坐标单位同 x 坐标，海拔高度 z 单位是英尺 plot(y ~ x, cex = (960 - z) / (960 - 690) * 3, data = topo, xlab = &quot;X Coordinates&quot;, ylab = &quot;Y coordinates&quot; ) 图 7.42: 地形图之海拔高度 散点图也适合分类数据的展示，在图中用不同颜色或符号标记数据点所属类别，即在普通散点图的基础上添加一分类变量的描述 plot(mpg ~ hp, data = subset(mtcars, am == 1), pch = 16, col = &quot;blue&quot;, xlim = c(50, 350), ylim = c(10, 35) ) points(mpg ~ hp, col = &quot;red&quot;, pch = 16, data = subset(mtcars, am == 0) ) legend(300, 35, c(&quot;1&quot;, &quot;0&quot;), title = &quot;am&quot;, col = c(&quot;blue&quot;, &quot;red&quot;), pch = c(16, 16) ) 图 7.43: 分类散点图 iris 数据 plot(Sepal.Length ~ Sepal.Width, data = iris, col = Species, pch = 16) legend(&quot;topright&quot;, legend = unique(iris$Species), box.col = &quot;gray&quot;, pch = 16, col = unique(iris$Species) ) box(col = &quot;gray&quot;) 图 7.44: 分类散点图 分组散点图和平滑 library(carData) library(car) scatterplot(Sepal.Length ~ Sepal.Width, col = c(&quot;black&quot;, &quot;red&quot;, &quot;blue&quot;), pch = c(16, 16, 16), smooth = TRUE, boxplots = &quot;xy&quot;, groups = iris$Species, xlab = &quot;Sepal.Width&quot;, ylab = &quot;Sepal.Length&quot;, data = iris ) 有时为了实现特定的目的，需要高亮其中某些点，按类别或者因子变量分组绘制散点图，这里继续采用 stripchart 函数绘制二维散点图7.45， 由左图可知，函数 stripchart 提供的参数 pch 不接受向量，实际只是取了前三个值 16 16 17 对应于 Species 的三类，关键是高亮的分界点是有区分意义的 data(&quot;iris&quot;) pch &lt;- rep(16, length(iris$Petal.Length)) pch[which(iris$Petal.Length &lt; 1.4)] &lt;- 17 stripchart(Petal.Length ~ Species, data = iris, vertical = TRUE, method = &quot;jitter&quot;, pch = pch ) # 对比一下 stripchart(Petal.Length ~ Species, data = iris, subset = Petal.Length &gt; 1.4, vertical = TRUE, method = &quot;jitter&quot;, ylim = c(1, 7), pch = 16 ) stripchart(Petal.Length ~ Species, data = iris, subset = Petal.Length &lt; 1.4, vertical = TRUE, method = &quot;jitter&quot;, add = TRUE, pch = 17, col = &quot;red&quot; ) 图 7.45: 高亮图中部分散点 如果存在大量散点 densCols(x, y = NULL, nbin = 128, bandwidth, colramp = colorRampPalette(blues9[-(1:3)]) ) densCols 函数根据点的局部密度生成颜色，密度估计采用核平滑法，由 KernSmooth 包的 bkde2D 函数实现。参数 colramp 传递一个函数，colorRampPalette 根据给定的几种颜色生成函数，参数 bandwidth 实际上是传给 bkde2D 函数 x1 &lt;- matrix(rnorm(1e3), ncol = 2) x2 &lt;- matrix(rnorm(1e3, mean = 3, sd = 1.5), ncol = 2) x &lt;- rbind(x1, x2) dcols &lt;- densCols(x) graphics::plot(x, col = dcols, pch = 20, panel.first = grid()) # title(main = &quot;n = 1000&quot;, xpd = TRUE) 图 7.46: 根据点的密度生成颜色 气泡图也是散点图的一种 plot(Volume ~ Height, data = trees, pch = 16, cex = Girth / 8, col = rev(terrain.colors(nrow(trees), alpha = .5)) ) box(col = &quot;gray&quot;) 图 7.47: 气泡图 气泡图 # 空白画布 plot(c(1, 5, 10), c(1, 5, 10), panel.first = grid(10, 10), type = &quot;n&quot;, axes = FALSE, ann = FALSE) # 添加坐标轴 axis(1, at = seq(10), labels = TRUE) axis(2, at = seq(10), labels = TRUE) par(new = TRUE) # 在当前图形上添加图形 # axes 坐标轴上的刻度 &quot;xaxt&quot; or &quot;yaxt&quot; ann 坐标轴和标题的标签 set.seed(1234) plot(rnorm(100, 5, 1), rnorm(100, 5, 1), cex = runif(100, 0, 2), col = hcl.colors(4)[rep(seq(4), 100)], bg = paste0(&quot;gray&quot;, replicate(100, sample(seq(100), 1, replace = TRUE))), axes = FALSE, ann = FALSE, pch = 21, lwd = 2 ) legend(&quot;top&quot;, legend = paste0(&quot;class&quot;, seq(4)), col = hcl.colors(4), pt.lwd = 2, pch = 21, box.col = &quot;gray&quot;, horiz = TRUE ) 除了par(new=TRUE)设置外，有些函数本身就具有 add 选项 set.seed(1234) plot(dist ~ speed, data = cars, pch = 17, col = &quot;red&quot;, cex = 1) with(cars, symbols(dist ~ speed, circles = runif(length(speed), 0, 1), pch = 16, inches = .5, add = TRUE )) z &lt;- lm(dist ~ speed, data = cars) abline(z, col = &quot;blue&quot;) curve(tan, from = 0, to = 8 * pi, n = 100, add = TRUE) lines(stats::lowess(cars)) points(10, 100, pch = 16, cex = 3, col = &quot;green&quot;) text(10, 80, &quot;text here&quot;, cex = 3) 7.2.10 抖动图 抖动散点图 mat &lt;- matrix(1:length(colors()), ncol = 9, byrow = TRUE) df &lt;- data.frame( col = colors(), x = as.integer(cut(1:length(colors()), 9)), y = rep(1:73, 9), stringsAsFactors = FALSE ) par(mar = c(4, 4, 1, 0.1)) plot(y ~ jitter(x), data = df, col = df$col, pch = 16, main = &quot;Visualizing colors() split in 9 groups&quot;, xlab = &quot;Group&quot;, ylab = &quot;Element of the group (min = 1, max = 73)&quot;, sub = &quot;x = 3, y = 1 means that it&#39;s the 2 * 73 + 1 = 147th color&quot; ) 图 7.48: 抖动散点图 7.2.11 箱线图 boxplotdbl: Double Box Plot for Two-Axes Correlation. Correlation chart of two set (x and y) of data. Using Quartiles with boxplot style. Visualize the effect of factor. 复合箱线图 A &lt;- c( 79.98, 80.04, 80.02, 80.04, 80.03, 80.03, 80.04, 79.97, 80.05, 80.03, 80.02, 80, 80.02 ) B &lt;- c(80.02, 79.94, 79.98, 79.97, 79.97, 80.03, 79.95, 79.97) boxplot(A, B) with(data = iris, { op &lt;- par(mfrow = c(2, 2), mar = c(4, 4, 2, .5)) plot(Sepal.Length ~ Species) plot(Sepal.Width ~ Species) plot(Petal.Length ~ Species) plot(Petal.Width ~ Species) par(op) mtext(&quot;Edgar Anderson&#39;s Iris Data&quot;, side = 3, line = 4) }) 图 7.49: 安德森的鸢尾花数据 箱线图的花样也很多 boxplot(longley$Unemployed) # 水平放置 boxplot(longley$Unemployed, horizontal = TRUE, col = &quot;pink&quot;, main = &quot;&quot; ) data(InsectSprays) boxplot(count ~ spray, data = InsectSprays, col = &quot;pink&quot;, xlab = &quot;Spray&quot;, ylab = &quot;Count&quot;, main = &quot;&quot; ) 水平放置 boxplot(count ~ spray, data = InsectSprays, col = &quot;pink&quot;, horizontal = TRUE, las = 1, # Horizontal labels xlab = &quot;Count&quot;, ylab = &quot;Spray&quot;, main = &quot;&quot; ) Notched Boxplots set.seed(1234) n &lt;- 8 g &lt;- gl(n, 100, n * 100) # n水平个数 100是重复次数 x &lt;- rnorm(n * 100) + sqrt(as.numeric(g)) boxplot(split(x, g), col = hcl.colors(n), notch = TRUE) title( main = &quot;Notched Boxplots&quot;, xlab = &quot;Group&quot;, font.main = 4, font.lab = 1 ) 真实的情况是这样的 cumcm2011A &lt;- readRDS(file = &quot;cumcm2011A.RDS&quot;) par(mfrow = c(2, 4), mar = c(4, 3, 1, 1)) with(cumcm2011A, boxplot(As, xlab = &quot;As&quot;)) abline(h = c(1.8, 3.6, 5.4), col = c(&quot;green&quot;, &quot;blue&quot;, &quot;red&quot;), lty = 2) with(cumcm2011A, boxplot(Cd, xlab = &quot;Cd&quot;)) abline(h = c(70, 130, 190), col = c(&quot;green&quot;, &quot;blue&quot;, &quot;red&quot;), lty = 2) with(cumcm2011A, boxplot(Cr, xlab = &quot;Cr&quot;)) abline(h = c(13, 31, 49), col = c(&quot;green&quot;, &quot;blue&quot;, &quot;red&quot;), lty = 2) with(cumcm2011A, boxplot(Cu, xlab = &quot;Cu&quot;)) abline(h = c(6.0, 13.2, 20.4), col = c(&quot;green&quot;, &quot;blue&quot;, &quot;red&quot;), lty = 2) with(cumcm2011A, boxplot(Hg, xlab = &quot;Hg&quot;)) abline(h = c(19, 35, 51), col = c(&quot;green&quot;, &quot;blue&quot;, &quot;red&quot;), lty = 2) with(cumcm2011A, boxplot(Ni, xlab = &quot;Ni&quot;)) abline(h = c(4.7, 12.3, 19.9), col = c(&quot;green&quot;, &quot;blue&quot;, &quot;red&quot;), lty = 2) with(cumcm2011A, boxplot(Pb, xlab = &quot;Pb&quot;)) abline(h = c(19, 31, 43), col = c(&quot;green&quot;, &quot;blue&quot;, &quot;red&quot;), lty = 2) with(cumcm2011A, boxplot(Zn, xlab = &quot;Zn&quot;)) abline(h = c(41, 69, 97), col = c(&quot;green&quot;, &quot;blue&quot;, &quot;red&quot;), lty = 2) boxplot(As ~ area, data = cumcm2011A, col = hcl.colors(5) ) abline( h = c(1.8, 3.6, 5.4), col = c(&quot;green&quot;, &quot;blue&quot;, &quot;red&quot;), lty = 2, lwd = 2 ) 7.2.12 残差图 iris 四个测量指标 vec_mean &lt;- colMeans(iris[, -5]) vec_sd &lt;- apply(iris[, -5], 2, sd) plot(seq(4), vec_mean, ylim = range(c(vec_mean - vec_sd, vec_mean + vec_sd)), xlab = &quot;Species&quot;, ylab = &quot;Mean +/- SD&quot;, lwd = 1, pch = 19, axes = FALSE ) axis(1, at = seq(4), labels = colnames(iris)[-5]) axis(2, at = seq(7), labels = seq(7)) arrows(seq(4), vec_mean - vec_sd, seq(4), vec_mean + vec_sd, length = 0.05, angle = 90, code = 3 ) box() 图 7.50: 带标准差的均值散点图 7.2.13 提琴图 Tom Kelly 维护的 vioplot 包 https://github.com/TomKellyGenetics/vioplot 7.2.14 轮廓图 topo 是地形数据 等高线图 7.2.15 折线图 函数曲线，样条曲线，核密度曲线，平行坐标图 折线图 点线图 plot(type=\"b\") 函数曲线图 curve matplot X 样条曲线 xspline 时序图 太阳黑子活动数据 sunspot.month Monthly Sunspot Data, from 1749 to “Present” sunspot.year Yearly Sunspot Data, 1700-1988 sunspots Monthly Sunspot Numbers, 1749-1983 plot(AirPassengers) box(col = &quot;gray&quot;) 图 7.51: 折线图 7.2.16 函数图 library(pracma) ## First zero on the critical line s = 0.5 + i t x &lt;- seq(0, 20, len = 1001) z &lt;- 0.5 + x * 1i fr &lt;- Re(zeta(z)) fi &lt;- Im(zeta(z)) fa &lt;- abs(zeta(z)) plot(x, fa, type = &quot;n&quot;, xlim = c(0, 20), ylim = c(-1.5, 2.5), xlab = &quot;Imaginary part (on critical line)&quot;, ylab = &quot;Function value&quot;, main = &quot;Riemann&#39;s Zeta Function along the critical line&quot; ) grid() lines(x, fr, col = &quot;blue&quot;) lines(x, fi, col = &quot;darkgreen&quot;) lines(x, fa, col = &quot;red&quot;, lwd = 2) points(14.1347, 0, col = &quot;darkred&quot;) legend(0, 2.4, c(&quot;real part&quot;, &quot;imaginary part&quot;, &quot;absolute value&quot;), lty = 1, lwd = c(1, 1, 2), col = c(&quot;blue&quot;, &quot;darkgreen&quot;, &quot;red&quot;) ) 还有 eta 函数和 gammaz 函数 7.2.17 马赛克图 马赛克图 mosaicplot plot(HairEyeColor, col = &quot;lightblue&quot;, border = &quot;white&quot;, main = &quot;&quot;) 图 7.52: 马赛克图 7.2.18 克利夫兰点图 dotchart 条件图 coplot 7.2.19 矩阵图 在对角线上添加平滑曲线、密度曲线 pairs(longley, gap = 0, diag.panel = function(x, ...) { par(new = TRUE) hist(x, col = &quot;light blue&quot;, probability = TRUE, axes = FALSE, main = &quot;&quot; ) lines(density(x), col = &quot;red&quot;, lwd = 3 ) rug(x) } ) 图 7.53: 变量关系 # 自带 layout plot(iris[, -5], col = iris$Species) 图 7.54: 矩阵图 7.2.20 雷达图 星图 stars 多元数据 7.2.21 玫瑰图 7.2.22 地形图 轮廓图 contour 等高线图 热图 image if (!&quot;spDataLarge&quot; %in% .packages(TRUE)) { install.packages(&quot;spDataLarge&quot;, repos = &quot;https://nowosad.github.io/drat/&quot;, type = &quot;source&quot; ) } raster 图形，Elevation raster data from SRTM of the Zion National Park area library(sp) library(raster) library(spDataLarge) plot(elevation, asp = NA) 图 7.55: raster 图形 注意与 image 函数区别 # A prettier display of the volcano x &lt;- 10 * (1:nrow(volcano)) y &lt;- 10 * (1:ncol(volcano)) image(x, y, volcano, col = terrain.colors(100), axes = FALSE) contour(x, y, volcano, levels = seq(90, 200, by = 5), add = TRUE, col = &quot;peru&quot; ) axis(1, at = seq(100, 800, by = 100)) axis(2, at = seq(100, 600, by = 100)) box() title(main = &quot;Maunga Whau Volcano&quot;, font.main = 4) 图 7.56: image 图形 7.3 运行环境 xfun::session_info() #&gt; R version 3.6.1 (2019-07-05) #&gt; Platform: x86_64-pc-linux-gnu (64-bit) #&gt; Running under: Debian GNU/Linux 10 (buster) #&gt; #&gt; Locale: #&gt; LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C #&gt; LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 #&gt; LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 #&gt; LC_PAPER=en_US.UTF-8 LC_NAME=C #&gt; LC_ADDRESS=C LC_TELEPHONE=C #&gt; LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C #&gt; #&gt; Package version: #&gt; base64enc_0.1.3 bookdown_0.12 codetools_0.2-16 #&gt; compiler_3.6.1 curl_4.0 digest_0.6.20 #&gt; evaluate_0.14 glue_1.3.1 graphics_3.6.1 #&gt; grDevices_3.6.1 grid_3.6.1 highr_0.8 #&gt; htmltools_0.3.6 jsonlite_1.6 knitr_1.23 #&gt; lattice_0.20-38 magrittr_1.5 markdown_1.0 #&gt; MASS_7.3-51.4 Matrix_1.2-17 methods_3.6.1 #&gt; mime_0.7 pracma_2.2.5 raster_2.9-23 #&gt; Rcpp_1.0.2 rgdal_1.4-4 rmarkdown_1.14 #&gt; sp_1.3-1 spDataLarge_0.3.1 splines_3.6.1 #&gt; stats_3.6.1 stringi_1.4.3 stringr_1.4.0 #&gt; survival_2.44-1.1 tinytex_0.14 tools_3.6.1 #&gt; utils_3.6.1 xfun_0.8 yaml_2.2.0 参考文献 "],
["dv-ggplot2.html", "第 8 章 数据可视化 8.1 基础语法 8.2 统计图形 8.3 运行环境", " 第 8 章 数据可视化 David Robinson 给出为何使用 ggplot224 当然也有 Jeff Leek 指出在某些重要场合不适合 ggplot225 并且给出强有力的 证据，其实不管怎么样，适合自己的才是好的。也不枉费 Garrick Aden-Buie 花费 160 页幻灯片逐步分解介绍 优雅的ggplot2，Malcolm Barrett 也介绍了 ggplot2 基础用法，还有 Selva Prabhakaran 精心总结给出了 50 个 ggplot2 数据可视化的 例子 以及 Victor Perrier 为小白用 ggplot2 操碎了心地开发 RStudio 插件 esquisse 包，Claus O. Wilke 教你一步步创建出版级的图形 https://github.com/clauswilke/practical_ggplot2。 GGplot2 是十分方便的统计作图工具，相比 Base R，为了一张出版级的图形，不需要去调整每个参数，实现快速出图。集成了很多其它统计计算的 R 包，支持丰富的统计分析和计算功能，如回归、平滑等，实现了作图和模型的无缝连接。比如图8.1，使用 loess 局部多项式平滑得到数据的趋势，不仅仅是散点图，代码量也非常少。 ggplot(mpg, aes(displ, hwy)) + geom_point(aes(color = class)) + geom_smooth(se = TRUE, method = &quot;loess&quot;) + labs( title = &quot;Fuel efficiency generally decreases with engine size&quot;, subtitle = &quot;Two seaters (sports cars) are an exception because of their light weight&quot;, caption = &quot;Data from fueleconomy.gov&quot; ) 图 8.1: 简洁美观 故事源于一幅图片，我不记得第一次见到这幅图是什么时候了，只因多次在多个场合中见过，所以留下了深刻的印象，后来才知道它出自于一篇博文 — Using R packages and education to scale Data Science at Airbnb，作者 Ricardo Bion 还在其 Github 上传了相关代码26。除此之外还有几篇重要的参考资料： Pablo Barberá 的 Data Visualization with R and ggplot2 Kieran Healy 的新书 Data Visualization: A Practical Introduction Matt Leonawicz 的新作 mapmate, 可以去其主页欣赏系列作品27 tidytuesday 可视化挑战官方项目 还有 tidytuesday ggstatsplot 可视化统计检验、模型的结果 ggpubr 制作出版级统计图形 8.1 基础语法 以数据集 airquality 为例介绍GGplot2 图层、主题、配色、坐标、尺度、注释和组合等 8.1.1 图层 ls(&quot;package:ggplot2&quot;, pattern = &quot;^geom_&quot;) #&gt; [1] &quot;geom_abline&quot; &quot;geom_area&quot; &quot;geom_bar&quot; #&gt; [4] &quot;geom_bin2d&quot; &quot;geom_blank&quot; &quot;geom_boxplot&quot; #&gt; [7] &quot;geom_col&quot; &quot;geom_contour&quot; &quot;geom_count&quot; #&gt; [10] &quot;geom_crossbar&quot; &quot;geom_curve&quot; &quot;geom_density&quot; #&gt; [13] &quot;geom_density_2d&quot; &quot;geom_density2d&quot; &quot;geom_dotplot&quot; #&gt; [16] &quot;geom_errorbar&quot; &quot;geom_errorbarh&quot; &quot;geom_freqpoly&quot; #&gt; [19] &quot;geom_hex&quot; &quot;geom_histogram&quot; &quot;geom_hline&quot; #&gt; [22] &quot;geom_jitter&quot; &quot;geom_label&quot; &quot;geom_line&quot; #&gt; [25] &quot;geom_linerange&quot; &quot;geom_map&quot; &quot;geom_path&quot; #&gt; [28] &quot;geom_point&quot; &quot;geom_pointrange&quot; &quot;geom_polygon&quot; #&gt; [31] &quot;geom_qq&quot; &quot;geom_qq_line&quot; &quot;geom_quantile&quot; #&gt; [34] &quot;geom_raster&quot; &quot;geom_rect&quot; &quot;geom_ribbon&quot; #&gt; [37] &quot;geom_rug&quot; &quot;geom_segment&quot; &quot;geom_sf&quot; #&gt; [40] &quot;geom_sf_label&quot; &quot;geom_sf_text&quot; &quot;geom_smooth&quot; #&gt; [43] &quot;geom_spoke&quot; &quot;geom_step&quot; &quot;geom_text&quot; #&gt; [46] &quot;geom_tile&quot; &quot;geom_violin&quot; &quot;geom_vline&quot; 生成一个散点图 ggplot(airquality, aes(x = Temp, y = Ozone)) + geom_point() #&gt; Warning: Removed 37 rows containing missing values (geom_point). 8.1.2 主题 ls(&quot;package:ggplot2&quot;, pattern = &quot;^theme_&quot;) #&gt; [1] &quot;theme_bw&quot; &quot;theme_classic&quot; &quot;theme_dark&quot; &quot;theme_get&quot; #&gt; [5] &quot;theme_gray&quot; &quot;theme_grey&quot; &quot;theme_light&quot; &quot;theme_linedraw&quot; #&gt; [9] &quot;theme_minimal&quot; &quot;theme_replace&quot; &quot;theme_set&quot; &quot;theme_test&quot; #&gt; [13] &quot;theme_update&quot; &quot;theme_void&quot; 这里只展示 theme_bw() theme_void() theme_minimal() 和 theme_void() 等四个常见主题，更多主题参考 ggsci、ggthemes 、hrbrthemes 和 ggthemr 包 ggplot(airquality, aes(x = Temp, y = Ozone)) + geom_point() + theme_bw() #&gt; Warning: Removed 37 rows containing missing values (geom_point). ggplot(airquality, aes(x = Temp, y = Ozone)) + geom_point() + theme_void() #&gt; Warning: Removed 37 rows containing missing values (geom_point). ggplot(airquality, aes(x = Temp, y = Ozone)) + geom_point() + theme_minimal() #&gt; Warning: Removed 37 rows containing missing values (geom_point). ggplot(airquality, aes(x = Temp, y = Ozone)) + geom_point() + theme_void() #&gt; Warning: Removed 37 rows containing missing values (geom_point). 除主题之外，还有一类提供一整套统一的风格样式来绘制各种统计图形，如 ggpubr 和 bbplot 8.1.3 配色 ls(&quot;package:ggplot2&quot;, pattern = &quot;^scale_(color|fill)_&quot;) #&gt; [1] &quot;scale_color_brewer&quot; &quot;scale_color_continuous&quot; #&gt; [3] &quot;scale_color_discrete&quot; &quot;scale_color_distiller&quot; #&gt; [5] &quot;scale_color_gradient&quot; &quot;scale_color_gradient2&quot; #&gt; [7] &quot;scale_color_gradientn&quot; &quot;scale_color_grey&quot; #&gt; [9] &quot;scale_color_hue&quot; &quot;scale_color_identity&quot; #&gt; [11] &quot;scale_color_manual&quot; &quot;scale_color_viridis_c&quot; #&gt; [13] &quot;scale_color_viridis_d&quot; &quot;scale_fill_brewer&quot; #&gt; [15] &quot;scale_fill_continuous&quot; &quot;scale_fill_date&quot; #&gt; [17] &quot;scale_fill_datetime&quot; &quot;scale_fill_discrete&quot; #&gt; [19] &quot;scale_fill_distiller&quot; &quot;scale_fill_gradient&quot; #&gt; [21] &quot;scale_fill_gradient2&quot; &quot;scale_fill_gradientn&quot; #&gt; [23] &quot;scale_fill_grey&quot; &quot;scale_fill_hue&quot; #&gt; [25] &quot;scale_fill_identity&quot; &quot;scale_fill_manual&quot; #&gt; [27] &quot;scale_fill_ordinal&quot; &quot;scale_fill_viridis_c&quot; #&gt; [29] &quot;scale_fill_viridis_d&quot; ggplot(airquality, aes(x = Temp, y = Ozone, color = as.factor(Month))) + geom_point(na.rm = TRUE) ggplot(airquality, aes(x = Temp, y = Ozone, color = as.ordered(Month))) + geom_point(na.rm = TRUE) 8.1.4 刻度 ls(&quot;package:ggplot2&quot;, pattern = &quot;^scale_(x|y)_&quot;) #&gt; [1] &quot;scale_x_continuous&quot; &quot;scale_x_date&quot; &quot;scale_x_datetime&quot; #&gt; [4] &quot;scale_x_discrete&quot; &quot;scale_x_log10&quot; &quot;scale_x_reverse&quot; #&gt; [7] &quot;scale_x_sqrt&quot; &quot;scale_x_time&quot; &quot;scale_y_continuous&quot; #&gt; [10] &quot;scale_y_date&quot; &quot;scale_y_datetime&quot; &quot;scale_y_discrete&quot; #&gt; [13] &quot;scale_y_log10&quot; &quot;scale_y_reverse&quot; &quot;scale_y_sqrt&quot; #&gt; [16] &quot;scale_y_time&quot; range(airquality$Temp, na.rm = TRUE) #&gt; [1] 56 97 range(airquality$Ozone, na.rm = TRUE) #&gt; [1] 1 168 ggplot(airquality, aes(x = Temp, y = Ozone)) + geom_point(na.rm = TRUE) + scale_x_continuous(breaks = seq(50, 100, 5)) + scale_y_continuous(breaks = seq(0, 200, 20)) 8.1.5 注释 ls(&quot;package:ggplot2&quot;, pattern = &quot;^annotation_&quot;) #&gt; [1] &quot;annotation_custom&quot; &quot;annotation_logticks&quot; &quot;annotation_map&quot; #&gt; [4] &quot;annotation_raster&quot; ggplot(airquality, aes(x = Temp, y = Ozone)) + geom_point(na.rm = TRUE) ggplot(airquality, aes(x = Temp, y = Ozone)) + geom_point(na.rm = TRUE) + labs(title = substitute(paste(d * bolditalic(x)[italic(t)] == alpha * (theta - bolditalic(x)[italic(t)]) * d * italic(t) + lambda * d * italic(B)[italic(t)]), list(lambda = 4))) 8.1.6 图例 二维的图例 biscale 和 multiscales 和 ggnewscale 8.1.7 组合 ggplot(airquality) + geom_point(aes(x = Temp, y = Ozone), na.rm = TRUE) + facet_wrap(~ as.ordered(Month)) ggplot(airquality) + geom_point(aes(x = Temp, y = Ozone), na.rm = TRUE) + facet_wrap(~ as.ordered(Month), nrow = 1) cowplot 是以作者 Claus O. Wilke 命名的，用来组合 ggplot 对象画图，类似的组合图形的功能包还有 baptiste auguié 开发的 gridExtra 和 egg， Thomas Lin Pedersen 开发的 patchwork Dean Attali 开发的 ggExtra 可以在图的边界添加密度估计曲线，直方图等 8.1.8 坐标系 极坐标，直角坐标 ls(&quot;package:ggplot2&quot;, pattern = &quot;^coord_&quot;) #&gt; [1] &quot;coord_cartesian&quot; &quot;coord_equal&quot; &quot;coord_fixed&quot; #&gt; [4] &quot;coord_flip&quot; &quot;coord_map&quot; &quot;coord_munch&quot; #&gt; [7] &quot;coord_polar&quot; &quot;coord_quickmap&quot; &quot;coord_sf&quot; #&gt; [10] &quot;coord_trans&quot; 8.1.9 坐标轴 坐标轴标签位置、大小、字体 8.2 统计图形 8.2.1 散点图 下面以 diamonds 数据集为例展示 ggplot2 的绘图过程，首先加载 diamonds 数据集，查看数据集的内容 data(diamonds) str(diamonds) #&gt; Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 53940 obs. of 10 variables: #&gt; $ carat : num 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ... #&gt; $ cut : Ord.factor w/ 5 levels &quot;Fair&quot;&lt;&quot;Good&quot;&lt;..: 5 4 2 4 2 3 3 3 1 3 .. #&gt; $ color : Ord.factor w/ 7 levels &quot;D&quot;&lt;&quot;E&quot;&lt;&quot;F&quot;&lt;&quot;G&quot;&lt;..: 2 2 2 6 7 7 6 5 2 .. #&gt; $ clarity: Ord.factor w/ 8 levels &quot;I1&quot;&lt;&quot;SI2&quot;&lt;&quot;SI1&quot;&lt;..: 2 3 5 4 2 6 7 3 4.. #&gt; $ depth : num 61.5 59.8 56.9 62.4 63.3 62.8 62.3 61.9 65.1 59.4 ... #&gt; $ table : num 55 61 65 58 58 57 57 55 61 61 ... #&gt; $ price : int 326 326 327 334 335 336 336 337 337 338 ... #&gt; $ x : num 3.95 3.89 4.05 4.2 4.34 3.94 3.95 4.07 3.87 4 ... #&gt; $ y : num 3.98 3.84 4.07 4.23 4.35 3.96 3.98 4.11 3.78 4.05 ... #&gt; $ z : num 2.43 2.31 2.31 2.63 2.75 2.48 2.47 2.53 2.49 2.39 ... 数值型变量 carat 作为 x 轴 ggplot(diamonds, aes(x = carat)) ggplot(diamonds, aes(x = carat, y = price)) ggplot(diamonds, aes(x = carat, color = cut)) ggplot(diamonds, aes(x = carat), color = &quot;steelblue&quot;) 图 8.2: 指定统一颜色 图 8.2 的基础上添加数据图层 sub_diamonds &lt;- diamonds[sample(1:nrow(diamonds), 1000), ] ggplot(sub_diamonds, aes(x = carat, y = price)) + geom_point() 图 8.3: 添加数据图层 给散点图8.3上色 ggplot(sub_diamonds, aes(x = carat, y = price)) + geom_point(color = &quot;steelblue&quot;) 图 8.4: 散点图配色 ggplot(sub_diamonds, aes(x = carat, y = price)) + geom_point(color = &quot;steelblue&quot;) + scale_y_continuous( labels = scales::unit_format(unit = &quot;k&quot;, scale = 1e-3), breaks = seq(0, 20000, 4000) ) 图 8.5: 格式化坐标轴刻度标签 让另一变量 cut 作为颜色分类指标 ggplot(sub_diamonds, aes(x = carat, y = price, color = cut)) + geom_point() 图 8.6: 分类散点图 当然还有一种类似的表示就是分组，默认情况下，ggplot2将所有观测点视为一组，以分类变量 cut 来分组 ggplot(sub_diamonds, aes(x = carat, y = price, group = cut)) + geom_point() 图 8.7: 分组 在图8.7 上没有体现出来分组的意思，下面以 cut 分组线性回归为例 ggplot(sub_diamonds, aes(x = carat, y = price)) + geom_point() + geom_smooth(method = &quot;lm&quot;) ggplot(sub_diamonds, aes(x = carat, y = price, group = cut)) + geom_point() + geom_smooth(method = &quot;lm&quot;) 图 8.8: 分组线性回归 我们当然可以选择更加合适的拟合方式，如局部多项式平滑 loess 但是该方法不太适用观测值比较多的情况，因为它会占用比较多的内存，建议使用广义可加模型作平滑拟合 ggplot(sub_diamonds, aes(x = carat, y = price, group = cut)) + geom_point() + geom_smooth(method = &quot;loess&quot;) 图 8.9: 局部多项式平滑 ggplot(sub_diamonds, aes(x = carat, y = price, group = cut)) + geom_point() + geom_smooth(method = &quot;gam&quot;, formula = y ~ s(x, bs = &quot;cs&quot;)) 图 8.10: 数据分组应用广义可加平滑 ggfortify 包支持更多的统计分析结果的可视化 为了更好地区分开组别，我们在图8.10的基础上分面或者配色 ggplot(sub_diamonds, aes(x = carat, y = price, group = cut)) + geom_point() + geom_smooth(method = &quot;gam&quot;, formula = y ~ s(x, bs = &quot;cs&quot;)) + facet_grid(~cut) ggplot(sub_diamonds, aes(x = carat, y = price, group = cut, color = cut)) + geom_point() + geom_smooth(method = &quot;gam&quot;, formula = y ~ s(x, bs = &quot;cs&quot;)) 图 8.11: 分组配色 在分类散点图的另一种表示方法就是分面图，以 cut 变量作为分面的依据 ggplot(sub_diamonds, aes(x = carat, y = price)) + geom_point() + facet_grid(~cut) 图 8.12: 分面散点图 给图 8.12 上色 ggplot(sub_diamonds, aes(x = carat, y = price)) + geom_point(color = &quot;steelblue&quot;) + facet_grid(~cut) 图 8.13: 给分面散点图上色 在图8.13的基础上，给不同的类上不同的颜色 ggplot(sub_diamonds, aes(x = carat, y = price, color = cut)) + geom_point() + facet_grid(~cut) 图 8.14: 给不同的类上不同的颜色 去掉图例，此时图例属于冗余信息了 ggplot(sub_diamonds, aes(x = carat, y = price, color = cut)) + geom_point(show.legend = FALSE) + facet_grid(~cut) 图 8.15: 去掉图例 四块土地，所施肥料不同，肥力大小顺序 4 &lt; 2 &lt; 3 &lt; 1 小麦产量随肥力的变化 data(Wheat2, package = &quot;nlme&quot;) # Wheat Yield Trials library(colorspace) ggplot(Wheat2, aes(longitude, latitude)) + geom_point(aes(size = yield, colour = Block)) + scale_color_discrete_sequential(palette = &quot;Viridis&quot;) + scale_x_continuous(breaks = seq(0, 30, 5)) + scale_y_continuous(breaks = seq(0, 50, 10)) 图 8.16: 多个图例 ggplot(mtcars, aes(x = hp, y = mpg, color = factor(am))) + geom_point() 图 8.17: 分类散点图 图层、分组、分面和散点图介绍完了，接下来就是其它统计图形，如箱线图，小提琴图和条形图 dat &lt;- as.data.frame(cbind(rep(1948 + seq(12), each = 12), rep(seq(12), 12), AirPassengers)) colnames(dat) &lt;- c(&quot;year&quot;, &quot;month&quot;, &quot;passengers&quot;) ggplot(data = dat, aes(x = as.factor(year), y = as.factor(month))) + stat_sum(aes(size = passengers), colour = &quot;lightblue&quot;) + scale_size(range = c(1, 10), breaks = seq(100, 650, 50)) + labs(x = &quot;Year&quot;, y = &quot;Month&quot;, colour = &quot;Passengers&quot;) + theme_minimal() 图 7.14: 1948年至1960年航班乘客人数变化 8.2.2 箱线图 以 PlantGrowth 数据集为例展示箱线图，在两组不同实验条件下，植物生长的情况，纵坐标是干燥植物的量，横坐标表示不同的实验条件。这是非常典型的适合用箱线图来表达数据的场合，Y 轴对应数值型变量，X 轴对应分类变量，在 R 语言中，分类变量的类型是 factor data(&quot;PlantGrowth&quot;) str(PlantGrowth) #&gt; &#39;data.frame&#39;: 30 obs. of 2 variables: #&gt; $ weight: num 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ... #&gt; $ group : Factor w/ 3 levels &quot;ctrl&quot;,&quot;trt1&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... ggplot(data = PlantGrowth, aes(x = group, y = weight)) + geom_boxplot() PlantGrowth 数据量比较小，此时比较适合采用抖动散点图，抖动是为了避免点之间相互重叠，为了增加不同类别之间的识别性，我们可以用不同的点的形状或者不同的颜色来表示类别 ggplot(data = PlantGrowth, aes(x = group, y = weight, shape = group)) + geom_jitter() ggplot(data = PlantGrowth, aes(x = group, y = weight, color = group)) + geom_jitter() boxplot(weight ~ group, data = PlantGrowth, ylab = &quot;Dried weight of plants&quot;, col = &quot;lightgray&quot;, notch = FALSE, varwidth = TRUE ) 以钻石切割质量 cut 为分面依据，以钻石颜色类别 color 为 x 轴，钻石价格为 y 轴，绘制箱线图8.18 ggplot(diamonds, aes(x = color, y = price, color = cut)) + geom_boxplot(show.legend = FALSE) + facet_grid(~cut) 图 8.18: 箱线图 我们当然还可以添加钻石的纯净度 clarity 作为分面依据，那么箱线图可以为图 8.19 ggplot(diamonds, aes(x = color, y = price, color = cut)) + geom_boxplot(show.legend = FALSE) + facet_grid(clarity ~ cut) 图 8.19: 复合分面箱线图 经过观察，我们发现水平分类过多，考虑用切割质量 cut 替换钻石颜色 color 绘图，但是由于分类过细，图信息展示不简练，反而不好，如图 8.20 ggplot(diamonds, aes(x = cut, y = price, color = cut)) + geom_boxplot(show.legend = FALSE) + facet_grid(clarity ~ color) ggplot(diamonds, aes(x = cut, y = price, color = color)) + geom_boxplot(show.legend = FALSE) + facet_grid(clarity ~ color) 图 8.20: 钻石颜色配色 8.2.3 条形图 条形图特别适合分类变量的展示，我们这里展示钻石切割质量 cut 不同等级的数量，当然我们可以直接展示各类的数目，在图层 geom_bar 中指定 stat=\"identity\" # 需要映射数据框的两个变量，相当于自己先计算了每类的数量 with(diamonds, table(cut)) #&gt; cut #&gt; Fair Good Very Good Premium Ideal #&gt; 1610 4906 12082 13791 21551 cut_df &lt;- as.data.frame(table(diamonds$cut)) ggplot(cut_df, aes(x = Var1, y = Freq)) + geom_bar(stat = &quot;identity&quot;) ggplot(diamonds, aes(x = cut)) + geom_bar() 图 8.21: 频数条形图 还有另外三种表示方法 ggplot(diamonds, aes(x = cut)) + geom_bar(stat = &quot;count&quot;) ggplot(diamonds, aes(x = cut, y = ..count..)) + geom_bar() ggplot(diamonds, aes(x = cut, y = stat(count))) + geom_bar() 我们还可以在图 8.21 的基础上再添加一个分类变量钻石的纯净度 clarity，形成堆积条形图 ggplot(diamonds, aes(x = cut, fill = clarity)) + geom_bar() 图 8.22: 堆积条形图 再添加一个分类变量钻石颜色 color 比较好的做法是分面 ggplot(diamonds, aes(x = color, fill = clarity)) + geom_bar() + facet_grid(~cut) 图 8.23: 分面堆积条形图 实际上，绘制图8.23包含了对分类变量的分组计数过程，如下 with(diamonds, table(cut, color)) #&gt; color #&gt; cut D E F G H I J #&gt; Fair 163 224 312 314 303 175 119 #&gt; Good 662 933 909 871 702 522 307 #&gt; Very Good 1513 2400 2164 2299 1824 1204 678 #&gt; Premium 1603 2337 2331 2924 2360 1428 808 #&gt; Ideal 2834 3903 3826 4884 3115 2093 896 还有一种堆积的方法是按比例，而不是按数量，如图8.24 ggplot(diamonds, aes(x = color, fill = clarity)) + geom_bar(position = &quot;fill&quot;) + facet_grid(~cut) 图 8.24: 比例堆积条形图 接下来就是复合条形图 ggplot(diamonds, aes(x = color, fill = clarity)) + geom_bar(position = &quot;dodge&quot;) 图 8.25: 复合条形图 再添加一个分类变量，就是需要分面大法了，图 8.25 展示了三个分类变量，其实我们还可以再添加一个分类变量用作分面的列依据 ggplot(diamonds, aes(x = color, fill = clarity)) + geom_bar(position = &quot;dodge&quot;) + facet_grid(rows = vars(cut)) 图 8.26: 分面复合条形图 图 8.26 展示的数据如下 with(diamonds, table(color, clarity, cut)) #&gt; , , cut = Fair #&gt; #&gt; clarity #&gt; color I1 SI2 SI1 VS2 VS1 VVS2 VVS1 IF #&gt; D 4 56 58 25 5 9 3 3 #&gt; E 9 78 65 42 14 13 3 0 #&gt; F 35 89 83 53 33 10 5 4 #&gt; G 53 80 69 45 45 17 3 2 #&gt; H 52 91 75 41 32 11 1 0 #&gt; I 34 45 30 32 25 8 1 0 #&gt; J 23 27 28 23 16 1 1 0 #&gt; #&gt; , , cut = Good #&gt; #&gt; clarity #&gt; color I1 SI2 SI1 VS2 VS1 VVS2 VVS1 IF #&gt; D 8 223 237 104 43 25 13 9 #&gt; E 23 202 355 160 89 52 43 9 #&gt; F 19 201 273 184 132 50 35 15 #&gt; G 19 163 207 192 152 75 41 22 #&gt; H 14 158 235 138 77 45 31 4 #&gt; I 9 81 165 110 103 26 22 6 #&gt; J 4 53 88 90 52 13 1 6 #&gt; #&gt; , , cut = Very Good #&gt; #&gt; clarity #&gt; color I1 SI2 SI1 VS2 VS1 VVS2 VVS1 IF #&gt; D 5 314 494 309 175 141 52 23 #&gt; E 22 445 626 503 293 298 170 43 #&gt; F 13 343 559 466 293 249 174 67 #&gt; G 16 327 474 479 432 302 190 79 #&gt; H 12 343 547 376 257 145 115 29 #&gt; I 8 200 358 274 205 71 69 19 #&gt; J 8 128 182 184 120 29 19 8 #&gt; #&gt; , , cut = Premium #&gt; #&gt; clarity #&gt; color I1 SI2 SI1 VS2 VS1 VVS2 VVS1 IF #&gt; D 12 421 556 339 131 94 40 10 #&gt; E 30 519 614 629 292 121 105 27 #&gt; F 34 523 608 619 290 146 80 31 #&gt; G 46 492 566 721 566 275 171 87 #&gt; H 46 521 655 532 336 118 112 40 #&gt; I 24 312 367 315 221 82 84 23 #&gt; J 13 161 209 202 153 34 24 12 #&gt; #&gt; , , cut = Ideal #&gt; #&gt; clarity #&gt; color I1 SI2 SI1 VS2 VS1 VVS2 VVS1 IF #&gt; D 13 356 738 920 351 284 144 28 #&gt; E 18 469 766 1136 593 507 335 79 #&gt; F 42 453 608 879 616 520 440 268 #&gt; G 16 486 660 910 953 774 594 491 #&gt; H 38 450 763 556 467 289 326 226 #&gt; I 17 274 504 438 408 178 179 95 #&gt; J 2 110 243 232 201 54 29 25 8.2.4 折线图 时间序列数据的展示，时序图 ggplot(economics, aes(date, unemploy)) + geom_line() 图 7.22: 时序图 8.2.5 直方图 直方图用来查看连续变量的分布 ggplot(diamonds, aes(price)) + geom_histogram(bins = 30) 图 7.23: 钻石价格的分布 堆积直方图 ggplot(diamonds, aes(x = price, fill = cut)) + geom_histogram(bins = 30) 图 8.27: 钻石价格随切割质量的分布 基础 R 包与 Ggplot2 包绘制的直方图的对比，Base R 绘图速度快，代码更加稳定，Ggplot2 代码简洁，更美观 par(mar = c(2.1, 2.1, 1.5, 0.5)) plot(c(50, 350), c(0, 10), type = &quot;n&quot;, font.main = 1, xlab = &quot;&quot;, ylab = &quot;&quot;, frame.plot = FALSE, axes = FALSE, # xlab = &quot;hp&quot;, ylab = &quot;Frequency&quot;, main = paste(&quot;Histogram with Base R&quot;, paste(rep(&quot; &quot;, 60), collapse = &quot;&quot;)) ) axis( side = 1, at = seq(50, 350, 50), labels = seq(50, 350, 50), tick = FALSE, las = 1, padj = 0, mgp = c(3, 0.1, 0) ) axis( side = 2, at = seq(0, 10, 2), labels = seq(0, 10, 2), # col = &quot;white&quot;, 坐标轴的颜色 # col.ticks 刻度线的颜色 tick = FALSE, # 取消刻度线 las = 1, # 水平方向 hadj = 1, # 右侧对齐 mgp = c(3, 0.1, 0) # 纵轴边距线设置为 0.1 ) abline(h = seq(0, 10, 2), v = seq(50, 350, 50), col = &quot;gray90&quot;, lty = &quot;solid&quot;) abline(h = seq(1, 9, 2), v = seq(75, 325, 50), col = &quot;gray95&quot;, lty = &quot;solid&quot;) hist(mtcars$hp, col = &quot;#56B4E9&quot;, border = &quot;white&quot;, freq = TRUE, add = TRUE # labels = TRUE, axes = TRUE, ylim = c(0, 10.5), # xlab = &quot;hp&quot;,main = &quot;Histogram with Base R&quot; ) mtext(&quot;hp&quot;, 1, line = 1.0) mtext(&quot;Frequency&quot;, 2, line = 1.0) ggplot(mtcars) + geom_histogram(aes(x = hp), fill = &quot;#56B4E9&quot;, color = &quot;white&quot;, breaks = seq(50, 350, 50)) + scale_x_continuous(breaks = seq(50, 350, 50)) + scale_y_continuous(breaks = seq(0, 12, 2)) + labs(x = &quot;hp&quot;, y = &quot;Frequency&quot;, title = &quot;Histogram with Ggplot2&quot;) + theme_minimal(base_size = 12) 图 7.24: 直方图 8.2.6 提琴图 提琴图 ggplot(diamonds, aes(x = cut, y = price)) + geom_boxplot() ggplot(diamonds, aes(x = cut, y = price)) + geom_violin() 图 8.28: 小提琴图 ggplot(mpg, aes(class, cty)) + geom_violin() + labs( title = &quot;Violin plot&quot;, subtitle = &quot;City Mileage vs Class of vehicle&quot;, caption = &quot;Source: mpg&quot;, x = &quot;Class of Vehicle&quot;, y = &quot;City Mileage&quot; ) 图 8.29: 城市里程与车辆类别 蜂群图 ggbeeswarm 是分类散点图加箱线图的合体 ggplot(mpg, aes(x = class, y = hwy, color = class)) + ggbeeswarm::geom_quasirandom() 8.2.7 抖动图 抖动图适合数据量比较小的情况 ggplot(mpg, aes(x = class, y = hwy, color = class)) + geom_jitter() 抖不抖，还是抖一下 ggplot(iris, aes(x = Species, y = Sepal.Length)) + geom_point(aes(fill = Species), size = 5, shape = 21, colour = &quot;grey20&quot;) + # geom_boxplot(outlier.colour = NA, fill = NA, colour = &quot;grey20&quot;) + labs(title = &quot;Not Jittered&quot;) ggplot(iris, aes(x = Species, y = Sepal.Length)) + geom_point(aes(fill = Species), size = 5, shape = 21, colour = &quot;grey20&quot;, position = position_jitter(width = 0.2, height = 0.1) ) + # geom_boxplot(outlier.colour = NA, fill = NA, colour = &quot;grey20&quot;) + labs(title = &quot;Jittered&quot;) 在数据量比较大的时候，可以用箱线图、密度图、提琴图 ggplot(sub_diamonds, aes(x = cut, y = price)) + geom_jitter() 图 8.30: 抖动图的反例 上色和分面都不好使的抖动图，因为区分度变小 ggplot(sub_diamonds, aes(x = color, y = price, color = color)) + geom_jitter() + facet_grid(clarity ~ cut) 图 7.25: 根据钻石颜色上色 箱线图此时不宜分的过细 ggplot(diamonds, aes(x = color, y = price, color = color)) + geom_boxplot() + facet_grid(cut ~ clarity) 图 7.26: 箱线图 所以这样更好 ggplot(diamonds, aes(x = color, y = price, color = color)) + geom_boxplot() + facet_grid(~clarity) 最好只比较一个维度 ggplot(diamonds, aes(x = color, y = price, color = color)) + geom_boxplot() 8.2.8 密度图 ggplot(mpg, aes(cty)) + geom_density(aes(fill = factor(cyl)), alpha = 0.8) + labs( title = &quot;Density plot&quot;, subtitle = &quot;City Mileage Grouped by Number of cylinders&quot;, caption = &quot;Source: mpg&quot;, x = &quot;City Mileage&quot;, fill = &quot;# Cylinders&quot; ) 图 7.29: 按汽缸数分组的城市里程 添加透明度，解决遮挡 ggplot(diamonds, aes(x = price, fill = cut)) + geom_density() ggplot(diamonds, aes(x = price, fill = cut)) + geom_density(alpha = 0.5) 图 8.31: 添加透明度的密度图 堆积密度图 ggplot(diamonds, aes(x = price, fill = cut)) + geom_density(position = &quot;stack&quot;) 图 8.32: 堆积密度图 条件密度估计 # You can use position=&quot;fill&quot; to produce a conditional density estimate ggplot(diamonds, aes(carat, stat(count), fill = cut)) + geom_density(position = &quot;fill&quot;) 图 7.30: 条件密度估计图 岭线图是密度图的一种变体，可以防止密度曲线重叠在一起 ggplot(diamonds) + ggridges::geom_density_ridges(aes(x = price, y = color, fill = color)) #&gt; Picking joint bandwidth of 535 二维的密度图又是一种延伸 ggplot(diamonds, aes(x = carat, y = price)) + geom_density_2d(aes(color = cut)) + facet_grid(~cut) stat 函数，特别是 nlevel 参数，在密度曲线之间填充我们又可以得到热力图 ggplot(diamonds, aes(x = carat, y = price)) + stat_density_2d(aes(fill = stat(nlevel)), geom = &quot;polygon&quot;) + facet_grid(. ~ cut) gemo_hex 也是二维密度图的一种变体，特别适合数据量比较大的情形 ggplot(diamonds, aes(x = carat, y = price)) + geom_hex() + scale_fill_viridis_c() 8.2.9 玫瑰图 南丁格尔风玫瑰图28 可以作为堆积条形图，分组条形图 ggplot(diamonds, aes(x = color, fill = clarity)) + geom_bar() ggplot(diamonds, aes(x = color, fill = clarity)) + geom_bar() + coord_polar() 图 8.33: 堆积条形图转风玫瑰图 # 风玫瑰图 http://blog.csdn.net/Bone_ACE/article/details/47624987 set.seed(2018) # 随机生成100次风向，并汇集到16个区间内 direction &lt;- cut_interval(runif(100, 0, 360), n = 16) # 随机生成100次风速，并划分成4种强度 mag &lt;- cut_interval(rgamma(100, 15), 4) dat &lt;- data.frame(direction = direction, mag = mag) # 将风向映射到X轴，频数映射到Y轴，风速大小映射到填充色，生成条形图后再转为极坐标形式即可 p &lt;- ggplot(dat, aes(x = direction, y = ..count.., fill = mag)) p + geom_bar(colour = &quot;white&quot;) + coord_polar() + theme(axis.ticks = element_blank(), axis.text.y = element_blank()) + labs(x = &quot;&quot;, y = &quot;&quot;, fill = &quot;Magnitude&quot;) 图 8.34: 风玫瑰图 p + geom_bar(position = &quot;fill&quot;) + coord_polar() + theme(axis.ticks = element_blank(), axis.text.y = element_blank()) + labs(x = &quot;&quot;, y = &quot;&quot;, fill = &quot;Magnitude&quot;) 8.2.10 词云图 词云 ggwordcloud 8.3 运行环境 xfun::session_info( packages = c( &quot;ggplot2&quot;, &quot;magrittr&quot;, &quot;colorspace&quot;, &quot;nlme&quot;, &quot;mgcv&quot;, &quot;ggbeeswarm&quot;, &quot;ggridges&quot;, &quot;hexbin&quot; ) ) #&gt; R version 3.6.1 (2019-07-05) #&gt; Platform: x86_64-pc-linux-gnu (64-bit) #&gt; Running under: Debian GNU/Linux 10 (buster) #&gt; #&gt; Locale: #&gt; LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C #&gt; LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 #&gt; LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 #&gt; LC_PAPER=en_US.UTF-8 LC_NAME=C #&gt; LC_ADDRESS=C LC_TELEPHONE=C #&gt; LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C #&gt; #&gt; Package version: #&gt; assertthat_0.2.1 backports_1.1.4 beeswarm_0.2.3 #&gt; cli_1.1.0 colorspace_1.4-1 crayon_1.3.4 #&gt; digest_0.6.20 ellipsis_0.2.0.1 fansi_0.4.0 #&gt; ggbeeswarm_0.6.0 ggplot2_3.2.0 ggridges_0.5.1 #&gt; glue_1.3.1 graphics_3.6.1 grDevices_3.6.1 #&gt; grid_3.6.1 gtable_0.3.0 hexbin_1.27.3 #&gt; labeling_0.3 lattice_0.20.38 lazyeval_0.2.2 #&gt; magrittr_1.5 MASS_7.3.51.4 Matrix_1.2.17 #&gt; methods_3.6.1 mgcv_1.8-28 munsell_0.5.0 #&gt; nlme_3.1-140 pillar_1.4.2 pkgconfig_2.0.2 #&gt; plyr_1.8.4 R6_2.4.0 RColorBrewer_1.1.2 #&gt; Rcpp_1.0.2 reshape2_1.4.3 rlang_0.4.0 #&gt; scales_1.0.0 splines_3.6.1 stats_3.6.1 #&gt; stringi_1.4.3 stringr_1.4.0 tibble_2.1.3 #&gt; tools_3.6.1 utf8_1.1.4 utils_3.6.1 #&gt; vctrs_0.2.0 vipor_0.4.5 viridisLite_0.3.0 #&gt; withr_2.1.2 zeallot_0.1.0 "],
["dv-spatio-temporal.html", "第 9 章 时空可视化 9.1 地图 9.2 空间数据对象", " 第 9 章 时空可视化 library(ggplot2) library(magrittr) options( ggplot2.continuous.colour = &quot;viridis&quot;, ggplot2.continuous.fill = &quot;viridis&quot; ) Robert J. Hijmans29 开发了 raster 包用于网格空间数据的读、写、操作、分析和建模，同时维护了空间数据分析的网站 https://www.rspatial.org Edzer Pebesma30 和 Roger Bivand 等创建了 sp 包定义了空间数据类型和方法，提供了大量的空间数据操作方法，同时维护了空间数据对象 sp 的绘图网站 https://edzer.github.io/sp/，他们也一起合作写了新书 Spatial Data Science，提供了在线 网页版 书籍及其 源代码 Edzer Pebesma 后来开发了 sf 包重新定义了空间数据对象和操作方法，并维护了空间数据分析、建模和可视化网站 https://www.r-spatial.org/ 课程案例学习 2018-Introduction to Geospatial Raster and Vector Data with R 空间数据分析课程 Peter Ellis 新西兰大选和普查数据 More cartograms of New Zealand census data: district and city level 2017-Mapping oil production by country in R 石油产量在全球的分布 2017-How to highlight countries on a map 高亮地图上的国家 2017-Mapping With Sf: Part 3 Data Visualization Shiny Apps 数据可视化核密度估计 In this app I identify crime hotspots using a bivariate density estimation strategy Association of Statisticians of American Religious Bodies (ASARB) viridis USA map 出租车行车轨迹数据 Geospatial processing with Clickhouse-CARTO Blog 9.1 地图 我们先来看看中国及其周边，这个地图的缺陷就是中国南海及九段线没有标记，台湾和中国大陆不是一种颜色标记，地图数据来自 R 包的 maps 和 mapdata library(maps) library(mapdata) east_asia &lt;- map_data(&quot;worldHires&quot;, region = c( &quot;Japan&quot;, &quot;Taiwan&quot;, &quot;China&quot;, &quot;North Korea&quot;, &quot;South Korea&quot; ) ) ggplot(east_asia, aes(x = long, y = lat, group = group, fill = region)) + geom_polygon(colour = &quot;black&quot;) + scale_fill_brewer(palette = &quot;Set2&quot;) 9.1.1 投影和观察方位 世界地图引发的 https://d.cosx.org/d/420808 worldmap &lt;- map_data(&quot;world&quot;) ggplot(worldmap, aes(long, lat, group = group)) + geom_polygon() + coord_map( xlim = c(-120, 40), ylim = c(30, 90), orientation = c(90, 0, 0) ) # 默认mercator投影下的默认视角 c(90, 0, mean(range(x))) ggplot(worldmap, aes(long, lat, group = group)) + geom_polygon(aes(fill = region), show.legend = FALSE) + coord_map( xlim = c(-120, 40), ylim = c(30, 90) ) # 相当于 (-120 + 40)/2 = -40 ggplot(worldmap, aes(long, lat, group = group)) + geom_polygon(aes(fill = region), show.legend = FALSE) + coord_map( xlim = c(-120, 40), ylim = c(30, 90), orientation = c(90, 0, -40) ) # 从西经 120 度到东经 40度 不同的看待 range(x) ggplot(worldmap, aes(long, lat, group = group)) + geom_polygon(aes(fill = region), show.legend = FALSE) + coord_map( xlim = c(-120, 40), ylim = c(30, 90), orientation = c(90, 0, -20) ) # 换观察角度 ggplot(worldmap, aes(long, lat, group = group)) + geom_polygon(aes(fill = region), show.legend = FALSE) + coord_map( xlim = c(-120, 40), ylim = c(30, 90), orientation = c(90, 0, 0) ) # 换投影坐标系 ggplot(worldmap, aes(long, lat, group = group)) + geom_polygon(aes(fill = region), show.legend = FALSE) + coord_map(&quot;ortho&quot;, xlim = c(-120, 40), ylim = c(30, 90) ) # 二者皆换 ggplot(worldmap, aes(long, lat, group = group)) + geom_polygon(aes(fill = region), show.legend = FALSE) + coord_map(&quot;ortho&quot;, xlim = c(-120, 40), ylim = c(30, 90), orientation = c(90, 0, 0) ) 9.1.2 美国各州犯罪率 美国各州的犯罪率数据 USArrests 准备数据集 crimes &lt;- data.frame(state = tolower(rownames(USArrests)), USArrests) crimesm &lt;- reshape2::melt(crimes, id = 1) head(crimesm) #&gt; state variable value #&gt; 1 alabama Murder 13.2 #&gt; 2 alaska Murder 10.0 #&gt; 3 arizona Murder 8.1 #&gt; 4 arkansas Murder 8.8 #&gt; 5 california Murder 9.0 #&gt; 6 colorado Murder 7.9 添加地图数据 library(maps) states_map &lt;- map_data(&quot;state&quot;) head(states_map) #&gt; long lat group order region subregion #&gt; 1 -87.46201 30.38968 1 1 alabama &lt;NA&gt; #&gt; 2 -87.48493 30.37249 1 2 alabama &lt;NA&gt; #&gt; 3 -87.52503 30.37249 1 3 alabama &lt;NA&gt; #&gt; 4 -87.53076 30.33239 1 4 alabama &lt;NA&gt; #&gt; 5 -87.57087 30.32665 1 5 alabama &lt;NA&gt; #&gt; 6 -87.58806 30.32665 1 6 alabama &lt;NA&gt; 绘图 ggplot(crimes, aes(map_id = state)) + geom_map(aes(fill = Murder), map = states_map) + expand_limits(x = states_map$long, y = states_map$lat) + coord_map() 图 7.6: 1973年美国各州的犯罪率数据 ggplot(crimesm, aes(map_id = state)) + geom_map(aes(fill = value), map = states_map) + expand_limits(x = states_map$long, y = states_map$lat) + facet_wrap(~variable) 图 9.1: 四类犯罪在各州的分布 9.1.3 斐济地震带 比较 viridis 和 Spectral 两块调色板，如图 9.2 所示，可见 Spectral 的可识别性高些 dat &lt;- as.data.frame(cbind(rep(1948 + seq(12), each = 12), rep(seq(12), 12), AirPassengers)) colnames(dat) &lt;- c(&quot;year&quot;, &quot;month&quot;, &quot;passengers&quot;) ggplot(data = dat, aes(as.factor(year), as.factor(month))) + geom_point(aes(colour = passengers), pch = 15, size = 8) + scale_colour_distiller(palette = &quot;Spectral&quot;) + labs(x = &quot;Year&quot;, y = &quot;Month&quot;) + theme_minimal() 图 9.2: viridis 和 Spectral对比 再举栗子，图9.3是正负例对比，其中好在哪里呢？这张图要表达美国黄石国家公园的老忠实泉间歇喷发的时间规律，那么好的标准就是层次分明，以突出不同颜色之间的时间差异。这个差异，还要看起来不那么费眼睛，越一目了然越好。 library(gridExtra) erupt &lt;- ggplot(faithfuld, aes(waiting, eruptions, fill = density)) + geom_raster() + scale_x_continuous(NULL, expand = c(0, 0)) + scale_y_continuous(NULL, expand = c(0, 0)) + theme(legend.position = &quot;none&quot;) erupt1 &lt;- erupt + scale_fill_gradientn(colours = gray.colors(7)) erupt2 &lt;- erupt + scale_fill_distiller(palette = &quot;Spectral&quot;) erupt3 &lt;- erupt + scale_fill_gradientn(colours = terrain.colors(7)) erupt4 &lt;- erupt grid.arrange(erupt1, erupt2, erupt3, erupt4, ncol = 2) 图 9.3: 美国黄石国家公园的老忠实泉 此处调用 RColorBrewer 中 Spectral 调色板，它本来只有11中颜色，通过 scale_colour_distiller 却可以把它映射到连续型数值变量 mag 上，发散型调色板本身的对比性也可以起到很好的区分度，如图 9.4 所示 FijiMap &lt;- map_data(&quot;worldHires&quot;, region = &quot;Fiji&quot;) ggplot(FijiMap, aes(x = long, y = lat)) + geom_map(map = FijiMap, aes(map_id = region), size = .2) + geom_point(data = quakes, aes(x = long, y = lat, colour = mag), pch = 16) + xlim(160, 195) + scale_colour_distiller(palette = &quot;Spectral&quot;) + scale_y_continuous(breaks = (-18:18) * 5) + coord_map(&quot;ortho&quot;, orientation = c(-10, 180, 0)) + labs(colour = &quot;Magnitude&quot;, x = &quot;Longitude&quot;, y = &quot;Latitude&quot;) + theme_minimal() 图 9.4: 斐济地震带 此外， colormap 包提供更加丰富的调色板，通过 scale_color_colormap 支持 ggplot2 绘图风格 9.1.4 美国各城镇失业率 # 数据来源 http://datasets.flowingdata.com/unemployment09.csv unemp &lt;- read.csv( file = &quot;http://datasets.flowingdata.com/unemployment09.csv&quot;, header = FALSE, stringsAsFactors = FALSE ) names(unemp) &lt;- c( &quot;id&quot;, &quot;state_fips&quot;, &quot;county_fips&quot;, &quot;name&quot;, &quot;year&quot;, &quot;?&quot;, &quot;?&quot;, &quot;?&quot;, &quot;rate&quot; ) unemp$county &lt;- tolower(gsub(&quot; County, [A-Z]{2}&quot;, &quot;&quot;, unemp$name)) unemp$state &lt;- gsub(&quot;^.*([A-Z]{2}).*$&quot;, &quot;\\\\1&quot;, unemp$name) county_df &lt;- map_data(&quot;county&quot;) names(county_df) &lt;- c(&quot;long&quot;, &quot;lat&quot;, &quot;group&quot;, &quot;order&quot;, &quot;state_name&quot;, &quot;county&quot;) county_df$state &lt;- state.abb[match(county_df$state_name, tolower(state.name))] county_df$state_name &lt;- NULL state_df &lt;- map_data(&quot;state&quot;) # Combine together choropleth &lt;- merge(county_df, unemp, by = c(&quot;state&quot;, &quot;county&quot;)) choropleth &lt;- choropleth[order(choropleth$order), ] choropleth$rate_d &lt;- cut(choropleth$rate, breaks = c(seq(0, 10, by = 2), 35)) library(ggthemes) ggplot(choropleth, aes(long, lat, group = group)) + geom_polygon(aes(fill = rate_d), colour = alpha(&quot;white&quot;, 1 / 4), size = 0.2) + geom_polygon(data = state_df, colour = &quot;white&quot;, fill = NA) + scale_fill_brewer(palette = &quot;PuRd&quot;) + labs( fill = &quot;ratio&quot;, title = &quot;ratio of unemployment by county, 2009&quot;, caption = &quot;data source: http://datasets.flowingdata.com/unemployment09.csv&quot; ) + coord_map(&quot;polyconic&quot;) + theme_map() 图 9.5: 2009年美国各城镇失业率 美国各地区失业率地图，配不同颜色， colormap 适合给静态图配色 9.2 空间数据对象 9.2.1 sp 空间数据对象，以类 sp 方式存储 (Pebesma and Bivand 2005) library(sp) crs = CRS(&quot;+init=epsg:28992&quot;) data(&quot;meuse&quot;) coordinates(meuse) &lt;- ~x+y proj4string(meuse) &lt;- crs class(meuse) #&gt; [1] &quot;SpatialPointsDataFrame&quot; #&gt; attr(,&quot;package&quot;) #&gt; [1] &quot;sp&quot; proj4string(meuse) #&gt; [1] &quot;+init=epsg:28992 +proj=sterea +lat_0=52.15616055555555 +lon_0=5.38763888888889 +k=0.9999079 +x_0=155000 +y_0=463000 +ellps=bessel +towgs84=565.2369,50.0087,465.658,-0.406857,0.350733,-1.87035,4.0812 +units=m +no_defs&quot; plot(meuse, axes = TRUE) 图 9.6: sp 对象 crs.longlat &lt;- CRS(&quot;+init=epsg:4326&quot;) meuse.longlat &lt;- spTransform(meuse, crs.longlat) plot(meuse.longlat, axes = TRUE) 图 9.7: sp 对象 library(maptools) #&gt; Checking rgeos availability: TRUE fname &lt;- system.file(&quot;shapes/sids.shp&quot;, package = &quot;maptools&quot;) p4s &lt;- CRS(&quot;+proj=longlat +datum=NAD27&quot;) nc &lt;- readShapePoly(fname, proj4string = p4s) #&gt; Warning: readShapePoly is deprecated; use rgdal::readOGR or sf::st_read plot(nc, axes = TRUE, col = grey(1 - nc$SID79 / 57)) # Trellis maps arrow &lt;- list(&quot;SpatialPolygonsRescale&quot;, layout.north.arrow(2), offset = c(-76, 34), scale = 0.5, which = 2 ) spplot(nc, c(&quot;SID74&quot;, &quot;SID79&quot;), as.table = TRUE, scales = list(draw = T), sp.layout = arrow ) maptools 提供的 readShapePoly 函数去读取 shp 文件的方式已经过时，推荐使用 rgdal::readOGR 或者 sf::st_read 方式读取 9.2.2 raster raster 包定义了获取和操作空间 raster 类型数据集的类和方法，rasterVis 补充加强了 raster 包在数据可视化和交互方面的功能。可视化是基于 lattice 的 raster 包的开发已经被作者 Robert J. Hijmans 迁移到 Github 上啦，官方文档 https://www.rspatial.org/ 星号 * 标记的是 S3 方法 methods(plot) #&gt; [1] plot,ANY,ANY-method #&gt; [2] plot,color,ANY-method #&gt; [3] plot,Spatial,missing-method #&gt; [4] plot,SpatialGrid,missing-method #&gt; [5] plot,SpatialGridDataFrame,missing-method #&gt; [6] plot,SpatialLines,missing-method #&gt; [7] plot,SpatialMultiPoints,missing-method #&gt; [8] plot,SpatialPixels,missing-method #&gt; [9] plot,SpatialPixelsDataFrame,missing-method #&gt; [10] plot,SpatialPoints,missing-method #&gt; [11] plot,SpatialPolygons,missing-method #&gt; [12] plot.acf* #&gt; [13] plot.data.frame* #&gt; [14] plot.decomposed.ts* #&gt; [15] plot.default #&gt; [16] plot.dendrogram* #&gt; [17] plot.density* #&gt; [18] plot.ecdf #&gt; [19] plot.factor* #&gt; [20] plot.formula* #&gt; [21] plot.function #&gt; [22] plot.ggplot* #&gt; [23] plot.gtable* #&gt; [24] plot.hcl_palettes* #&gt; [25] plot.hclust* #&gt; [26] plot.histogram* #&gt; [27] plot.HoltWinters* #&gt; [28] plot.isoreg* #&gt; [29] plot.lm* #&gt; [30] plot.medpolish* #&gt; [31] plot.mlm* #&gt; [32] plot.ppr* #&gt; [33] plot.prcomp* #&gt; [34] plot.princomp* #&gt; [35] plot.profile.nls* #&gt; [36] plot.R6* #&gt; [37] plot.raster* #&gt; [38] plot.shingle* #&gt; [39] plot.spec* #&gt; [40] plot.stepfun #&gt; [41] plot.stl* #&gt; [42] plot.table* #&gt; [43] plot.trellis* #&gt; [44] plot.ts #&gt; [45] plot.tskernel* #&gt; [46] plot.TukeyHSD* #&gt; see &#39;?methods&#39; for accessing help and source code 查看函数的定义 getAnywhere(plot.raster) #&gt; A single object matching &#39;plot.raster&#39; was found #&gt; It was found in the following places #&gt; registered S3 method for plot from namespace graphics #&gt; namespace:graphics #&gt; with value #&gt; #&gt; function (x, y, xlim = c(0, ncol(x)), ylim = c(0, nrow(x)), xaxs = &quot;i&quot;, #&gt; yaxs = &quot;i&quot;, asp = 1, add = FALSE, ...) #&gt; { #&gt; if (!add) { #&gt; plot.new() #&gt; plot.window(xlim = xlim, ylim = ylim, asp = asp, xaxs = xaxs, #&gt; yaxs = yaxs) #&gt; } #&gt; rasterImage(x, 0, 0, ncol(x), nrow(x), ...) #&gt; } #&gt; &lt;bytecode: 0x562774eee7e0&gt; #&gt; &lt;environment: namespace:graphics&gt; rasterImage 函数来绘制图像，如果想知道 rasterImage 的内容可以继续看 getAnywhere(rasterImage) getAnywhere(rasterImage) #&gt; A single object matching &#39;rasterImage&#39; was found #&gt; It was found in the following places #&gt; package:graphics #&gt; namespace:graphics #&gt; with value #&gt; #&gt; function (image, xleft, ybottom, xright, ytop, angle = 0, interpolate = TRUE, #&gt; ...) #&gt; { #&gt; .External.graphics(C_raster, if (inherits(image, &quot;nativeRaster&quot;)) image else as.raster(image), #&gt; as.double(xleft), as.double(ybottom), as.double(xright), #&gt; as.double(ytop), as.double(angle), as.logical(interpolate), #&gt; ...) #&gt; invisible() #&gt; } #&gt; &lt;bytecode: 0x562778eb8420&gt; #&gt; &lt;environment: namespace:graphics&gt; 通过查看函数的帮助 ?rasterImage ，我们需要重点关注一下 参数 image 传递的 raster 对象 plot(c(100, 250), c(300, 450), type = &quot;n&quot;, xlab = &quot;&quot;, ylab = &quot;&quot;) image &lt;- as.raster(matrix(0:1, ncol = 5, nrow = 3)) rasterImage(image, 100, 300, 150, 350, interpolate = FALSE) rasterImage(image, 100, 400, 150, 450) rasterImage(image, 200, 300, 200 + xinch(.5), 300 + yinch(.3), interpolate = FALSE ) rasterImage(image, 200, 400, 250, 450, angle = 15, interpolate = FALSE) 图 7.14: raster 图像 library(raster) #&gt; #&gt; Attaching package: &#39;raster&#39; #&gt; The following object is masked from &#39;package:magrittr&#39;: #&gt; #&gt; extract meuse.test &lt;- raster(x = system.file(&quot;external/test.grd&quot;, package=&quot;raster&quot;)) class(meuse.test) #&gt; [1] &quot;RasterLayer&quot; #&gt; attr(,&quot;package&quot;) #&gt; [1] &quot;raster&quot; plot(meuse.test, legend = F) 图 7.17: raster 对象 Edzer Pebesma 开发了 stars 包 # https://resources.rstudio.com/rstudio-conf-2019/spatial-data-science-in-the-tidyverse library(abind) library(sf) #&gt; Linking to GEOS 3.7.1, GDAL 2.4.0, PROJ 5.2.0 library(stars) x &lt;- system.file(&quot;tif/L7_ETMs.tif&quot;, package = &quot;stars&quot;) %&gt;% read_stars() ggplot() + geom_stars(data = x) + coord_equal() + facet_wrap(~band) + theme_void() + scale_fill_viridis_c() + scale_x_discrete(expand = c(0, 0)) + scale_y_discrete(expand = c(0, 0)) 9.2.3 sf nc &lt;- system.file(&quot;gpkg/nc.gpkg&quot;, package = &quot;sf&quot;) %&gt;% read_sf() nc2 &lt;- nc %&gt;% dplyr::select(SID74, SID79) %&gt;% tidyr::gather(VAR, SID, -geom) ggplot() + geom_sf(data = nc2, aes(fill = SID)) + facet_wrap(~VAR, ncol = 1) 参考文献 "],
["cs-cran-network.html", "第 10 章 案例：分析 CRAN 10.1 R 核心团队 10.2 高产的开发者 10.3 社区开发者 10.4 首次贡献 R 包 10.5 贡献关系网络 10.6 更新知多少 10.7 使用许可证 10.8 R 包增长速度 10.9 选择 R 包 10.10 运行环境", " 第 10 章 案例：分析 CRAN library(ggplot2) library(magrittr) options( ggplot2.continuous.colour = &quot;viridis&quot;, ggplot2.continuous.fill = &quot;viridis&quot; ) 首先我们从 CRAN 官网下载 R 包描述信息 pdb &lt;- tools::CRAN_package_db() 接着，我们可以看看CRAN 上发布的 R 包数量 length(pdb[, &quot;Package&quot;]) #&gt; [1] 14634 经过与官网发布的数据来对比，我们发现这里计算的结果与实际不符，多出来了几十个R包，所以我们再观察一下是否有重复的 R 包描述信息 pdb[, &quot;Package&quot;][duplicated(pdb[, &quot;Package&quot;])] #&gt; [1] &quot;boot&quot; &quot;class&quot; &quot;cluster&quot; &quot;codetools&quot; &quot;foreign&quot; #&gt; [6] &quot;KernSmooth&quot; &quot;lattice&quot; &quot;MASS&quot; &quot;Matrix&quot; &quot;mgcv&quot; #&gt; [11] &quot;nlme&quot; &quot;nnet&quot; &quot;rpart&quot; &quot;spatial&quot; &quot;survival&quot; 不难发现，果然有！所以去掉重复的 R 包信息，就是 CRAN 上实际发布的 R 包数量 dim(subset(pdb, subset = !duplicated(pdb[, &quot;Package&quot;])))[1] #&gt; [1] 14619 接下来就是分析去掉重复信息后的数据矩阵 pdb pdb &lt;- subset(pdb, subset = !duplicated(pdb[, &quot;Package&quot;])) 10.1 R 核心团队 R 核心团队除了维护开发 Base R 包以外，还开发了哪些 R 包，我们依据这些开发者邮箱 &lt;Firstname&gt;.&lt;Lastname&gt;@R-project.org 的特点，从数据集 pdb 中提取他们开发的 R 包 core_pdb &lt;- subset(pdb, subset = grepl( x = pdb[, &quot;Maintainer&quot;], pattern = &quot;(@R-project\\\\.org)&quot; ), select = c(&quot;Package&quot;, &quot;Maintainer&quot;) ) dim(core_pdb[order(core_pdb[, &quot;Maintainer&quot;]), ]) #&gt; [1] 94 2 这么少，是不是有点意外，看来很多大佬更喜欢用自己的邮箱，比如 Paul Murrell， 他的邮箱是 paul@stat.auckland.ac.nz subset(pdb, subset = grepl(x = pdb[, &quot;Maintainer&quot;], pattern = &quot;(Paul Murrell)&quot;), select = c(&quot;Package&quot;, &quot;Maintainer&quot;)) #&gt; Package Maintainer #&gt; 2000 compare Paul Murrell &lt;p.murrell@auckland.ac.nz&gt; #&gt; 5035 graphicsQC Paul Murrell &lt;paul@stat.auckland.ac.nz&gt; #&gt; 5067 gridBase Paul Murrell &lt;paul@stat.auckland.ac.nz&gt; #&gt; 5068 gridBezier Paul Murrell &lt;paul@stat.auckland.ac.nz&gt; #&gt; 5069 gridDebug Paul Murrell &lt;p.murrell@auckland.ac.nz&gt; #&gt; 5071 gridGeometry Paul Murrell &lt;paul@stat.auckland.ac.nz&gt; #&gt; 5072 gridGraphics Paul Murrell &lt;paul@stat.auckland.ac.nz&gt; #&gt; 5073 gridGraphviz Paul Murrell &lt;p.murrell@auckland.ac.nz&gt; #&gt; 5076 gridSVG Paul Murrell &lt;paul@stat.auckland.ac.nz&gt; .... 所以这种方式不行了，只能列举所有 R Core Team 成员，挨个去匹配，幸好 contributors() 函数已经收集了成员名单，不需要我们去官网找了。 core_team &lt;- read.table( text = &quot; Douglas Bates John Chambers Peter Dalgaard Robert Gentleman Kurt Hornik Ross Ihaka Tomas Kalibera Michael Lawrence Friedrich Leisch Uwe Ligges Thomas Lumley Martin Maechler Martin Morgan Paul Murrell Martyn Plummer Brian Ripley Deepayan Sarkar Duncan Temple Lang Luke Tierney Simon Urbanek Heiner Schwarte Guido Masarotto Stefano Iacus Seth Falcon Duncan Murdoch David Meyer Simon Wood &quot;, header = FALSE, sep = &quot;\\n&quot;, check.names = FALSE, stringsAsFactors = FALSE, colClasses = &quot;character&quot;, comment.char = &quot;&quot;, col.names = &quot;name&quot; ) R 核心团队维护的 R 包及其最新发布的日期 core_pdb &lt;- subset(pdb, subset = grepl( x = pdb[, &quot;Maintainer&quot;], pattern = paste(&quot;(&quot;, core_team$name, &quot;)&quot;, collapse = &quot;|&quot;, sep = &quot;&quot;) ), select = c(&quot;Package&quot;, &quot;Maintainer&quot;, &quot;Published&quot;) ) 清理 Maintainer 字段中的邮箱部分，方便表格展示 clean_maintainer &lt;- function(x) { # 去掉邮箱 x &lt;- gsub(&quot;&lt;([^&lt;&gt;]*)&gt;&quot;, &quot;&quot;, x) # 去掉 \\n \\t \\&#39; \\&quot; 和 &#39; x &lt;- gsub(&quot;(\\\\\\n)|(\\\\\\t)|(\\\\\\&quot;)|(\\\\\\&#39;)|(&#39;)&quot;, &quot;&quot;, x) # 去掉末尾空格 x &lt;- gsub(&quot; +$&quot;, &quot;&quot;, x) } core_pdb[, &quot;Maintainer&quot;] &lt;- clean_maintainer(core_pdb[, &quot;Maintainer&quot;]) 我们可以看到 R 核心团队总共开发维护有 170 个 R 包 dim(core_pdb) #&gt; [1] 170 3 篇幅所限，我们就展示部分人和R包，见表 10.1 按照拼音顺序 Brian Ripley 是第一位 knitr::kable(head(core_pdb[order( core_pdb[, &quot;Maintainer&quot;], core_pdb[, &quot;Published&quot;] ), ], 10), caption = &quot;R Core Team 维护的 R 包（展示部分）&quot;, booktabs = TRUE ) 表 10.1: R Core Team 维护的 R 包（展示部分） Package Maintainer Published 4505 gee Brian Ripley 2015-06-29 6225 KernSmooth Brian Ripley 2015-06-29 12592 spatial Brian Ripley 2015-08-30 8290 nnet Brian Ripley 2016-02-02 11161 RODBC Brian Ripley 2017-05-05 7473 mix Brian Ripley 2017-06-12 9785 pspline Brian Ripley 2017-06-12 1742 class Brian Ripley 2019-01-01 6986 MASS Brian Ripley 2019-04-26 13702 tree Brian Ripley 2019-04-26 分组计数，看看每个核心开发者维护的 R 包有多少 sort(table(core_pdb[, &quot;Maintainer&quot;]), decreasing = TRUE) #&gt; #&gt; Kurt Hornik Martin Maechler Simon Urbanek #&gt; 28 25 24 #&gt; Paul Murrell Brian Ripley Thomas Lumley #&gt; 18 12 9 #&gt; Uwe Ligges Duncan Murdoch Michael Lawrence #&gt; 9 7 7 #&gt; David Meyer Friedrich Leisch Luke Tierney #&gt; 6 5 5 #&gt; Douglas Bates John Chambers Simon Wood #&gt; 3 3 3 #&gt; Deepayan Sarkar Martyn Plummer Duncan Temple Lang #&gt; 2 2 1 #&gt; Peter Dalgaard #&gt; 1 10.2 高产的开发者 这些人的个人简介 接下来，我们再来查看一些比较高产的 R 包开发者谢益辉都维护了哪些R包，如表 10.2 所示 yihui_pdb &lt;- subset(pdb, subset = grepl(&quot;Yihui Xie&quot;, pdb[, &quot;Maintainer&quot;]), select = c(&quot;Package&quot;, &quot;Maintainer&quot;, &quot;Title&quot;) ) yihui_pdb[, &quot;Title&quot;] &lt;- gsub(&quot;(\\\\\\n)&quot;, &quot; &quot;, yihui_pdb[, &quot;Title&quot;]) knitr::kable(yihui_pdb, caption = &quot;谢益辉维护的 R Markdown 生态&quot;, booktabs = TRUE) 表 10.2: 谢益辉维护的 R Markdown 生态 Package Maintainer Title 296 animation Yihui Xie xie@yihui.name A Gallery of Animations in Statistics and Utilities to Create Animations 1135 blogdown Yihui Xie xie@yihui.name Create Blogs and Websites with R Markdown 1199 bookdown Yihui Xie xie@yihui.name Authoring Books and Technical Documents with R Markdown 3124 DT Yihui Xie xie@yihui.name A Wrapper of the JavaScript Library ‘DataTables’ 3675 evaluate Yihui Xie xie@yihui.name Parsing and Evaluation Tools that Provide More Details than the Default 4194 formatR Yihui Xie xie@yihui.name Format R Code Automatically 4311 fun Yihui Xie xie@yihui.name Use R for Fun 5382 highr Yihui Xie xie@yihui.name Syntax Highlighting for R Source Code 6276 knitr Yihui Xie xie@yihui.name A General-Purpose Package for Dynamic Report Generation in R 6970 markdown Yihui Xie xie@yihui.name Render Markdown with the C Library ‘Sundown’ 7405 mime Yihui Xie xie@yihui.name Map Filenames to MIME Types 7826 MSG Yihui Xie xie@yihui.name Data and Functions for the Book Modern Statistical Graphics 8780 pagedown Yihui Xie xie@yihui.name Paginate the HTML Output of R Markdown with CSS for Print 9641 printr Yihui Xie xie@yihui.name Automatically Print R Objects to Appropriate Formats According to the ‘knitr’ Output Format 10450 Rd2roxygen Yihui Xie xie@yihui.name Convert Rd to ‘Roxygen’ Documentation 11003 rmarkdown Yihui Xie xie@yihui.name Dynamic Documents for R 11191 rolldown Yihui Xie xie@yihui.name R Markdown Output Formats for Storytelling 11498 rticles Yihui Xie xie@yihui.name Article Formats for R Markdown 12000 servr Yihui Xie xie@yihui.name A Simple HTTP Server to Serve Static Files or Dynamic Documents 13398 testit Yihui Xie xie@yihui.name A Simple Package for Testing R Packages 13566 tinytex Yihui Xie xie@yihui.name Helper Functions to Install and Maintain ‘TeX Live’, and Compile ‘LaTeX’ Documents 13870 tufte Yihui Xie xie@yihui.name Tufte’s Styles for R Markdown Documents 14472 xaringan Yihui Xie xie@yihui.name Presentation Ninja 14479 xfun Yihui Xie xie@yihui.name Miscellaneous Functions by ‘Yihui Xie’ Jeroen Ooms 维护从 C++ 世界搬运进来的库，如图像处理 magick 包、 视频处理 av 包、 PDF 文档操作 qpdf 包 subset(pdb, subset = grepl(&quot;Jeroen Ooms&quot;, pdb[, &quot;Maintainer&quot;]), select = &#39;Package&#39;, drop = TRUE) #&gt; [1] &quot;antiword&quot; &quot;askpass&quot; &quot;av&quot; &quot;base64&quot; &quot;bcrypt&quot; #&gt; [6] &quot;brotli&quot; &quot;cld2&quot; &quot;cld3&quot; &quot;commonmark&quot; &quot;credentials&quot; #&gt; [11] &quot;curl&quot; &quot;gert&quot; &quot;gifski&quot; &quot;gpg&quot; &quot;graphql&quot; #&gt; [16] &quot;hunspell&quot; &quot;jenkins&quot; &quot;jose&quot; &quot;js&quot; &quot;jsonld&quot; #&gt; [21] &quot;jsonlite&quot; &quot;magick&quot; &quot;minimist&quot; &quot;mongolite&quot; &quot;opencpu&quot; #&gt; [26] &quot;opencv&quot; &quot;openssl&quot; &quot;pdftools&quot; &quot;protolite&quot; &quot;qpdf&quot; #&gt; [31] &quot;RAppArmor&quot; &quot;rjade&quot; &quot;RMySQL&quot; &quot;rsvg&quot; &quot;rzmq&quot; #&gt; [36] &quot;sodium&quot; &quot;spelling&quot; &quot;ssh&quot; &quot;sys&quot; &quot;tesseract&quot; #&gt; [41] &quot;unix&quot; &quot;unrtf&quot; &quot;V8&quot; &quot;webp&quot; &quot;webutils&quot; #&gt; [46] &quot;writexl&quot; &quot;xslt&quot; Dirk Eddelbuettel 维护 Rcpp 生态 subset(pdb, subset = grepl(&quot;Dirk Eddelbuettel&quot;, pdb[, &quot;Maintainer&quot;]), select = &#39;Package&#39;, drop = TRUE) #&gt; [1] &quot;anytime&quot; &quot;AsioHeaders&quot; &quot;BH&quot; #&gt; [4] &quot;binb&quot; &quot;dang&quot; &quot;digest&quot; #&gt; [7] &quot;drat&quot; &quot;gaussfacts&quot; &quot;gcbd&quot; #&gt; [10] &quot;gettz&quot; &quot;gunsales&quot; &quot;inline&quot; #&gt; [13] &quot;linl&quot; &quot;littler&quot; &quot;nanotime&quot; #&gt; [16] &quot;pinp&quot; &quot;pkgKitten&quot; &quot;prrd&quot; #&gt; [19] &quot;random&quot; &quot;RApiDatetime&quot; &quot;RApiSerialize&quot; #&gt; [22] &quot;Rblpapi&quot; &quot;Rcpp&quot; &quot;RcppAnnoy&quot; #&gt; [25] &quot;RcppAPT&quot; &quot;RcppArmadillo&quot; &quot;RcppBDT&quot; #&gt; [28] &quot;RcppCCTZ&quot; &quot;RcppClassic&quot; &quot;RcppClassicExamples&quot; #&gt; [31] &quot;RcppCNPy&quot; &quot;RcppDE&quot; &quot;RcppEigen&quot; #&gt; [34] &quot;RcppExamples&quot; &quot;RcppGetconf&quot; &quot;RcppGSL&quot; #&gt; [37] &quot;RcppMsgPack&quot; &quot;RcppNLoptExample&quot; &quot;RcppQuantuccia&quot; #&gt; [40] &quot;RcppRedis&quot; &quot;RcppSMC&quot; &quot;RcppStreams&quot; #&gt; [43] &quot;RcppTOML&quot; &quot;RcppXts&quot; &quot;RcppZiggurat&quot; #&gt; [46] &quot;RDieHarder&quot; &quot;rfoaas&quot; &quot;RInside&quot; #&gt; [49] &quot;rmsfact&quot; &quot;RProtoBuf&quot; &quot;RPushbullet&quot; #&gt; [52] &quot;RQuantLib&quot; &quot;RVowpalWabbit&quot; &quot;sanitizers&quot; #&gt; [55] &quot;tint&quot; &quot;x13binary&quot; Hadley Wickham 维护 tidyverse 生态 subset(pdb, subset = grepl(&quot;Hadley Wickham&quot;, pdb[, &quot;Maintainer&quot;]), select = &#39;Package&#39;, drop = TRUE) #&gt; [1] &quot;assertthat&quot; &quot;babynames&quot; &quot;bigrquery&quot; &quot;classifly&quot; #&gt; [5] &quot;clusterfly&quot; &quot;conflicted&quot; &quot;dbplyr&quot; &quot;dplyr&quot; #&gt; [9] &quot;ellipsis&quot; &quot;feather&quot; &quot;forcats&quot; &quot;fueleconomy&quot; #&gt; [13] &quot;ggplot2&quot; &quot;ggplot2movies&quot; &quot;gtable&quot; &quot;haven&quot; #&gt; [17] &quot;hflights&quot; &quot;httr&quot; &quot;lazyeval&quot; &quot;lobstr&quot; #&gt; [21] &quot;lvplot&quot; &quot;meifly&quot; &quot;modelr&quot; &quot;nasaweather&quot; #&gt; [25] &quot;nycflights13&quot; &quot;pkgdown&quot; &quot;plyr&quot; &quot;productplots&quot; #&gt; [29] &quot;profr&quot; &quot;proto&quot; &quot;pryr&quot; &quot;rappdirs&quot; #&gt; [33] &quot;reshape&quot; &quot;reshape2&quot; &quot;rggobi&quot; &quot;roxygen2&quot; #&gt; [37] &quot;rvest&quot; &quot;scales&quot; &quot;sloop&quot; &quot;stringr&quot; #&gt; [41] &quot;testthat&quot; &quot;tidyr&quot; &quot;tidyverse&quot; &quot;vctrs&quot; Scott Chamberlain 是非营利性组织 rOpenSci 的联合创始人，但是没几个 R 包听说过 subset(pdb, subset = grepl(&quot;Scott Chamberlain&quot;, pdb[, &quot;Maintainer&quot;]), select = &#39;Package&#39;, drop = TRUE) #&gt; [1] &quot;analogsea&quot; &quot;bold&quot; &quot;brranching&quot; &quot;ccafs&quot; &quot;charlatan&quot; #&gt; [6] &quot;ckanr&quot; &quot;conditionz&quot; &quot;cowsay&quot; &quot;crminer&quot; &quot;crul&quot; #&gt; [11] &quot;discgolf&quot; &quot;elastic&quot; &quot;etseed&quot; &quot;fauxpas&quot; &quot;finch&quot; #&gt; [16] &quot;fulltext&quot; &quot;geoaxe&quot; &quot;geojson&quot; &quot;geojsonio&quot; &quot;geojsonlint&quot; #&gt; [21] &quot;geoops&quot; &quot;getlandsat&quot; &quot;gistr&quot; &quot;handlr&quot; &quot;hoardr&quot; #&gt; [26] &quot;httpcode&quot; &quot;httping&quot; &quot;isdparser&quot; &quot;jaod&quot; &quot;jqr&quot; #&gt; [31] &quot;lawn&quot; &quot;mapr&quot; &quot;microdemic&quot; &quot;mregions&quot; &quot;natserv&quot; #&gt; [36] &quot;nodbi&quot; &quot;oai&quot; &quot;openadds&quot; &quot;originr&quot; &quot;pangaear&quot; #&gt; [41] &quot;phylocomr&quot; &quot;pleiades&quot; &quot;pubchunks&quot; &quot;randgeo&quot; &quot;rbhl&quot; #&gt; [46] &quot;rbison&quot; &quot;rbraries&quot; &quot;rcitoid&quot; &quot;rcoreoa&quot; &quot;rcrossref&quot; #&gt; [51] &quot;rdatacite&quot; &quot;rdpla&quot; &quot;rdryad&quot; &quot;request&quot; &quot;rerddap&quot; #&gt; [56] &quot;rgbif&quot; &quot;rif&quot; &quot;ritis&quot; &quot;rjsonapi&quot; &quot;rnoaa&quot; #&gt; [61] &quot;rnpn&quot; &quot;rorcid&quot; &quot;rphylopic&quot; &quot;rplos&quot; &quot;rredlist&quot; #&gt; [66] &quot;rsnps&quot; &quot;rvertnet&quot; &quot;scrubr&quot; &quot;seaaroundus&quot; &quot;sofa&quot; #&gt; [71] &quot;solrium&quot; &quot;spocc&quot; &quot;taxize&quot; &quot;taxizedb&quot; &quot;traits&quot; #&gt; [76] &quot;vcr&quot; &quot;webmockr&quot; &quot;wellknown&quot; &quot;wikitaxa&quot; &quot;worrms&quot; #&gt; [81] &quot;zbank&quot; 10.3 社区开发者 接下来，我们想看看 R 包维护者数量有多少 length(unique(pdb[, &quot;Maintainer&quot;])) #&gt; [1] 8629 可实际上没有这么多的开发者，因为存在这样的情况，以 R 包维护者 Hadley Wickham 为例，由于他曾使用过不同的邮箱，所以在维护者字段出现了不一致的情况，实际却是同一个人。 subset(pdb, subset = grepl(&quot;Hadley Wickham&quot;, pdb[, &quot;Maintainer&quot;]), select = c(&quot;Package&quot;, &quot;Maintainer&quot;) ) #&gt; Package Maintainer #&gt; 486 assertthat Hadley Wickham &lt;hadley@rstudio.com&gt; #&gt; 611 babynames Hadley Wickham &lt;hadley@rstudio.com&gt; #&gt; 968 bigrquery Hadley Wickham &lt;hadley@rstudio.com&gt; #&gt; 1747 classifly Hadley Wickham &lt;h.wickham@gmail.com&gt; #&gt; 1826 clusterfly Hadley Wickham &lt;h.wickham@gmail.com&gt; #&gt; 2070 conflicted Hadley Wickham &lt;hadley@rstudio.com&gt; #&gt; 2580 dbplyr Hadley Wickham &lt;hadley@rstudio.com&gt; #&gt; 3057 dplyr Hadley Wickham &lt;hadley@rstudio.com&gt; #&gt; 3416 ellipsis Hadley Wickham &lt;hadley@rstudio.com&gt; .... 因此，有必要先把 Maintainer 字段中的邮箱部分去掉，这样我们可以得到比较靠谱的R包维护者数量了！ pdb[, &quot;Maintainer&quot;] &lt;- clean_maintainer(pdb[, &quot;Maintainer&quot;]) length(unique(pdb[, &quot;Maintainer&quot;])) #&gt; [1] 7992 接下来，我们还想把 R 包维护者，按照其维护的R包数量排个序，用条形图10.1 表示 top_maintainer &lt;- head(sort(table(pdb[, &quot;Maintainer&quot;]), decreasing = TRUE), 20) par(mar = c(2, 7, 1, 1)) barCenters &lt;- barplot(top_maintainer, col = &quot;lightblue&quot;, axes = FALSE, axisnames = FALSE, horiz = TRUE, border = &quot;white&quot; ) text( y = barCenters, x = par(&quot;usr&quot;)[3], adj = 1, labels = names(top_maintainer), xpd = TRUE ) axis(1, labels = seq(0, 90, by = 10), at = seq(0, 90, by = 10), las = 1, col = &quot;gray&quot; ) grid() 图 10.1: 维护R包数量最多的20个人32 调用 ggplot2 包绘图要求输入的数据类型是 data.frame，所以我们首先将 top_maintainer 转化为数据框类型 top_maintainer &lt;- as.data.frame(top_maintainer) colnames(top_maintainer) &lt;- c(&quot;Maintainer&quot;, &quot;Freq&quot;) ggplot(top_maintainer) + geom_bar(aes(x = Maintainer, y = Freq), stat = &quot;identity&quot;) + coord_flip() + xlab(&quot;Maintainer&quot;) + ylab(&quot;Numbers of Package&quot;) 条形图在柱子很多的情况下，点线图是一种更加简洁的替代方式 ggplot(top_maintainer, aes(x = Freq, y = Maintainer)) + geom_segment(aes(x = 20, xend = Freq, yend = Maintainer), colour = &quot;grey50&quot;) + geom_point(size = 2, colour = &quot;red&quot;) + labs(x = &quot; # of Packages &quot;, y = &quot; Maintainer &quot;) 接下来，我们想看看开发者维护的 R 包数量的分布，仅从上图，我们知道有的人能维护 80 多个 R 包，总体的分布情况又是如何呢？如图所示，我们将纵轴刻度设置为 log 模式，随着开发的R包数量的增加，开发者人数是指数级递减，可见开发R包依然是一个门槛很高的工作！ barplot(table(table(pdb[, &quot;Maintainer&quot;])), col = &quot;lightblue&quot;, log = &quot;y&quot;, border = &quot;white&quot;, xlab = &quot;# of Packages&quot;, ylab = &quot;# of Maintainers (log)&quot;, panel.first = grid() ) 只开发一个 R 包的人数达到 5276 人，占开发者总数的 67.31%，约为2/3。 10.4 首次贡献 R 包 我们还想进一步了解这些人是不是就自己开发自己维护，基本没有其他人参与，答案是 Almost Sure. 这些人其实占了大部分，相比于前面的 R 核心开发团队或者 R Markdown 生态的维护者，他们绝大部分属于金字塔底部的人，二八定律似乎在这里再次得到印证。 sub_pdb &lt;- subset(pdb, select = c(&quot;Package&quot;, &quot;Maintainer&quot;, &quot;Author&quot;)) 接着先清理一下 Maintainer 和 Author 字段，Author 字段的内容比起 Maintainer 复杂一些 clean_author &lt;- function(x) { # 去掉中括号及其内容 [aut] [aut, cre] x &lt;- gsub(&quot;(\\\\[.*?\\\\])&quot;, &quot;&quot;, x) # 去掉小括号及其内容 () x &lt;- gsub(&quot;(\\\\(.*?\\\\))&quot;, &quot;&quot;, x) # 去掉尖括号及其内容 &lt; &gt; x &lt;- gsub(&quot;(&lt;.*?&gt;)&quot;, &quot;&quot;, x) # 去掉 \\n x &lt;- gsub(&quot;(\\\\\\n)&quot;, &quot;&quot;, x) # 去掉制表符、双引号、单引号和 \\&#39;，如 &#39;Hadley Wickham&#39; 中的单引号 &#39; 等 x &lt;- gsub(&quot;(\\\\\\t)|(\\\\\\&quot;)|(\\\\\\&#39;)|(&#39;)|(\\\\))&quot;, &quot;&quot;, x) # Christian P. Robert, Universite Paris Dauphine, and Jean-Michel\\n Marin, Universite Montpellier 2 x &lt;- gsub(&quot;(and)&quot;, &quot;&quot;, x) # 两个以上的空格替换为一个空格 x &lt;- gsub(&quot;( {2,})&quot;,&quot; &quot;,x) x } sub_pdb[, &quot;Maintainer&quot;] &lt;- clean_maintainer(sub_pdb[, &quot;Maintainer&quot;]) sub_pdb[, &quot;Author&quot;] &lt;- clean_author(sub_pdb[, &quot;Author&quot;]) 维护多个 R 包的开发者数量 length(unique(sub_pdb[, &quot;Maintainer&quot;][duplicated(sub_pdb[, &quot;Maintainer&quot;])])) #&gt; [1] 2603 总的开发者中去掉开发了多个R包的人，就剩下只维护1个R包的开发者，共有 first_ctb &lt;- setdiff( sub_pdb[, &quot;Maintainer&quot;][!duplicated(sub_pdb[, &quot;Maintainer&quot;])], unique(sub_pdb[, &quot;Maintainer&quot;][duplicated(sub_pdb[, &quot;Maintainer&quot;])]) ) 按照每个R包贡献者的数量分组，如图所示，有一个或者没有贡献者的占总数占 70.60%，说明这些 R 包的开发者基本在单干，有 4 个及以下的贡献者占总数（这个总数是指只开发了一个R包的那些开发者）的 90.85%。 ctb_num &lt;- unlist( lapply( strsplit( subset(sub_pdb, subset = sub_pdb[, &quot;Maintainer&quot;] %in% first_ctb, select = &quot;Author&quot;, drop = TRUE # drop out data.frame return vector ), split = &quot;,&quot; ), length ) ) hist(ctb_num, col = &quot;lightblue&quot;, border = &quot;white&quot;, probability = TRUE, labels = TRUE, xlab = &quot;# of Contributors&quot;, ylab = &quot;Proportion&quot;, main = &quot;&quot;, panel.first = grid(), xlim = c(0, 10)) 这些基本单干的R包开发者是否参与其它 R 包的贡献？如果不参与，则他们对社区的贡献非常有限，仅限于为社区带来数量上的堆积！ table(ctb_num) #&gt; ctb_num #&gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #&gt; 2663 1118 695 417 178 109 72 47 25 24 7 8 4 4 3 #&gt; 16 17 18 19 21 22 37 #&gt; 3 3 2 2 2 2 1 有意思的是，有一个开发者虽然只开发了一个 R 包，但是却引来37位贡献者（包括开发者本人在内），下面把这个颇受欢迎的 R 包找出来 # 找到开发者 first_ctb[which.max(ctb_num)] #&gt; [1] &quot;Matt Dowle&quot; # 找到 R 包 subset(sub_pdb, subset = grepl(&quot;Matt Dowle&quot;, sub_pdb[, &quot;Maintainer&quot;]), select = &quot;Package&quot;) #&gt; Package #&gt; 2502 data.table 哇，大名鼎鼎的 data.table 包！！ I JUST find it!! 这是个异数，我们知道 data.table 在R社区享有盛名，影响范围很广，从 Matt Dowle 的 Github 主页 来看，他确实只开发了这一个 R 包！黑天鹅在这里出现了！如果按照谁的贡献者多谁影响力大的规律来看，有 10 个以上贡献者的其它几个 R 包也必定是名器！这里留给读者把它找出来吧！ 10.5 贡献关系网络 接下来进入本节最核心的部分，分析所有的开发者之间的贡献网络，在第10.4节清理 Author 字段的正则表达式几乎不可能覆盖到所有的情况，所以既然 Maintainer 字段是比较好清理的，不妨以它作为匹配的模式去匹配 Author 字段，这样做的代价就是迭代次数会很多，增加一定的计算负担，但是为了更加准确的清理结果，也是拼了！ net_pdb &lt;- subset(pdb, select = c(&quot;Maintainer&quot;, &quot;Author&quot;)) net_pdb[, &quot;Maintainer&quot;] &lt;- clean_maintainer(net_pdb[, &quot;Maintainer&quot;]) total_maintainer &lt;- unique(net_pdb[, &quot;Maintainer&quot;]) clean_author &lt;- function(maintainer) { sapply(net_pdb[, &quot;Author&quot;], grepl, pattern = paste0(&quot;(&quot;, maintainer, &quot;)&quot;)) } 接下来是非常耗时的一步，实际是两层循环 1.2 亿次左右的查找计算， grepl 耗时 30分钟左右，正则表达式本身的性能优化问题，maintainer_author 逻辑型矩阵占用内存空间 430 M 左右 maintainer_author &lt;- Reduce(&quot;cbind&quot;, lapply(total_maintainer, clean_author)) colnames(maintainer_author) &lt;- total_maintainer rownames(maintainer_author) &lt;- net_pdb[, &quot;Maintainer&quot;] 为了重复运行这段耗时很长的代码，我们将中间结果保存到磁盘，推荐保存为 R 支持的序列化后的数据格式 *.rds，相比于 *.csv 格式能极大地减少磁盘存储空间，读者可运行下面两行保存数据的代码，比较看看！ saveRDS(maintainer_author, file = &quot;data/maintainer_author.rds&quot;) write.table(maintainer_author,file = &quot;data/maintainer_author.csv&quot;, row.names = TRUE, col.names = TRUE) 查看 maintainer_author 数据集占用内存空间的大小 format(object.size(maintainer_author), units = &quot;auto&quot;) #&gt; [1] &quot;430.5 Mb&quot; 看几个数字，R 包贡献者最多的有 62 人,这个 R 包的粉丝是真多！有一个开发者对 137 个 R 包的做出过贡献，其中包括自己开发的 R 包，快来快来抓住他！ max(rowSums(maintainer_author)) #&gt; [1] 62 max(colSums(maintainer_author)) #&gt; [1] 137 继续看看每个开发者对外贡献的量的分布情况，由图可知，绝大部分开发者对外输出不超过 3，其表示对其它 R 包的贡献不超过 3个 hist(colSums(maintainer_author)[colSums(maintainer_author) &lt;= 10], probability = FALSE, xlab = &quot;&quot;, main = &quot;&quot;) 每个 R 包参与贡献的人数分布又是如何呢？如图所示，基本集中在1~2个人的样子 hist(rowSums(maintainer_author)[rowSums(maintainer_author) &lt;= 20], xlab = &quot;&quot;, main = &quot;&quot;,probability = FALSE) 好了，接下来我们要深入挖掘贡献协作网络中的结构特点，看看是不是由几位领导人在完全掌控，还有一大群人其实是自己搞自己的那点事，写论文、发布 R 包、投稿等如此循环。其实这就是 R 社区的特点，也决定了它不会像 Python 那样应用性强，有足够多的工程开发人员加入。大多数人写 R 包只是为了配合发论文而已，并不关心有没有人来用自己的 R 包！此外，没有人来做功能整合和持续维护，所以发展缓慢！各自造轮子的事情太多！ 接着，先从表面看看开发者和贡献者的关系矩阵，maintainer_author 是一个大型的超稀疏矩阵，非零元素最多的行、列分别只占 0.79% 和 0.95%，都不到百分之一。 # 非零元素最多的行 max(rowMeans(maintainer_author)) #&gt; [1] 0.007904131 # 非零元素最多的列 max(colMeans(maintainer_author)) #&gt; [1] 0.009548369 用稀疏索引的方式重新编码矩阵，然后用社群检测的算法找到其中的结构，网络关系图用 Gephi 画，igraph 肯定是不行了，参考文献 社会网络分析：探索人人网好友推荐系统 网络的统计建模分析31 重新获取 maintainer_author 矩阵，存储指标向量，然后调用 Matrix 生成稀疏矩阵，后续的数据操作就好办了，因为 Matrix 包是内置的，它定义的稀疏矩阵类其它 R 包也都支持。先以一个简单的例子说明构造稀疏矩阵的过程 library(Matrix) spM &lt;- spMatrix(3, 4, i = c(1, 1, 2, 3, 3), j = c(4, 1, 2, 1, 3), x = c(4, 4, 1, 4, 8)) spM #&gt; 3 x 4 sparse Matrix of class &quot;dgTMatrix&quot; #&gt; #&gt; [1,] 4 . . 4 #&gt; [2,] . 1 . . #&gt; [3,] 4 . 8 . image(spM) i 和 j 表示矩阵中有值的位置，x 表示对应位置上的值，i，j 和 x 是三个长度相等的数值型向量，我们还可以调用 image函数，把稀疏矩阵可视化出来，对于大型稀疏矩阵可视化其稀疏模式是重要的。 贡献网络可视化 clean_net_pdb &lt;- function(maintainer) { index &lt;- clean_author(maintainer) if (sum(index) == 0) { return(NULL) } data.frame( from_id = maintainer, to_id = net_pdb[, &quot;Maintainer&quot;][index], stringsAsFactors = FALSE ) } # maintainer_author &lt;- data.table::rbindlist(lapply(total_maintainer, clean_net_pdb)) # saveRDS(maintainer_author, file = &quot;data/maintainer_author.rds&quot;) toc &lt;- system.time({ maintainer_author_net &lt;- Reduce(&quot;rbind&quot;, lapply(total_maintainer, clean_net_pdb)) }, gcFirst = TRUE) 分组统计开发者之间贡献次数，从开发者到 maintainer_author_net$weight &lt;- 1 edges &lt;- aggregate(weight ~ from_id + to_id, data = maintainer_author_net, sum) dup_edges &lt;- edges[edges[, 1] != edges[, 2], ] library(geomnet) ggplot(data = dup_edges, aes(from_id = from_id, to_id = to_id)) + geom_net(aes(linewidth = weight), layout.alg = &quot;kamadakawai&quot;, labelon = FALSE, directed = TRUE, show.legend = FALSE, ealpha = 1, ecolour = &quot;grey70&quot;, arrowsize = 0.1, size = 0.5 ) + theme_net() # https://smallstats.blogspot.jp/2012/12/loading-huge-graphs-with-igraph-and-r.html library(igraph) # 贡献矩阵 ctb_df &lt;- graph.data.frame(maintainer_author, directed = TRUE) vertex.attrs &lt;- list(name = unique(c(ctb_df$from_id, ctb_df$to_id))) edges &lt;- rbind( match(ctb_df$from_id, vertex.attrs$name), match(ctb_df$to_id, vertex.attrs$name) ) ctb_net &lt;- graph.empty(n = 0, directed = T) ctb_net &lt;- add.vertices(ctb_net, length(vertex.attrs$name), attr = vertex.attrs) ctb_net &lt;- add.edges(ctb_net, edges) 10.6 更新知多少 这节标题取其字面意思表达 CRAN 服务器的特殊日子 2012-10-29，那天 CRAN 更新了一大波 R 包，像一根擎天柱一样支撑这幅图！ update_pdb &lt;- as.data.frame(pdb[, c(&quot;Package&quot;, &quot;Published&quot;)], stringsAsFactors = FALSE) # 这天要更新的R包最多 sort(table(update_pdb[,&quot;Published&quot;]), decreasing = TRUE)[1] #&gt; 2012-10-29 #&gt; 130 ggplot(update_pdb, aes(as.Date(Published))) + geom_bar(color = &quot;skyblue4&quot;) + geom_line( data = data.frame( date = as.Date(c(&quot;2011-01-01&quot;, &quot;2012-10-20&quot;)), count = c(80, 100) ), aes(x = date, y = count), arrow = arrow(angle = 15, length = unit(0.15, &quot;inches&quot;)) ) + annotate(&quot;text&quot;, x = as.Date(&quot;2010-11-01&quot;), y = 75, label = &quot;(2012-10-29,130)&quot;) + scale_x_date(date_breaks = &quot;1 year&quot;, date_labels = &quot;%Y&quot;) + labs(x = &quot;Published Date&quot;, y = &quot;Count&quot;) + theme_minimal() 当日发布的R包，不论是新增还是更新之前发布的R包都视为最新版，当日之前的都是旧版本，它们可能存在已经修复的 BUG！这句子好奇怪是吧，因为很多 R 包要么托管在 Github 上，要么托管在 R-Forge 上开发，而 CRAN 上的版本除了发布日外，一般来讲都会落后。如图所示待更新的 R 包在日期上的分布，有的已经10来年没有更新了，最老的 R 包可以追溯到 2006-03-15，它是 coxrobust！！ 10.7 使用许可证 列举 R 社区使用的许可证及其区别和联系 R 开源还体现在许可证信息，顺便谈谈美国和中国技术封锁，开源社区可能面临的风险 社区主要使用 GPL 及其相关授权协议，因为 R 软件本身也是授权在 GPL-2 或 GPL-3 下 license_pdb &lt;- head(sort(table(pdb[, &quot;License&quot;]), decreasing = TRUE), 20) par(mar = c(2, 12, 0.5, 0)) plot(c(1, 1e1, 1e2, 1e3, 1e4), c(1, 5, 10, 15, 20), type = &quot;n&quot;,panel.first = grid(), ann = FALSE, log = &quot;x&quot;, axes = FALSE ) axis(1, at = c(1, 1e1, 1e2, 1e3, 1e4), labels = expression(1, 10^1, 10^2, 10^3, 10^4) ) text( y = seq(length(license_pdb)), x = 1, cex = 1, offset = 1, pos = 2, labels = names(license_pdb), xpd = TRUE ) text(1e3, 15, &quot;CRAN&quot;) segments(x0 = 1, y0 = seq(length(license_pdb)), x1 = license_pdb, y1 = seq(length(license_pdb)), col = &quot;lightblue&quot;, lwd = 4) rforge_pdb &lt;- available.packages(repos = &quot;http://R-Forge.R-project.org&quot;) license_rforge_pdb &lt;- head(sort(table(rforge_pdb[, &quot;License&quot;]), decreasing = TRUE), 20) par(mar = c(2, 12, 0.5, 0)) plot(c(1, 1e1, 1e2, 1e3), seq(from = 1, to = 20,length.out = 4), type = &quot;n&quot;,panel.first = grid(), ann = FALSE, log = &quot;x&quot;, axes = FALSE ) axis(1, at = c(1, 1e1, 1e2, 1e3), labels = expression(1, 10^1, 10^2, 10^3) ) text( y = seq(length(license_rforge_pdb)), x = 1, cex = 1, offset = 1, pos = 2, labels = names(license_rforge_pdb), xpd = TRUE ) text(1e2, 15, &quot;R-Forge&quot;) segments(x0 = 1, y0 = seq(length(license_rforge_pdb)), x1 = license_rforge_pdb, y1 = seq(length(license_rforge_pdb)), lwd = 4, col = &quot;lightblue&quot;) 改进的方向是含义相同的进行合并，这需要研究一下各个许可证，然后使用对比型条形图合并上面两个图 CRAN 会检测 R 包的授权，只有授权协议包含在数据库中的才可以在 CRAN 上发布 https://svn.r-project.org/R/trunk/share/licenses/license.db 10.8 R 包增长速度 # 抓取网页数据 library(rvest) library(dplyr) library(zoo) url &lt;- &quot;https://cran.r-project.org/web/packages/available_packages_by_date.html&quot; page &lt;- read_html(url) page %&gt;% html_node(&quot;table&quot;) %&gt;% html_table() %&gt;% mutate(count = rev(1:nrow(.))) %&gt;% mutate(Date = as.Date(Date)) %&gt;% mutate(Month = format(Date, format = &quot;%Y-%m&quot;)) %&gt;% group_by(Month) %&gt;% summarise(published = min(count)) %&gt;% mutate(Date = as.Date(as.yearmon(Month))) -&gt; pkgs # 计算自2013年以来R包增长速度 pkgs %&gt;% filter(Date &gt; as.Date(&quot;2012-12-31&quot;)) %&gt;% mutate(publishedGrowth = c(tail(.$published, -1), NA) / published) %&gt;% mutate(counter = 1:nrow(.)) -&gt; new_pkgs # 绘图 library(ggplot2) library(grid) gg &lt;- ggplot(pkgs, aes(x = Date, y = published)) + geom_line(size = 1.5) + scale_y_log10( breaks = c(0, 10, 100, 1000, 10000), labels = c(&quot;1&quot;, &quot;10&quot;, &quot;100&quot;, &quot;1.000&quot;, &quot;10.000&quot;) ) + labs( x = &quot;&quot;, y = &quot;# Packages (log)&quot;, title = &quot;Packages published on CRAN ever since&quot; ) + theme_minimal(base_size = 14, base_family = &quot;sans&quot;) + theme(panel.grid.major.x = element_blank()) + geom_hline(yintercept = 0, size = 1, colour = &quot;#535353&quot;) gg2 &lt;- ggplot(new_pkgs, aes(x = Date, y = published)) + geom_line(size = 1) + geom_line( data = new_pkgs, aes(y = (min(published) * 1.048^counter)), color = &quot;red&quot;, size = .7, linetype = 1 ) + annotate(&quot;segment&quot;, x = as.Date(&quot;2015-04-01&quot;), xend = as.Date(&quot;2015-08-01&quot;), y = 1000, yend = 1000, colour = &quot;red&quot;, size = 1 ) + annotate(&quot;text&quot;, x = as.Date(&quot;2016-12-01&quot;), y = 1000, label = &quot;4.6% growth estimation&quot;, size = 3.5 ) + scale_y_continuous( breaks = seq(from = 0, to = 12000, by = 2000), labels = seq(from = 0, to = 12000, by = 2000) ) + labs(y = &quot;# Packages&quot;, x = &quot;&quot;, subtitle = &quot;Packages published on CRAN since 2013&quot;) + theme_minimal( base_size = 11, base_family = &quot;sans&quot; ) + theme(panel.grid.major.x = element_blank()) + geom_hline(yintercept = 0, size = .6, colour = &quot;#535353&quot;) gg print(gg2, vp = viewport(.70, .31, .43, .43)) 10.9 选择 R 包 R 社区开发的 R 包实在太多了，重复造的轮子也很多，哪个轮子结实好用就选哪个，挑选合适的 R 包 install.packages(&quot;formattable&quot;) devtools::install_github(&quot;ropenscilabs/packagemetrics&quot;) library(formattable) library(packagemetrics) library(dplyr) address &lt;- sprintf(&quot;%s/web/packages/packages.rds&quot;, getOption(&quot;repos&quot;)[&quot;CRAN&quot;]) con &lt;- url(address, &quot;rb&quot;) pdb &lt;- as.data.frame(readRDS(gzcon(con)), stringsAsFactors = FALSE) close(con) packages &lt;- subset(pdb, Maintainer == maintainer(&quot;rmarkdown&quot;), select = &quot;Package&quot;) pd &lt;- apply(packages, 1, combine_metrics) %&gt;% data.table::rbindlist() %&gt;% select( package, published, dl_last_month, stars, forks, last_commit, depends_count, watchers ) %&gt;% mutate(last_commit = round(last_commit, 1)) pd[is.na(pd)] &lt;- &quot;&quot; formattable(pd, list( package = formatter(&quot;span&quot;, style = x ~ style(font.weight = &quot;bold&quot;) ), contributors = color_tile(&quot;white&quot;, &quot;#1CC2E3&quot;), depends_count = color_tile(&quot;white&quot;, &quot;#1CC2E3&quot;), reverse_count = color_tile(&quot;white&quot;, &quot;#1CC2E3&quot;), tidyverse_happy = formatter(&quot;span&quot;, style = x ~ style(color = ifelse(x, &quot;purple&quot;, &quot;white&quot;)), x ~ icontext(ifelse(x, &quot;glass&quot;, &quot;glass&quot;)) ), vignette = formatter(&quot;span&quot;, style = x ~ style(color = ifelse(x, &quot;green&quot;, &quot;white&quot;)), x ~ icontext(ifelse(x, &quot;ok&quot;, &quot;ok&quot;)) ), has_tests = formatter(&quot;span&quot;, style = x ~ style(color = ifelse(x, &quot;green&quot;, &quot;red&quot;)), x ~ icontext(ifelse(x, &quot;ok&quot;, &quot;remove&quot;)) ), dl_last_month = color_bar(&quot;#56A33E&quot;), forks = color_tile(&quot;white&quot;, &quot;#56A33E&quot;), stars = color_tile(&quot;white&quot;, &quot;#56A33E&quot;), last_commit = color_tile(&quot;#F06B13&quot;, &quot;white&quot;, na.rm = T) )) webshot::webshot(url = &quot;http://localhost:16977/session/viewhtml150c673821fc/index.html&quot;,file = &quot;figures/packages.png&quot;) 10.10 运行环境 xfun::session_info() #&gt; R version 3.6.1 (2019-07-05) #&gt; Platform: x86_64-pc-linux-gnu (64-bit) #&gt; Running under: Debian GNU/Linux 10 (buster) #&gt; #&gt; Locale: #&gt; LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C #&gt; LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 #&gt; LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 #&gt; LC_PAPER=en_US.UTF-8 LC_NAME=C #&gt; LC_ADDRESS=C LC_TELEPHONE=C #&gt; LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C #&gt; #&gt; Package version: #&gt; assertthat_0.2.1 backports_1.1.4 base64enc_0.1.3 #&gt; BH_1.69.0.1 bookdown_0.12 cli_1.1.0 #&gt; codetools_0.2-16 colorspace_1.4-1 compiler_3.6.1 #&gt; crayon_1.3.4 curl_4.0 digest_0.6.20 #&gt; dplyr_0.8.3 ellipsis_0.2.0.1 evaluate_0.14 #&gt; fansi_0.4.0 ggplot2_3.2.0 glue_1.3.1 #&gt; graphics_3.6.1 grDevices_3.6.1 grid_3.6.1 #&gt; gtable_0.3.0 highr_0.8 htmltools_0.3.6 #&gt; jsonlite_1.6 knitr_1.23 labeling_0.3 #&gt; lattice_0.20-38 lazyeval_0.2.2 magrittr_1.5 #&gt; markdown_1.0 MASS_7.3.51.4 Matrix_1.2-17 #&gt; methods_3.6.1 mgcv_1.8.28 mime_0.7 #&gt; munsell_0.5.0 nlme_3.1.140 pillar_1.4.2 #&gt; pkgconfig_2.0.2 plogr_0.2.0 plyr_1.8.4 #&gt; purrr_0.3.2 R6_2.4.0 RColorBrewer_1.1.2 #&gt; Rcpp_1.0.2 reshape2_1.4.3 rlang_0.4.0 #&gt; rmarkdown_1.14 scales_1.0.0 splines_3.6.1 #&gt; stats_3.6.1 stringi_1.4.3 stringr_1.4.0 #&gt; tibble_2.1.3 tidyselect_0.2.5 tinytex_0.14 #&gt; tools_3.6.1 utf8_1.1.4 utils_3.6.1 #&gt; vctrs_0.2.0 viridisLite_0.3.0 withr_2.1.2 #&gt; xfun_0.8 yaml_2.2.0 zeallot_0.1.0 "],
["99-references.html", "参考文献", " 参考文献 "]
]
