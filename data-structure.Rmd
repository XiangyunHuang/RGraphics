# 数据结构 {#chap:data-structure}

> The trouble with nonstandard evaluation is that it doesn't follow standard
evaluation rules...
>
>   --- Peter Dalgaard (about nonstandard evaluation in the curve() function)
      R-help (June 2011)

<!-- 详细介绍 data.frame 和 data.table，而不简略介绍 tibble 和 dplyr -->

向量，列表，

数据框 data frame 在 R 里面可以用三种不同类型的数据对象来表达

> 从历史脉络来看，为什么会出现三种不同的东西，它们之间的区别和联系是什么，能否用一张表来描述

data.frame 设计的历史，首次包含在 R 里面是什么时候，R 是否一发布就包含了这个数据类型

The function `data.frame()` creates data frames, tightly coupled collections of variables which share many of the properties of matrices and of lists, used as the fundamental data structure by most of R's modeling software.

**data.table** 2006 年 4 月 15 日首次登陆 CRAN 发布 1.0 版本，差不多恰好 10 年后

**tibble** 在 2016 年 3 月 23 日首次登陆 CRAN 发布 1.0 版本

`data.frame()`， `tibble()` 和 `data.table()` 的区别，去看函数的帮助文档

Provides a 'tbl_df' class (the 'tibble') that provides stricter checking and better formatting than the traditional data frame.

[vctrs](https://github.com/r-lib/vctrs) 和 [rlang](https://github.com/r-lib/rlang) 包
R 内置的 [R Language Definition](https://cran.r-project.org/doc/manuals/r-release/R-lang.html)


## 类型 {#subsec:typeof}

```{r}
x <- "abc" # 数据对象
typeof(x) # 数据类型
mode(x) # 存储模式
storage.mode(x) # 存储类型
```


Table: (\#tab:all-data-type) 函数 `typeof()` 返回的数据类型 [^note]

| 符号          | 含义                     |
| :------------ | :----------------------- |
| `NULL`        | 空值                     |
| `symbol`      | 可变的名称/变量          |
| `pairlist`    | pairlist 对象***         |
| `closure`     | 函数闭包                 |
| `environment` | 环境                     |
| `promise`     | 实现惰性求值的对象       |
| `language`    | R 语言构造               |
| `special`     | 内部函数，不计算参数     |
| `builtin`     | 内部函数，计算参数       |
| `char`        | scalar 型字符对象***     |
| `logical`     | 逻辑向量                 |
| `integer`     | 整数向量                 |
| `double`      | 实值向量                 |
| `complex`     | 复值向量                 |
| `character`   | 字符向量                 |
| `...`         | 可变长度的参数***        |
| `any`         | 匹配任意类型             |
| `expression`  | 表达式对象               |
| `list`        | 列表                     |
| `bytecode`    | 位代码***                |
| `externalptr` | 外部指针对象             |
| `weakref`     | 弱引用对象               |
| `raw`         | 位向量                   |
| `S4`          | S4 对象                  |

[^note]: 表格中带 *** 标记的类型，用户不能轻易获得




Table: (\#tab:basic-data-type) R/Rcpp 提供的基本数据类型

|  Value   |  R vector   |            Rcpp vector             |            Rcpp matrix             | Rcpp scalar | C++ scalar |
| :------: | :---------: | :--------------------------------: | :--------------------------------: | :---------: | :--------: |
| Logical  |  `logical`  |          `LogicalVector`           |          `LogicalMatrix`           |      -      |   `bool`   |
| Integer  |  `integer`  |          `IntegerVector`           |          `IntegerMatrix`           |      -      |   `int`    |
|   Real   |  `numeric`  |          `NumericVector`           |          `NumericMatrix`           |      -      |  `double`  |
| Complex  |  `complex`  |          `ComplexVector`           |          `ComplexMatrix`           | `Rcomplex`  | `complex`  |
|  String  | `character` | `CharacterVector` (`StringVector`) | `CharacterMatrix` (`StringMatrix`) |  `String`   |  `string`  |
|   Date   |   `Date`    |            `DateVector`            |                 -                  |   `Date`    |     -      |
| Datetime |  `POSIXct`  |          `DatetimeVector`          |                 -                  | `Datetime`  |  `time_t`  |

## 日期 {#subsec:date-time}


注意观察时间转化

```{r}
Sys.Date()
Sys.time()
c(Sys.time(), Sys.Date())
data.table::year(Sys.Date())
data.table::year(Sys.time())
data.table::year(c(Sys.time(), Sys.Date()))
```

```{r}
x <- Sys.time()
class(x)
format(x, format = "%Y-%m-%d")
```

::: rmdnote

```{r}
x <- c("2019-12-21", "2019/12/21")
data.table::year("2019-12-21")
data.table::year("2019/12/21")
```

但是，下面这样会报错

```{r,error=TRUE}
data.table::year(x)
```

正确的姿势是首先将表示日期的字符串格式统一

```{r}
gsub(pattern = "/", replacement = "-", x) %>% 
  data.table::year()
```

:::

date-times 表示 POSIXct 和 POSIXlt 类型的日期对象

```{r}
(x <- Sys.time())
class(x)

data.table::second(x) # 取秒
format(x, format = "%S")

data.table::minute(x) # 取分
format(x, format = "%M")

data.table::hour(x) # 取时
format(x, format = "%H")
data.table::yday(x) # 此刻在一年的第几天

data.table::wday(x) # 此刻在一周的第几天，星期日是第1天，星期六是第7天
data.table::mday(x) # 此刻在当月第几天
format(x, format = "%d")

weekdays(x)
weekdays(x, abbreviate = T)

data.table::week(x) # 此刻在第几周
data.table::isoweek(x)

data.table::month(x) # 此刻在第几月
format(x, format = "%m")

months(x)
months(x, abbreviate = T)

data.table::quarter(x) # 此刻在第几季度
quarters(x)

data.table::year(x) # 取年
format(x, format = "%Y")
```

::: rmdtip
`format()` 是一个泛型函数，此刻命名空间有 `r length(methods(format))` 方法。
`format.Date()`， `format.difftime()`， `format.POSIXct()` 和 `format.POSIXlt()` 四个函数通过格式化不同类型的日期数据对象抽取指定部分。

```{r}
format(difftime(Sys.time(), x, units = "secs"))
```

日期转化详见 [@Brian_2001_date;@Gabor_2004_date]
:::

## 空值 {#subsec:null}

移除`list()` 列表里的为 `NULL` 元素

```{r}
rm_null <- function(l) Filter(Negate(is.null), l)
```



## 字符串 {#subsec:character}

### 命名捕捉 {#subsubsec:named-capture}

函数 `regexpr(..., perl = TRUE)` 和 `gregexpr(..., perl = TRUE)` 支持命名捕捉

```{r}
## named capture
notables <- c("  Ben Franklin and Jefferson Davis",
              "\tMillard Fillmore")
# name groups 'first' and 'last'
name.rex <- "(?<first>[[:upper:]][[:lower:]]+) (?<last>[[:upper:]][[:lower:]]+)"

(parsed <- regexpr(name.rex, notables, perl = TRUE))

attr(parsed, 'capture.names')

regmatches(notables, parsed)
```

希望返回一个 data.frame，列名是指定的 named group 名字

```{r}
# 有多个结果
(idx <- gregexpr(name.rex, notables, perl = TRUE))

regmatches(notables, idx)

attr(idx[[1]], 'capture.names')
```

```{r}
data.frame(notable = notables) %>% 
tidyr::extract(
    notable, c("first", "last"), name.rex, 
    remove = FALSE
  )
```


### 精确匹配 {#subsubsec:exact-match}

`fixed = TRUE`

### 模糊匹配 {#subsubsec:fuzzy-match}

近似字符串匹配 (Approximate String Matching) 也叫模糊匹配 (Fuzzy Matching)

`agrep()` `agrepl()` `aregexec()` `adist()`

```{r}
agrep(pattern = "lasy", x = "1 lazy 2")
agrep("lasy", c(" 1 lazy 2", "1 lasy 2"), max = list(sub = 0))
agrep("laysy", c("1 lazy", "1", "1 LAZY"), max = 2)
agrep("laysy", c("1 lazy", "1", "1 LAZY"), max = 2, value = TRUE)
agrep("laysy", c("1 lazy", "1", "1 LAZY"), max = 2, ignore.case = TRUE)

agrepl(pattern = "lasy", x = "1 lazy 2")
```

```{r}
## Cf. the examples for agrep.
x <- c("1 lazy", "1", "1 LAZY")

aregexec("laysy", x, max.distance = 2)
aregexec("(lay)(sy)", x, max.distance = 2)
aregexec("(lay)(sy)", x, max.distance = 2, ignore.case = TRUE)

m <- aregexec("(lay)(sy)", x, max.distance = 2)
regmatches(x, m)
```


```{r}
## Cf. https://en.wikipedia.org/wiki/Levenshtein_distance
adist("kitten", "sitting")
## To see the transformation counts for the Levenshtein distance:
drop(attr(adist("kitten", "sitting", counts = TRUE), "counts"))
## To see the transformation sequences:
attr(adist(c("kitten", "sitting"), counts = TRUE), "trafos")

## Cf. the examples for agrep:
adist("lasy", "1 lazy 2")
## For a "partial approximate match" (as used for agrep):
adist("lasy", "1 lazy 2", partial = TRUE)
```

案例

`help.search()`

### 替换 {#subsubsec:replace}

相比于 `sprintf()` 格式化输出字符串的方式替换，它的优势在于提示性，或者说代码的可读性

```{r}
glue_data <- function(param, text) {
  idx <- gregexpr('\\{[^}]*\\}', text)[[1L]]
  keys <- substring(text, idx, idx + attr(idx, 'match.length') - 1L)
  for (key in keys) {
    text <- gsub(key, param[[gsub('[{}]', '', key)]], text, fixed = TRUE)
  }
  text
}
cat(glue_data(
  param = list(table = 'flights', origin = 'JFK'),
  text = "
  select count(*) as n
  from {table}
  where origin = '{origin}'
  "
))
```


### 提取 {#subsubsec:extract}

从 text 中抽取给定模式 pattern 的字符串

```{r}
str_extract <- function(text, pattern, ...) regmatches(text, regexpr(pattern, text, ...))
```

举个栗子，比如提取数字

```{r}
shopping_list <- c("apples x4", "bag of flour", "bag of sugar", "milk x2")
stringr::str_extract(shopping_list, "\\d")
# 注意二者的差别
str_extract(shopping_list, "\\d")
```

提取所有符合匹配模式的字符串

```{r}
str_extract_all <- function(text, pattern, ...) regmatches(text, gregexpr(pattern, text, ...))
```

举个栗子，提取其中的英文字母

```{r}
str_extract_all(shopping_list, "[a-z]+")
stringr::str_extract_all(shopping_list, "[a-z]+")
```

## 表达式 {#subsec:expression}

```{r}
# %||% 中缀符
# x 是空值或者长度为 0 则保留 y 否则保留 x
function(x, y) if (is.null(x) || length(x) == 0) y else x
```

## 向量 {#subsec:vector} 
